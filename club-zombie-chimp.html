<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CLUB DECAY: Chimp vs Zombies</title>
  <style>
    :root{
      --bg:#05030a;
      --ui:#e8e8ff;
      --muted:#9aa0c6;
      --accent:#b300ff;
      --accent2:#00ffd5;
      --danger:#ff3b6b;
      --ok:#7CFF6B;
    }
    html,body{
      height:100%; margin:0;
      background: radial-gradient(1200px 800px at 50% 40%, #160a30 0%, #05030a 55%, #02010a 100%);
      color:var(--ui);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      overflow:hidden;
    }
    #wrap{height:100%; display:grid; place-items:center;}

    /* Fullscreen-friendly canvas */
    canvas{
      width:min(96vw, 1280px);
      height:auto;
      max-height:88vh;
      aspect-ratio: 16 / 9;

      image-rendering: pixelated;
      image-rendering: crisp-edges;
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 16px;
      background: #03020a;
      box-shadow:
        0 18px 70px rgba(0,0,0,0.70),
        0 0 0 1px rgba(179,0,255,0.20) inset,
        0 0 70px rgba(179,0,255,0.10);
    }
    .hint{
      position:fixed; left:14px; bottom:12px;
      font-size:12px; color:var(--muted);
      user-select:none;
      opacity:0.92;
    }
    .hint b{color:var(--ui)}
    .topright{
      position:fixed; right:14px; top:12px;
      font-size:12px; color:var(--muted);
      user-select:none;
      opacity:0.92;
      text-align:right;
    }
    .topright .tag{color:rgba(255,255,255,0.66)}
    a{color:var(--accent2)}
  </style>
</head>
<body>
<div id="wrap">
  <!-- Keep the same internal pixel size; CSS scales it up for fullscreen -->
  <canvas id="c" width="960" height="540"></canvas>
</div>

<div class="topright">
  CLUB DECAY MINI-GAME<br/>
  <span class="tag">One-file build · Waves + Shop</span>
</div>

<div class="hint">
  <b>Move</b> WASD · <b>Aim/Shoot</b> Mouse · <b>Punch</b> Space · <b>Swap</b> 1/2/3 · <b>Shop</b> B (between waves) · <b>Interact</b> E · <b>Pause</b> P · <b>Restart</b> Enter
</div>

<script>
(() => {
  // ======== Canvas & Pixel World ========
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });

  // Viewport logical res (rendered then upscaled)
  const W = 320, H = 180;
  const world = document.createElement('canvas');
  world.width = W; world.height = H;
  const g = world.getContext('2d', { alpha: false });

  // ======== Utilities ========
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const rand = (a,b)=>a+Math.random()*(b-a);
  const randi = (a,b)=> (a + Math.floor(Math.random()*(b-a+1)));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const dist2 = (ax,ay,bx,by)=>{ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; };

  // Fixed timestep
  let last = performance.now();
  let acc = 0;
  const DT = 1/60;

  // ======== Input ========
  const keys = new Set();
  const pressed = new Set();
  let mouse = { x: W/2, y: H/2, down:false };

  window.addEventListener('keydown', (e)=>{
    const k = e.key.toLowerCase();
    keys.add(k);
    pressed.add(k);
    if([" ", "arrowup","arrowdown","arrowleft","arrowright"].includes(e.key)) e.preventDefault();
  }, {passive:false});

  window.addEventListener('keyup', (e)=> keys.delete(e.key.toLowerCase()));

  canvas.addEventListener('mousemove', (e)=>{
    const rect = canvas.getBoundingClientRect();
    const sx = (e.clientX - rect.left) / rect.width;
    const sy = (e.clientY - rect.top) / rect.height;
    mouse.x = clamp(Math.floor(sx * W), 0, W-1);
    mouse.y = clamp(Math.floor(sy * H), 0, H-1);
  });

  canvas.addEventListener('mousedown', ()=>{ mouse.down=true; });
  window.addEventListener('mouseup', ()=>{ mouse.down=false; });

  // ======== State ========
  const STATE = { BUNKER:1, PLAY:2, DEAD:3 };
  let state = STATE.BUNKER;
  let paused = false;

  // High score
  const HS_KEY = "club_chimp_zombie_highscore_v2";
  let highScore = Number(localStorage.getItem(HS_KEY) || 0);

  // ======== FX ========
  let shake = 0;
  const sparks = [];
  const floats = [];
  const particles = (x,y,count,spread,speed,life,colA,colB)=>{
    for(let i=0;i<count;i++){
      const a = rand(0,Math.PI*2);
      const s = rand(speed*0.3, speed);
      sparks.push({
        x,y,
        vx: Math.cos(a)*s + rand(-spread,spread),
        vy: Math.sin(a)*s + rand(-spread,spread),
        life: rand(life*0.6, life),
        col: (Math.random()<0.5?colA:colB)
      });
    }
  };

  // ======== Big Map + Camera ========
  const MAP_W = 1120;
  const MAP_H = 720;
  const camera = { x: 0, y: 0 };
  function updateCamera(){
    camera.x = clamp(player.x - W/2, 0, MAP_W - W);
    camera.y = clamp(player.y - H/2, 0, MAP_H - H);
  }

  // ======== Arena ========
  const arena = { x0: 36, y0: 30, x1: MAP_W-36, y1: MAP_H-36 };

  // ======== Disco floor (CALM, not strobe) ========
  const disco = ["#0b0720","#120a2a","#1a0c35","#221246","#2a1658","#00ffd5","#b300ff","#ff3b6b","#7CFF6B","#ffd24a","#5aa7ff"];
  function discoCol(ix,iy,t){
    // Slower cycling + stable pattern (less flicker)
    const step = Math.floor(t*1.5); // slower than before
    const k = (ix*11 + iy*17 + step) % disco.length;
    return disco[k];
  }

  // ======== Sprites ========
  function drawChimp(px,py,dir,frame,aimAng){
    const x = Math.floor(px), y = Math.floor(py);
    const fur = "#6b4a2f";
    const dark = "#3b2416";
    const face = "#b88960";
    const eye = "#f4f4ff";
    const pupil = "#151018";
    const violet = "#b300ff";
    const teal = "#00ffd5";
    const bob = Math.floor(Math.sin(frame*0.3)*1);

    g.fillStyle = "rgba(0,0,0,0.35)";
    g.fillRect(x-6, y+8, 12, 3);

    g.fillStyle = fur;  g.fillRect(x-5, y-6+bob, 10, 10);
    g.fillStyle = dark; g.fillRect(x-3, y-4+bob, 6, 6);

    g.fillStyle = fur;  g.fillRect(x-6, y-14+bob, 12, 10);
    g.fillStyle = face; g.fillRect(x-4, y-12+bob, 8, 6);

    const ex = dir>0 ? 2 : -4;
    g.fillStyle = eye;   g.fillRect(x+ex, y-12+bob, 3, 2);
    g.fillStyle = pupil; g.fillRect(x+ex+1, y-12+bob, 1, 1);

    g.fillStyle = violet; g.fillRect(x-5, y+1+bob, 10, 2);
    g.fillStyle = teal;   g.fillRect(x-1, y-2+bob, 2, 2);

    g.fillStyle = fur;
    g.fillRect(x-7, y-5+bob, 2, 8);
    g.fillRect(x+5, y-5+bob, 2, 8);

    const ax = x + Math.cos(aimAng)*10;
    const ay = y + Math.sin(aimAng)*10;
    g.strokeStyle = "rgba(0,255,213,0.32)";
    g.beginPath();
    g.moveTo(x, y-2+bob);
    g.lineTo(ax, ay);
    g.stroke();
  }

  function drawZombie(z){
    const x = Math.floor(z.x), y = Math.floor(z.y);
    const bob = Math.floor(Math.sin(z.t*0.2)*1);

    g.fillStyle = "rgba(0,0,0,0.35)";
    g.fillRect(x-5, y+7, 10, 3);

    g.fillStyle = z.elite ? "#23ff86" : "#5aa7ff";
    g.fillRect(x-4, y-6+bob, 8, 10);
    g.fillStyle = z.elite ? "#00c866" : "#2d6fe0";
    g.fillRect(x-5, y-14+bob, 10, 9);

    g.fillStyle = "#0a0a12";
    g.fillRect(x-3, y-12+bob, 2, 2);
    g.fillRect(x+1, y-12+bob, 2, 2);
    g.fillStyle = "#ff3b6b";
    g.fillRect(x-1, y-9+bob, 2, 1);

    g.fillStyle = z.elite ? "#00c866" : "#2d6fe0";
    g.fillRect(x-7, y-4+bob, 2, 7);
    g.fillRect(x+5, y-4+bob, 2, 7);
  }

  function drawBoss(b){
    const x = Math.floor(b.x), y = Math.floor(b.y);
    const wob = Math.floor(Math.sin(b.t*0.12)*2);

    g.fillStyle = "rgba(0,0,0,0.45)";
    g.fillRect(x-16, y+18, 32, 6);

    g.fillStyle = "#ff3b6b";
    g.fillRect(x-14, y-8+wob, 28, 28);
    g.fillStyle = "#ff7aa0";
    g.fillRect(x-16, y-26+wob, 32, 20);

    g.fillStyle = "#0a0a12";
    g.fillRect(x-9, y-18+wob, 6, 4);
    g.fillRect(x+3, y-18+wob, 6, 4);
    g.fillStyle = "#b300ff";
    g.fillRect(x-7, y-17+wob, 2, 2);
    g.fillRect(x+5, y-17+wob, 2, 2);

    g.fillStyle = "#e8e8ff";
    g.fillRect(x-6, y-10+wob, 12, 3);

    g.fillStyle = "rgba(0,0,0,0.25)";
    g.fillRect(x-2, y-2+wob, 4, 6);

    g.fillStyle = "#00ffd5";
    g.fillRect(x-13, y-28+wob, 4, 4);
    g.fillRect(x+9, y-28+wob, 4, 4);
  }

  // ======== Backdrop ========
  function drawArenaBackdrop(t){
    g.fillStyle = "#050214";
    g.fillRect(0,0,W,H);

    // disco tiles (viewport slice of world)
    const tile = 10;
    const wx0 = Math.floor(camera.x / tile) * tile;
    const wy0 = Math.floor(camera.y / tile) * tile;
    const wx1 = camera.x + W + tile;
    const wy1 = camera.y + H + tile;

    for(let wy = wy0; wy < wy1; wy += tile){
      for(let wx = wx0; wx < wx1; wx += tile){
        const inArena = (wx+tile > arena.x0 && wx < arena.x1 && wy+tile > arena.y0 && wy < arena.y1);
        const sx = Math.floor(wx - camera.x);
        const sy = Math.floor(wy - camera.y);

        if(inArena){
          const ix = Math.floor(wx/tile), iy = Math.floor(wy/tile);
          g.fillStyle = discoCol(ix,iy,t);
          g.fillRect(sx, sy, tile, tile);

          // gentle gloss (not flashing)
          g.fillStyle = "rgba(255,255,255,0.04)";
          g.fillRect(sx+1, sy+1, tile-2, 1);
        }else{
          g.fillStyle = "rgba(10,6,22,0.88)";
          g.fillRect(sx, sy, tile, tile);
        }
      }
    }

    // vignette to calm edges (reduces “seizure” feel)
    g.fillStyle = "rgba(0,0,0,0.18)";
    g.fillRect(0,0,W,H);
    g.fillStyle = "rgba(0,0,0,0.22)";
    g.fillRect(0,0,W,18);

    // walls
    const ax0 = arena.x0 - camera.x;
    const ay0 = arena.y0 - camera.y;
    const aw = (arena.x1 - arena.x0);
    const ah = (arena.y1 - arena.y0);

    g.strokeStyle = "rgba(0,255,213,0.16)";
    g.strokeRect(Math.floor(ax0)+1, Math.floor(ay0)+1, Math.floor(aw)-2, Math.floor(ah)-2);

    g.strokeStyle = "rgba(179,0,255,0.58)";
    g.strokeRect(Math.floor(ax0), Math.floor(ay0), Math.floor(aw), Math.floor(ah));
  }

  // ======== Weapons ========
  // More guns + strong damage. Still 3-slot swapping.
  const WEAPONS = [
    { id:"pistol", name:"Pistol", color:"#00ffd5",  fireRate: 7.5, spread: 0.03, speed: 260, dmg: 34, pellets:1, recoil:0.75, price:0 },
    { id:"smg",    name:"SMG",   color:"#7CFF6B",  fireRate: 15.0, spread: 0.07, speed: 270, dmg: 15, pellets:1, recoil:0.45, price:90 },
    { id:"ar",     name:"AR",    color:"#5aa7ff",  fireRate: 10.5, spread: 0.04, speed: 290, dmg: 26, pellets:1, recoil:0.6,  price:140 },
    { id:"burst",  name:"Burst", color:"#ffd24a",  fireRate: 4.0,  spread: 0.03, speed: 310, dmg: 20, pellets:3, burstGap:0.06, recoil:1.0, price:170 },
    { id:"shotgun",name:"Shotgun",color:"#ff3b6b", fireRate: 1.7, spread: 0.22, speed: 230, dmg: 22, pellets:7, recoil:2.4, price:160 },
    { id:"sniper", name:"Sniper",color:"#e8e8ff",  fireRate: 1.1, spread: 0.005,speed: 420, dmg: 120,pellets:1, recoil:3.2, price:260 },
    { id:"laser",  name:"Laser", color:"#b300ff",  fireRate: 11.0, spread: 0.01, speed: 380, dmg: 28, pellets:1, recoil:0.35, pierce:true, price:220 },
    { id:"rail",   name:"Railgun",color:"#00ffd5", fireRate: 0.85,spread: 0.0,  speed: 520, dmg: 210,pellets:1, recoil:4.0, pierce:true, price:420 },
    { id:"rocket", name:"Rocket",color:"#ff3b6b",  fireRate: 0.9, spread: 0.02, speed: 170, dmg: 80, pellets:1, recoil:2.6, splash:28, price:330 },
    { id:"flame",  name:"Flame", color:"#ffd24a",  fireRate: 22.0,spread: 0.14, speed: 160, dmg: 9,  pellets:1, recoil:0.18, dot:2.2, price:250 },
    { id:"hammer", name:"Hammer",color:"#ffd24a",  melee:true, dmg: 90, cooldown: 0.48, reach: 16, price:120 } // FIXED: does damage
  ];
  const byId = Object.fromEntries(WEAPONS.map(w=>[w.id,w]));

  // ======== Objects ========
  const player = {
    x: MAP_W/2, y: MAP_H/2,
    vx: 0, vy: 0,
    hp: 100,
    dir: 1,
    invuln: 0,
    frame: 0,
    score: 0,
    cash: 0,
    timeAlive: 0,
    selected: [],
    slot: 0,
    shootCD: 0,
    meleeCD: 0,
    burstLeft: 0,
    burstCD: 0
  };

  const bullets = []; // {x,y,vx,vy,dmg,life,col,pierce,splash,dot}
  const zombies = []; // {x,y,vx,vy,hp,spd,t,elite,burn}
  let boss = null;
  let bossTriggered = false;

  // “More to do”: crates between waves
  const crates = []; // {x,y,open:false,kind}
  function spawnCrates(){
    crates.length = 0;
    const n = 2;
    for(let i=0;i<n;i++){
      const x = rand(arena.x0+40, arena.x1-40);
      const y = rand(arena.y0+40, arena.y1-40);
      crates.push({x,y,open:false,kind: (Math.random()<0.55 ? "cash" : "hp")});
    }
  }

  function resetRun(){
    bullets.length = 0;
    zombies.length = 0;
    sparks.length = 0;
    floats.length = 0;
    crates.length = 0;
    boss = null;
    bossTriggered = false;
    shake = 0;

    player.x = MAP_W/2; player.y = MAP_H/2;
    player.vx = 0; player.vy = 0;
    player.hp = 100;
    player.invuln = 0;
    player.frame = 0;
    player.score = 0;
    player.cash = 0;
    player.timeAlive = 0;
    player.slot = 0;
    player.shootCD = 0;
    player.meleeCD = 0;
    player.burstLeft = 0;
    player.burstCD = 0;

    waveInit();
    updateCamera();
  }

  // ======== Bunker ========
  let bunkerCursor = 0;
  let bunkerPicked = [];
  function bunkerInit(){
    bunkerCursor = 0;
    bunkerPicked = ["pistol","shotgun","hammer"]; // give you melee by default now
  }
  bunkerInit();

  // ======== Waves + Shop ========
  const wave = {
    n: 1,
    phase: "REST", // REST | FIGHT | CLEAR | SHOP
    timer: 2.0,
    toSpawn: 0,
    spawned: 0,
    spawnCD: 0
  };

  function waveInit(){
    wave.n = 1;
    wave.phase = "REST";
    wave.timer = 2.4;
    wave.toSpawn = 0;
    wave.spawned = 0;
    wave.spawnCD = 0;
    spawnCrates();
  }

  function beginWave(){
    wave.phase = "FIGHT";
    wave.spawned = 0;

    // fewer zombies overall, more readable
    const base = 6 + Math.floor(wave.n * 1.6);
    wave.toSpawn = clamp(base, 6, 26);
    wave.spawnCD = 0.18;

    particles(player.x, player.y, 22, 1.7, 80, 0.30, "#00ffd5", "#b300ff");
    shake = Math.max(shake, 2);
  }

  function endWave(){
    wave.phase = "REST";
    wave.timer = 2.2;
    wave.n++;
    spawnCrates();
  }

  let shopOpen = false;

  // ======== Spawn ========
  function spawnZombie(elite=false){
    const side = randi(0,3);
    let x,y;
    if(side===0){ x = arena.x0-10; y = rand(arena.y0, arena.y1); }
    if(side===1){ x = arena.x1+10; y = rand(arena.y0, arena.y1); }
    if(side===2){ x = rand(arena.x0, arena.x1); y = arena.y0-10; }
    if(side===3){ x = rand(arena.x0, arena.x1); y = arena.y1+10; }

    const hp = elite ? (95 + wave.n*6) : (60 + wave.n*4);
    const spd = elite ? rand(20,30) : rand(15,24);
    zombies.push({ x,y,vx:0,vy:0,hp,spd,t:rand(0,999), elite, burn:0 });
  }

  function spawnBoss(){
    bossTriggered = true;
    const side = randi(0,3);
    let x,y;
    if(side===0){ x = arena.x0-26; y = rand(arena.y0, arena.y1); }
    if(side===1){ x = arena.x1+26; y = rand(arena.y0, arena.y1); }
    if(side===2){ x = rand(arena.x0, arena.x1); y = arena.y0-26; }
    if(side===3){ x = rand(arena.x0, arena.x1); y = arena.y1+26; }

    const maxHp = 1350 + wave.n*120;
    boss = { x,y, hp:maxHp, maxHp, spd: 18, t:0, atkCD: 1.10 };
    particles(x,y,90,1.8,80,0.9,"#ff3b6b","#b300ff");
    shake = 7;
  }

  // ======== Combat ========
  function shootWeapon(w, ang){
    const ox = player.x;
    const oy = player.y-2;

    const makeBullet = (a)=>{
      bullets.push({
        x: ox + Math.cos(a)*6,
        y: oy + Math.sin(a)*6,
        vx: Math.cos(a)*w.speed,
        vy: Math.sin(a)*w.speed,
        dmg: w.dmg,
        life: 1.0,
        col: w.color,
        pierce: !!w.pierce,
        splash: w.splash || 0,
        dot: w.dot || 0
      });
    };

    if(w.burstGap){
      // Burst fires multiple pellets as a controlled burst
      player.burstLeft = w.pellets;
      player.burstCD = 0;
      // first shot now
      const a = ang + rand(-w.spread, w.spread);
      makeBullet(a);
      player.burstLeft--;
    } else {
      for(let p=0;p<(w.pellets||1);p++){
        const a = ang + rand(-w.spread, w.spread);
        makeBullet(a);
      }
    }

    particles(ox+Math.cos(ang)*7, oy+Math.sin(ang)*7, 7, 0.7, 55, 0.28, w.color, "#e8e8ff");
    shake = Math.max(shake, w.recoil || 0.6);
  }

  function applySplash(x,y,rad,dmg,col){
    const r2 = rad*rad;
    for(const z of zombies){
      if(dist2(x,y,z.x,z.y) <= r2){
        z.hp -= Math.floor(dmg*0.75);
        particles(z.x,z.y,10,1.0,60,0.22,col,"#e8e8ff");
      }
    }
    if(boss && dist2(x,y,boss.x,boss.y) <= (rad+18)*(rad+18)){
      boss.hp -= Math.floor(dmg*0.45);
      particles(boss.x,boss.y,14,1.2,70,0.28,col,"#ff3b6b");
    }
  }

  function meleeHit(w, ang){
    const reach = w.reach || 14;
    const hx = player.x + Math.cos(ang)*reach;
    const hy = player.y + Math.sin(ang)*reach;
    let hitAny = false;

    for(const z of zombies){
      if(dist2(hx,hy,z.x,z.y) < (12*12)){
        z.hp -= w.dmg;
        hitAny = true;
        particles(z.x,z.y,20,1.3,65,0.38,"#ffd24a","#ff3b6b");
        floats.push({x:z.x,y:z.y-6,vx:rand(-8,8),vy:rand(-18,-10),life:0.7,text:`-${w.dmg}`,col:"#ffd24a"});
        shake = Math.max(shake, 3.8);
      }
    }

    if(boss && dist2(hx,hy,boss.x,boss.y) < (26*26)){
      boss.hp -= w.dmg;
      hitAny = true;
      particles(boss.x,boss.y,26,1.7,75,0.48,"#ffd24a","#b300ff");
      floats.push({x:boss.x,y:boss.y-18,vx:rand(-10,10),vy:rand(-20,-12),life:0.8,text:`-${w.dmg}`,col:"#ffd24a"});
      shake = Math.max(shake, 6.0);
    }

    particles(player.x+Math.cos(ang)*10, player.y+Math.sin(ang)*10, hitAny?12:7, 1.1, 45, 0.24, "#ffd24a", "rgba(255,255,255,0.75)");
  }

  function hurtPlayer(amount){
    if(player.invuln > 0) return;
    player.hp -= amount;
    player.invuln = 0.55;
    shake = Math.max(shake, 6);
    particles(player.x, player.y, 42, 1.9, 80, 0.65, "#ff3b6b", "#b300ff");
  }

  // ======== UI Text ========
  function drawText(txt,x,y,scale=1,color="#e8e8ff"){
    g.fillStyle = color;
    g.font = `${8*scale}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace`;
    g.fillText(txt, x, y);
  }
  function niceTime(s){
    const m = Math.floor(s/60);
    const r = Math.floor(s%60).toString().padStart(2,"0");
    return `${m}:${r}`;
  }

  // ======== Shop ========
  const SHOP_EXCLUSIVE = ["ar","burst","sniper","laser","rocket","flame","rail"];
  let shopCursor = 0;
  function canBuy(id){
    const w = byId[id];
    if(!w) return false;
    if(player.selected.includes(id)) return false;
    return player.cash >= (w.price||0);
  }
  function buyWeapon(id){
    const w = byId[id];
    if(!w) return;
    if(!canBuy(id)) return;

    player.cash -= w.price;

    // Put into current slot, or first empty, else replace current slot
    let slot = player.selected.findIndex(v=>!v);
    if(slot < 0) slot = player.slot;
    player.selected[slot] = id;

    particles(player.x, player.y, 30, 1.6, 90, 0.35, "#00ffd5", "#b300ff");
    shake = Math.max(shake, 3);
  }

  // ======== Update ========
  function update(dt){
    if(paused) return;

    // FX
    for(let i=sparks.length-1;i>=0;i--){
      const p = sparks[i];
      p.x += p.vx*dt;
      p.y += p.vy*dt;
      p.vx *= Math.pow(0.02, dt);
      p.vy *= Math.pow(0.02, dt);
      p.life -= dt;
      if(p.life<=0) sparks.splice(i,1);
    }
    for(let i=floats.length-1;i>=0;i--){
      const f = floats[i];
      f.x += f.vx*dt;
      f.y += f.vy*dt;
      f.vx *= Math.pow(0.25, dt);
      f.vy += 30*dt;
      f.life -= dt;
      if(f.life<=0) floats.splice(i,1);
    }

    // Bunker screen
    if(state === STATE.BUNKER){
      if(pressed.has("arrowdown") || pressed.has("s")) bunkerCursor = (bunkerCursor+1) % WEAPONS.length;
      if(pressed.has("arrowup") || pressed.has("w")) bunkerCursor = (bunkerCursor-1+WEAPONS.length) % WEAPONS.length;

      if(pressed.has("enter") || pressed.has("e")){
        const id = WEAPONS[bunkerCursor].id;
        const idx = bunkerPicked.indexOf(id);
        if(idx>=0) bunkerPicked.splice(idx,1);
        else{
          if(bunkerPicked.length < 3) bunkerPicked.push(id);
          else bunkerPicked[bunkerPicked.length-1] = id;
        }
      }
      if(pressed.has(" ")){
        if(bunkerPicked.length === 0) bunkerPicked = ["pistol"];
        player.selected = bunkerPicked.slice(0,3);
        resetRun();
        state = STATE.PLAY;
      }
      pressed.clear();
      return;
    }

    // Dead
    if(state === STATE.DEAD){
      if(pressed.has("enter")){
        resetRun();
        state = STATE.PLAY;
      }
      if(pressed.has("escape")){
        state = STATE.BUNKER;
        bunkerInit();
      }
      pressed.clear();
      return;
    }

    // Play
    if(state === STATE.PLAY){
      if(pressed.has("p")) paused = !paused;

      // Shop toggle during REST only
      if(pressed.has("b") && wave.phase === "REST"){
        shopOpen = !shopOpen;
        shopCursor = 0;
      }

      // If shop open, handle shop controls and skip combat input
      if(shopOpen){
        if(pressed.has("arrowdown") || pressed.has("s")) shopCursor = (shopCursor+1) % SHOP_EXCLUSIVE.length;
        if(pressed.has("arrowup") || pressed.has("w")) shopCursor = (shopCursor-1+SHOP_EXCLUSIVE.length) % SHOP_EXCLUSIVE.length;
        if(pressed.has("enter") || pressed.has("e")){
          buyWeapon(SHOP_EXCLUSIVE[shopCursor]);
        }
        // close shop
        if(pressed.has("escape") || pressed.has("b")) shopOpen = false;
        pressed.clear();
        return;
      }

      player.timeAlive += dt;
      player.frame += 1;

      // swap weapons
      if(pressed.has("1")) player.slot = 0;
      if(pressed.has("2")) player.slot = 1;
      if(pressed.has("3")) player.slot = 2;

      const wId = player.selected[player.slot] || player.selected[0] || "pistol";
      const weapon = byId[wId] || byId.pistol;

      // movement
      let mx=0,my=0;
      if(keys.has("a")) mx -= 1;
      if(keys.has("d")) mx += 1;
      if(keys.has("w")) my -= 1;
      if(keys.has("s")) my += 1;

      const spd = 64;
      const len = Math.hypot(mx,my) || 1;
      mx /= len; my /= len;

      player.vx = lerp(player.vx, mx*spd, 0.2);
      player.vy = lerp(player.vy, my*spd, 0.2);

      player.x += player.vx*dt;
      player.y += player.vy*dt;

      player.x = clamp(player.x, arena.x0+6, arena.x1-6);
      player.y = clamp(player.y, arena.y0+8, arena.y1-8);

      updateCamera();

      // aim world
      const aimWorldX = camera.x + mouse.x;
      const aimWorldY = camera.y + mouse.y;
      const ang = Math.atan2(aimWorldY - player.y, aimWorldX - player.x);
      player.dir = Math.cos(ang) >= 0 ? 1 : -1;

      // invuln
      player.invuln = Math.max(0, player.invuln - dt);

      // burst timing (for Burst gun)
      if(player.burstLeft > 0){
        player.burstCD -= dt;
        if(player.burstCD <= 0){
          player.burstCD = byId.burst.burstGap;
          const a = ang + rand(-byId.burst.spread, byId.burst.spread);
          bullets.push({
            x: player.x + Math.cos(a)*6,
            y: player.y-2 + Math.sin(a)*6,
            vx: Math.cos(a)*byId.burst.speed,
            vy: Math.sin(a)*byId.burst.speed,
            dmg: byId.burst.dmg,
            life: 1.0,
            col: byId.burst.color,
            pierce:false,
            splash:0,
            dot:0
          });
          particles(player.x+Math.cos(a)*7, player.y-2+Math.sin(a)*7, 5, 0.6, 45, 0.22, byId.burst.color, "#e8e8ff");
          player.burstLeft--;
        }
      }

      // cooldowns
      player.shootCD = Math.max(0, player.shootCD - dt);
      player.meleeCD = Math.max(0, player.meleeCD - dt);

      // wave logic
      if(wave.phase === "REST"){
        wave.timer -= dt;

        // interact crates
        if(pressed.has("e")){
          for(const c of crates){
            if(c.open) continue;
            if(dist2(c.x,c.y,player.x,player.y) < (16*16)){
              c.open = true;
              if(c.kind === "cash"){
                const gain = 70 + Math.floor(wave.n*12);
                player.cash += gain;
                player.score += gain * 0.8;
                floats.push({x:c.x,y:c.y-10,vx:rand(-10,10),vy:rand(-24,-14),life:0.9,text:`+${gain}$`,col:"#00ffd5"});
                particles(c.x,c.y,28,1.8,90,0.35,"#00ffd5","#b300ff");
              } else {
                const heal = 18 + Math.floor(wave.n*1.5);
                player.hp = clamp(player.hp + heal, 0, 100);
                floats.push({x:c.x,y:c.y-10,vx:rand(-10,10),vy:rand(-24,-14),life:0.9,text:`+${heal}HP`,col:"#7CFF6B"});
                particles(c.x,c.y,24,1.6,80,0.32,"#7CFF6B","#00ffd5");
              }
              shake = Math.max(shake, 2);
              break;
            }
          }
        }

        if(wave.timer <= 0){
          wave.phase = "FIGHT";
          beginWave();
        }
      } else if(wave.phase === "FIGHT"){
        // spawn controlled
        wave.spawnCD -= dt;
        if(wave.spawned < wave.toSpawn && wave.spawnCD <= 0){
          wave.spawnCD = 0.22;
          const eliteChance = clamp((wave.n - 3) / 12, 0, 0.35);
          spawnZombie(Math.random() < eliteChance);
          wave.spawned++;
        }
        if(wave.spawned >= wave.toSpawn) wave.phase = "CLEAR";

        // boss milestone
        if(!bossTriggered && wave.n >= 8){
          spawnBoss();
        }
      } else if(wave.phase === "CLEAR"){
        if(zombies.length === 0 && !boss){
          endWave();
        }
      }

      // shooting/melee only if fighting or clearing (you can still shoot during rest, but it’s chill)
      const canCombat = (wave.phase !== "REST") || mouse.down || pressed.has(" ");
      if(canCombat){
        if(weapon.melee){
          if((mouse.down || pressed.has(" ")) && player.meleeCD <= 0){
            player.meleeCD = weapon.cooldown || 0.55;
            meleeHit(weapon, ang);
          }
        }else{
          const rate = weapon.fireRate || 6;
          if(mouse.down && player.shootCD <= 0){
            player.shootCD = 1 / rate;
            shootWeapon(weapon, ang);
          }
          // punch always on space
          if(pressed.has(" ") && player.meleeCD <= 0){
            player.meleeCD = 0.42;
            meleeHit({dmg:30, reach:12}, ang);
          }
        }
      }

      // bullets
      for(let i=bullets.length-1;i>=0;i--){
        const b = bullets[i];
        b.life -= dt;
        b.x += b.vx*dt;
        b.y += b.vy*dt;

        if(b.life<=0 || b.x<0 || b.x>MAP_W || b.y<0 || b.y>MAP_H){
          bullets.splice(i,1);
          continue;
        }

        // hit zombies
        for(let j=zombies.length-1;j>=0;j--){
          const z = zombies[j];
          if(dist2(b.x,b.y,z.x,z.y) < (7*7)){
            z.hp -= b.dmg;
            if(b.dot) z.burn = Math.max(z.burn, b.dot);
            particles(b.x,b.y,10,0.9,55,0.25,b.col,"#e8e8ff");

            if(b.splash) applySplash(b.x,b.y,b.splash,b.dmg,b.col);

            if(!b.pierce) bullets.splice(i,1);

            if(z.hp<=0){
              zombies.splice(j,1);
              const reward = z.elite ? 40 : 24;
              player.score += reward;
              player.cash += Math.floor(reward * 0.8);
              particles(z.x,z.y,18,1.2,65,0.45,"#00ffd5","#b300ff");
            }
            break;
          }
        }

        // hit boss
        if(boss && dist2(b.x,b.y,boss.x,boss.y) < (22*22)){
          boss.hp -= b.dmg;
          if(b.splash) applySplash(b.x,b.y,b.splash,b.dmg,b.col);
          particles(b.x,b.y,14,1.2,70,0.33,b.col,"#ff3b6b");
          if(!b.pierce) bullets.splice(i,1);
          player.score += 3;
        }
      }

      // zombies update
      for(let i=zombies.length-1;i>=0;i--){
        const z = zombies[i];
        z.t += 1;

        // burn DOT
        if(z.burn > 0){
          z.burn = Math.max(0, z.burn - dt);
          if(Math.random() < 0.25){
            z.hp -= 2;
            particles(z.x,z.y,2,0.3,20,0.15,"#ffd24a","#ff3b6b");
          }
        }

        const a = Math.atan2(player.y - z.y, player.x - z.x);
        z.vx = Math.cos(a)*z.spd;
        z.vy = Math.sin(a)*z.spd;
        z.x += z.vx*dt;
        z.y += z.vy*dt;

        z.x = clamp(z.x, arena.x0-12, arena.x1+12);
        z.y = clamp(z.y, arena.y0-12, arena.y1+12);

        if(dist2(z.x,z.y,player.x,player.y) < (10*10)){
          hurtPlayer(z.elite ? 12 : 8);
        }
      }

      // boss update
      if(boss){
        boss.t += 1;
        const a = Math.atan2(player.y - boss.y, player.x - boss.x);

        const hpP = boss.hp / boss.maxHp;
        const drift = (Math.sin(boss.t*0.04) * 9);
        const spdBoost = hpP < 0.6 ? 1.25 : 1.0;

        boss.x += (Math.cos(a)*boss.spd*spdBoost + drift)*dt;
        boss.y += (Math.sin(a)*boss.spd*spdBoost - drift)*dt;

        boss.x = clamp(boss.x, arena.x0+18, arena.x1-18);
        boss.y = clamp(boss.y, arena.y0+20, arena.y1-18);

        boss.atkCD -= dt;
        if(boss.atkCD <= 0){
          boss.atkCD = hpP < 0.5 ? 0.85 : 1.10;

          particles(boss.x,boss.y,70,2.2,95,0.65,"#ff3b6b","#00ffd5");
          shake = Math.max(shake, 9);

          const d = Math.sqrt(dist2(boss.x,boss.y,player.x,player.y));
          if(d < 36) hurtPlayer(hpP < 0.5 ? 18 : 14);

          for(let k=0;k<(hpP<0.5?3:2);k++){
            spawnZombie(Math.random()<0.30);
          }
        }

        if(dist2(boss.x,boss.y,player.x,player.y) < (22*22)){
          hurtPlayer(16);
        }

        if(boss.hp <= 0){
          player.score += 850;
          player.cash += 300;
          particles(boss.x,boss.y,170,2.8,140,1.25,"#b300ff","#00ffd5");
          shake = 10;
          boss = null;
          wave.phase = "REST";
          wave.timer = 3.0;
          spawnCrates();
        }
      }

      // score drip
      player.score += dt * (4 + wave.n*0.22);

      // death
      if(player.hp <= 0){
        state = STATE.DEAD;
        if(player.score > highScore){
          highScore = Math.floor(player.score);
          localStorage.setItem(HS_KEY, String(highScore));
        }
      }

      pressed.clear();
      return;
    }
  }

  // ======== Render ========
  function render(){
    const sx = shake>0 ? randi(-shake, shake) : 0;
    const sy = shake>0 ? randi(-shake, shake) : 0;
    shake = Math.max(0, shake - 0.35);

    const t = performance.now()/1000;

    if(state !== STATE.BUNKER) updateCamera();
    drawArenaBackdrop(t);

    g.save();
    g.translate(sx, sy);

    // ===== BUNKER (better start screen) =====
    if(state === STATE.BUNKER){
      g.fillStyle = "#050214";
      g.fillRect(0,0,W,H);

      // neon bands
      g.fillStyle = "rgba(179,0,255,0.30)";
      g.fillRect(0, 0, W, 22);
      g.fillStyle = "rgba(0,255,213,0.14)";
      g.fillRect(0, 22, W, 6);

      // subtle scanlines
      for(let y=0;y<H;y+=3){
        g.fillStyle = (y%6===0) ? "rgba(255,255,255,0.02)" : "rgba(0,0,0,0)";
        g.fillRect(0,y,W,1);
      }

      // title glow
      drawText("CLUB DECAY:", 18, 18, 1.9, "#e8e8ff");
      drawText("CHIMP VS ZOMBIES", 18, 36, 1.4, "rgba(0,255,213,0.90)");
      drawText("LOADOUT (pick up to 3)", 18, 52, 1.0, "rgba(232,232,255,0.78)");
      drawText("ENTER/E toggle · SPACE deploy", 18, 66, 1.0, "rgba(232,232,255,0.65)");

      // list
      const startY = 84;
      for(let i=0;i<WEAPONS.length;i++){
        const w = WEAPONS[i];
        const y = startY + i*14;
        if(y > H-26) break;

        const picked = bunkerPicked.includes(w.id);
        const cur = (i===bunkerCursor);

        if(cur){
          g.fillStyle = "rgba(0,255,213,0.12)";
          g.fillRect(12, y-10, W-24, 13);
          g.fillStyle = "rgba(179,0,255,0.18)";
          g.fillRect(12, y-10, 6, 13);
        }

        g.fillStyle = picked ? "rgba(0,255,213,0.18)" : "rgba(255,255,255,0.06)";
        g.fillRect(16, y-9, 10, 10);
        if(picked){
          g.fillStyle = "#00ffd5";
          g.fillRect(18, y-7, 6, 2);
          g.fillRect(22, y-5, 2, 4);
        }

        drawText(w.name.toUpperCase(), 34, y, 1.0, w.color);
        const meta = w.melee ? `MELEE dmg:${w.dmg}` : `dmg:${w.dmg} rate:${w.fireRate.toFixed(1)}`;
        drawText(meta, 175, y, 0.9, "rgba(232,232,255,0.55)");
      }

      // slots
      drawText("SLOTS:", 18, H-14, 1.0, "rgba(232,232,255,0.85)");
      for(let i=0;i<3;i++){
        const id = bunkerPicked[i];
        g.fillStyle = "rgba(255,255,255,0.08)";
        g.fillRect(70+i*82, H-22, 76, 14);
        if(id){
          const w = byId[id];
          g.fillStyle = w.color;
          g.fillRect(72+i*82, H-20, 8, 10);
          drawText(`${i+1}:${w.name}`, 84+i*82, H-10, 0.85, "#e8e8ff");
        } else {
          drawText(`${i+1}: -`, 84+i*82, H-10, 0.85, "rgba(232,232,255,0.4)");
        }
      }

      g.restore();
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(world, 0, 0, W, H, 0, 0, canvas.width, canvas.height);
      return;
    }

    // ===== PLAY / DEAD =====
    const ox = camera.x, oy = camera.y;

    // crates
    for(const c of crates){
      const x = Math.floor(c.x - ox), y = Math.floor(c.y - oy);
      if(x<-10||x>W+10||y<-10||y>H+10) continue;
      g.fillStyle = c.open ? "rgba(255,255,255,0.10)" : "rgba(179,0,255,0.22)";
      g.fillRect(x-5,y-5,10,10);
      g.fillStyle = c.open ? "rgba(0,0,0,0.45)" : "rgba(0,255,213,0.30)";
      g.fillRect(x-3,y-3,6,6);
      if(!c.open){
        // hint sparkle
        if(Math.random()<0.07){
          g.fillStyle = "rgba(255,255,255,0.55)";
          g.fillRect(x+randi(-5,5), y+randi(-5,5), 1, 1);
        }
      }
    }

    // bullets
    for(const b of bullets){
      const sxp = Math.floor(b.x - ox);
      const syp = Math.floor(b.y - oy);
      if(sxp<-3 || sxp>W+3 || syp<-3 || syp>H+3) continue;
      g.fillStyle = b.col;
      g.fillRect(sxp-1, syp-1, 3, 3);
      g.fillStyle = "rgba(255,255,255,0.25)";
      g.fillRect(sxp, syp, 1, 1);
    }

    // zombies
    for(const z of zombies){
      const sxz = z.x - ox, syz = z.y - oy;
      if(sxz<-24 || sxz>W+24 || syz<-24 || syz>H+24) continue;
      drawZombie({ ...z, x:sxz, y:syz });
    }

    // boss
    if(boss){
      drawBoss({ ...boss, x:boss.x-ox, y:boss.y-oy });
    }

    // player
    const aimWorldX = camera.x + mouse.x;
    const aimWorldY = camera.y + mouse.y;
    const aimAng = Math.atan2(aimWorldY-player.y, aimWorldX-player.x);
    const blink = player.invuln>0 && (Math.floor(performance.now()/70)%2===0);
    if(!blink) drawChimp(player.x-ox, player.y-oy, player.dir, player.frame, aimAng);

    // sparks
    for(const p of sparks){
      const spx = Math.floor(p.x - ox);
      const spy = Math.floor(p.y - oy);
      if(spx<0||spx>=W||spy<0||spy>=H) continue;
      g.fillStyle = p.col;
      g.fillRect(spx, spy, 1, 1);
    }
    // floats
    for(const f of floats){
      const fx = Math.floor(f.x - ox);
      const fy = Math.floor(f.y - oy);
      if(fx<-40||fx>W+40||fy<-20||fy>H+20) continue;
      drawText(f.text, fx, fy, 1.0, f.col);
    }

    // ===== HUD =====
    g.fillStyle = "rgba(0,0,0,0.45)";
    g.fillRect(0,0,W,28);
    g.fillStyle = "rgba(179,0,255,0.18)";
    g.fillRect(0,26,W,2);

    drawText(`SCORE ${Math.floor(player.score)}`, 8, 12, 1.0, "#e8e8ff");
    drawText(`CASH ${Math.floor(player.cash)}$`, 110, 12, 1.0, "rgba(0,255,213,0.90)");
    drawText(`HI ${highScore}`, 232, 12, 1.0, "rgba(232,232,255,0.70)");
    drawText(`WAVE ${wave.n} ${wave.phase==="REST"?"(REST)":wave.phase==="FIGHT"?"(INCOMING)":wave.phase==="CLEAR"?"(CLEAR)":" "}`, 8, 24, 0.9, "rgba(232,232,255,0.70)");

    // HP bar
    const hpP = clamp(player.hp/100, 0, 1);
    g.fillStyle = "rgba(255,255,255,0.10)";
    g.fillRect(8, 32, 170, 10);
    g.fillStyle = hpP>0.4 ? "#7CFF6B" : "#ff3b6b";
    g.fillRect(8, 32, 170*hpP, 10);
    g.strokeStyle = "rgba(255,255,255,0.18)";
    g.strokeRect(8, 32, 170, 10);
    drawText(`HP`, 184, 41, 0.9, "rgba(232,232,255,0.78)");

    // Boss bar
    if(boss){
      const bp = clamp(boss.hp/boss.maxHp, 0, 1);
      g.fillStyle = "rgba(0,0,0,0.46)";
      g.fillRect(8, 46, 304, 10);
      g.fillStyle = "#ff3b6b";
      g.fillRect(8, 46, 304*bp, 10);
      g.strokeStyle = "rgba(255,255,255,0.18)";
      g.strokeRect(8, 46, 304, 10);
      drawText(`BOSS`, 270, 54, 0.9, "#e8e8ff");
    }

    // minimap
    const mmW = 84, mmH = 48;
    const mmX = W - mmW - 8;
    const mmY = 32;
    g.fillStyle = "rgba(0,0,0,0.40)";
    g.fillRect(mmX, mmY, mmW, mmH);
    g.strokeStyle = "rgba(179,0,255,0.35)";
    g.strokeRect(mmX, mmY, mmW, mmH);

    const sxm = mmW / MAP_W;
    const sym = mmH / MAP_H;

    g.strokeStyle = "rgba(0,255,213,0.30)";
    g.strokeRect(mmX + arena.x0*sxm, mmY + arena.y0*sym, (arena.x1-arena.x0)*sxm, (arena.y1-arena.y0)*sym);

    g.fillStyle = "#e8e8ff";
    g.fillRect(Math.floor(mmX + player.x*sxm)-1, Math.floor(mmY + player.y*sym)-1, 3, 3);

    let shown = 0;
    for(const z of zombies){
      if(shown++ > 50) break;
      g.fillStyle = z.elite ? "#23ff86" : "rgba(90,167,255,0.85)";
      g.fillRect(Math.floor(mmX + z.x*sxm), Math.floor(mmY + z.y*sym), 1, 1);
    }
    if(boss){
      g.fillStyle = "#ff3b6b";
      g.fillRect(Math.floor(mmX + boss.x*sxm)-1, Math.floor(mmY + boss.y*sym)-1, 3, 3);
    }

    // weapon slots
    const y = H-16;
    for(let i=0;i<3;i++){
      const id = player.selected[i];
      g.fillStyle = "rgba(255,255,255,0.08)";
      g.fillRect(8+i*104, y, 96, 12);
      if(id){
        const w = byId[id];
        g.fillStyle = (i===player.slot) ? "rgba(179,0,255,0.42)" : "rgba(0,0,0,0.25)";
        g.fillRect(8+i*104, y, 96, 12);
        g.fillStyle = w.color;
        g.fillRect(10+i*104, y+2, 8, 8);
        drawText(`${i+1}:${w.name}`, 22+i*104, y+10, 0.9, "#e8e8ff");
      } else {
        drawText(`${i+1}: -`, 22+i*104, y+10, 0.9, "rgba(232,232,255,0.4)");
      }
    }

    // REST hint
    if(wave.phase === "REST"){
      g.fillStyle = "rgba(0,0,0,0.45)";
      g.fillRect(64, 70, 192, 36);
      drawText("REST ROUND", 118, 84, 1.3, "#00ffd5");
      drawText("Press B for SHOP · E to open crates", 78, 100, 1.0, "rgba(232,232,255,0.78)");
    }

    // SHOP overlay
    if(shopOpen){
      g.fillStyle = "rgba(0,0,0,0.72)";
      g.fillRect(0,0,W,H);
      drawText("SHOP (EXCLUSIVE)", 74, 36, 1.6, "#00ffd5");
      drawText(`CASH ${Math.floor(player.cash)}$`, 118, 54, 1.1, "rgba(232,232,255,0.9)");
      drawText("W/S or ↑/↓ to select · E/ENTER buy · B close", 22, 70, 1.0, "rgba(232,232,255,0.72)");

      const startY = 92;
      for(let i=0;i<SHOP_EXCLUSIVE.length;i++){
        const id = SHOP_EXCLUSIVE[i];
        const w = byId[id];
        const y = startY + i*14;
        const cur = (i===shopCursor);
        const owned = player.selected.includes(id);
        const afford = canBuy(id);

        if(cur){
          g.fillStyle = "rgba(179,0,255,0.22)";
          g.fillRect(18, y-10, W-36, 13);
        }
        g.fillStyle = "rgba(255,255,255,0.06)";
        g.fillRect(22, y-9, 10, 10);

        g.fillStyle = w.color;
        g.fillRect(24, y-7, 6, 6);

        drawText(w.name.toUpperCase(), 38, y, 1.0, w.color);
        drawText(`${w.price}$`, 198, y, 1.0, "rgba(232,232,255,0.80)");

        const tag = owned ? "OWNED" : (afford ? "BUY" : "LOCKED");
        const col = owned ? "rgba(232,232,255,0.5)" : (afford ? "#7CFF6B" : "#ff3b6b");
        drawText(tag, 246, y, 1.0, col);
      }
    }

    // DEAD overlay
    if(state === STATE.DEAD){
      g.fillStyle = "rgba(0,0,0,0.62)";
      g.fillRect(0,0,W,H);
      drawText("YOU GOT ERASED.", 86, 68, 1.9, "#ff3b6b");
      drawText(`SCORE ${Math.floor(player.score)} | WAVE ${wave.n}`, 84, 92, 1.1, "#e8e8ff");
      drawText(`HIGH SCORE ${highScore}`, 104, 110, 1.1, "#00ffd5");
      drawText("ENTER retry | ESC bunker", 86, 136, 1.0, "rgba(232,232,255,0.80)");
    }

    // PAUSED overlay
    if(paused){
      g.fillStyle = "rgba(0,0,0,0.55)";
      g.fillRect(0,0,W,H);
      drawText("PAUSED", 132, 92, 1.8, "#e8e8ff");
      drawText("Press P to resume", 104, 112, 1.0, "rgba(232,232,255,0.75)");
    }

    g.restore();
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(world, 0, 0, W, H, 0, 0, canvas.width, canvas.height);
  }

  // ======== Loop ========
  function loop(now){
    const dt = Math.min(0.05, (now - last)/1000);
    last = now;
    acc += dt;
    while(acc >= DT){
      update(DT);
      acc -= DT;
    }
    render();
    requestAnimationFrame(loop);
  }

  // Start
  resetRun();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
