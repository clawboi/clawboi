<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CLUB DECAY: Chimp vs Zombies</title>
  <style>
    :root{
      --bg:#05030a;
      --ui:#e8e8ff;
      --muted:#9aa0c6;
      --accent:#b300ff;
      --accent2:#00ffd5;
      --danger:#ff3b6b;
      --ok:#7CFF6B;
    }
    html,body{
      height:100%; margin:0;
      background: radial-gradient(1200px 800px at 50% 40%, #160a30 0%, #05030a 55%, #02010a 100%);
      color:var(--ui);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      overflow:hidden;
    }
    #wrap{height:100%; display:grid; place-items:center;}
    canvas{
      width:min(96vw, 1280px);
      height:auto;
      max-height:88vh;
      aspect-ratio: 16 / 9;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 16px;
      background: #03020a;
      box-shadow:
        0 18px 70px rgba(0,0,0,0.70),
        0 0 0 1px rgba(179,0,255,0.20) inset,
        0 0 70px rgba(179,0,255,0.10);
    }
    .hint{
      position:fixed; left:14px; bottom:12px;
      font-size:12px; color:var(--muted);
      user-select:none;
      opacity:0.92;
    }
    .hint b{color:var(--ui)}
    .topright{
      position:fixed; right:14px; top:12px;
      font-size:12px; color:var(--muted);
      user-select:none;
      opacity:0.92;
      text-align:right;
    }
    .topright .tag{color:rgba(255,255,255,0.66)}
    a{color:var(--accent2)}
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="c" width="960" height="540"></canvas>
</div>

<div class="topright">
  CLUB DECAY MINI-GAME<br/>
  <span class="tag">One-file build · Waves + Auto Shop + Skills + SFX</span>
</div>

<div class="hint">
  <b>Move</b> WASD · <b>Aim/Shoot</b> Mouse · <b>Punch</b> Space · <b>Swap</b> 1/2/3 ·
  <b>Dash</b> Shift · <b>Skill</b> Q · <b>Pause</b> P · <b>Continue</b> C (between waves) · <b>Interact</b> E · <b>Restart</b> Enter · <b>Mute</b> M
</div>

<script>
(() => {
  // ======== Canvas & Pixel World ========
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });

  const W = 320, H = 180;
  const world = document.createElement('canvas');
  world.width = W; world.height = H;
  const g = world.getContext('2d', { alpha: false });

  // ======== Utilities ========
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const rand = (a,b)=>a+Math.random()*(b-a);
  const randi = (a,b)=> (a + Math.floor(Math.random()*(b-a+1)));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const dist2 = (ax,ay,bx,by)=>{ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; };
  const hypot = (x,y)=>Math.hypot(x,y);
  const sat = (t)=>clamp(t,0,1);

  // Fixed timestep
  let last = performance.now();
  let acc = 0;
  const DT = 1/60;

  // ======== Input (reliable action mapping) ========
  const keys = new Set();
  const pressed = new Set();

  const ACTION = {
    up: ["w","arrowup","KeyW","ArrowUp"],
    down: ["s","arrowdown","KeyS","ArrowDown"],
    left: ["a","arrowleft","KeyA","ArrowLeft"],
    right:["d","arrowright","KeyD","ArrowRight"],
    punch:[" ","Space","space"],
    interact:["e","KeyE"],
    cont:["c","KeyC"],
    pause:["p","KeyP"],
    skill:["q","KeyQ"],
    dash:["shift","ShiftLeft","ShiftRight"],
    slot1:["1","Digit1"],
    slot2:["2","Digit2"],
    slot3:["3","Digit3"],
    enter:["enter","Enter"],
    esc:["escape","Escape"],
    mute:["m","KeyM"]
  };
  const hasAny = (set, arr)=>{ for(const a of arr){ if(set.has(a)) return true; } return false; };
  const isDown = (name)=> hasAny(keys, ACTION[name]||[]);
  const wasPressed = (name)=> hasAny(pressed, ACTION[name]||[]);
  const consume = (name)=>{ for(const a of (ACTION[name]||[])) pressed.delete(a); };

  let audioArmed = false;

  window.addEventListener('keydown', (e)=>{
    const k = (e.key || "").toLowerCase();
    const c = (e.code || "");
    keys.add(k);
    if(c) keys.add(c);
    pressed.add(k);
    if(c) pressed.add(c);

    // arm audio on first user gesture
    if(!audioArmed){ audioArmed = true; Audio.init(); }

    const block = [" ","Space","ArrowUp","ArrowDown","ArrowLeft","ArrowRight"];
    if(block.includes(e.key) || block.includes(e.code)) e.preventDefault();
    if(e.key === "Escape") e.preventDefault();
  }, {passive:false});

  window.addEventListener('keyup', (e)=>{
    const k = (e.key || "").toLowerCase();
    const c = (e.code || "");
    keys.delete(k);
    if(c) keys.delete(c);
  });

  // Mouse
  let mouse = { x: W/2, y: H/2, down:false };
  canvas.addEventListener('mousemove', (e)=>{
    const rect = canvas.getBoundingClientRect();
    const sx = (e.clientX - rect.left) / rect.width;
    const sy = (e.clientY - rect.top) / rect.height;
    mouse.x = clamp(Math.floor(sx * W), 0, W-1);
    mouse.y = clamp(Math.floor(sy * H), 0, H-1);
  });
  canvas.addEventListener('mousedown', ()=>{
    mouse.down=true;
    if(!audioArmed){ audioArmed = true; Audio.init(); }
  });
  window.addEventListener('mouseup', ()=>{ mouse.down=false; });

  // ======== Audio (WebAudio SFX) ========
  const Audio = (() => {
    let ac=null, master=null, noiseBuf=null, ready=false;
    let muted = false;

    function mkNoiseBuffer(){
      const len = ac.sampleRate * 1.0;
      const buf = ac.createBuffer(1, len, ac.sampleRate);
      const data = buf.getChannelData(0);
      let x = 0;
      for(let i=0;i<len;i++){
        x = x*0.97 + (Math.random()*2-1)*0.03;
        data[i] = x;
      }
      return buf;
    }

    function init(){
      if(ready) return;
      try{
        ac = new (window.AudioContext || window.webkitAudioContext)();
        master = ac.createGain();
        master.gain.value = 0.34;
        master.connect(ac.destination);
        noiseBuf = mkNoiseBuffer();
        ready = true;
        // apply persisted mute
        muted = (localStorage.getItem("club_chimp_mute_v1") === "1");
        master.gain.value = muted ? 0.0001 : 0.34;
      }catch(e){
        ready = false;
      }
    }

    function setMuted(m){
      muted = !!m;
      localStorage.setItem("club_chimp_mute_v1", muted ? "1" : "0");
      if(ready && master){
        master.gain.value = muted ? 0.0001 : 0.34;
      }
    }
    function toggleMute(){ setMuted(!muted); }
    function isMuted(){ return muted; }
    function isReady(){ return ready; }

    function tone({freq=220, type="sine", dur=0.08, gain=0.12, bend=0, pan=0}){
      if(!ready || muted) return;
      const t0 = ac.currentTime;
      const o = ac.createOscillator();
      const g0 = ac.createGain();
      const p0 = ac.createStereoPanner ? ac.createStereoPanner() : null;

      o.type = type;
      o.frequency.setValueAtTime(freq, t0);
      if(bend){
        o.frequency.exponentialRampToValueAtTime(Math.max(20, freq*bend), t0 + dur);
      }

      g0.gain.setValueAtTime(0.0001, t0);
      g0.gain.exponentialRampToValueAtTime(gain, t0 + 0.008);
      g0.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

      o.connect(g0);
      if(p0){
        p0.pan.setValueAtTime(pan, t0);
        g0.connect(p0);
        p0.connect(master);
      } else {
        g0.connect(master);
      }

      o.start(t0);
      o.stop(t0 + dur + 0.02);
    }

    function noise({dur=0.10, gain=0.12, hp=800, pan=0}){
      if(!ready || muted) return;
      const t0 = ac.currentTime;
      const src = ac.createBufferSource();
      src.buffer = noiseBuf;

      const g0 = ac.createGain();
      const f0 = ac.createBiquadFilter();
      f0.type = "highpass";
      f0.frequency.setValueAtTime(hp, t0);

      const p0 = ac.createStereoPanner ? ac.createStereoPanner() : null;

      g0.gain.setValueAtTime(0.0001, t0);
      g0.gain.exponentialRampToValueAtTime(gain, t0 + 0.008);
      g0.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

      src.connect(f0);
      f0.connect(g0);
      if(p0){
        p0.pan.setValueAtTime(pan, t0);
        g0.connect(p0);
        p0.connect(master);
      } else {
        g0.connect(master);
      }

      src.start(t0);
      src.stop(t0 + dur + 0.02);
    }

    // SFX palette
    function shoot(kind=0, pan=0){
      if(kind===2){
        tone({freq: 820, type:"sawtooth", dur:0.05, gain:0.11, bend:0.55, pan});
        tone({freq: 420, type:"triangle", dur:0.05, gain:0.07, bend:0.72, pan});
      }else if(kind===1){
        noise({dur:0.06, gain:0.13, hp:600, pan});
        tone({freq: 130, type:"square", dur:0.07, gain:0.09, bend:0.75, pan});
      }else{
        noise({dur:0.05, gain:0.09, hp:900, pan});
        tone({freq: 220, type:"square", dur:0.05, gain:0.06, bend:0.72, pan});
      }
    }
    function hit(pan=0){
      noise({dur:0.04, gain:0.08, hp:1200, pan});
      tone({freq: 160, type:"triangle", dur:0.05, gain:0.04, bend:0.55, pan});
    }
    function explode(pan=0){
      noise({dur:0.22, gain:0.17, hp:250, pan});
      tone({freq: 70, type:"sine", dur:0.22, gain:0.10, bend:0.55, pan});
      tone({freq: 120, type:"square", dur:0.12, gain:0.06, bend:0.72, pan});
    }
    function dash(pan=0){
      noise({dur:0.07, gain:0.10, hp:1600, pan});
      tone({freq: 420, type:"triangle", dur:0.07, gain:0.05, bend:1.5, pan});
    }
    function pulse(pan=0){
      tone({freq: 220, type:"sine", dur:0.18, gain:0.09, bend:1.7, pan});
      tone({freq: 520, type:"triangle", dur:0.12, gain:0.06, bend:0.62, pan});
      noise({dur:0.12, gain:0.08, hp:1100, pan});
    }
    function pickup(pan=0){
      tone({freq: 660, type:"sine", dur:0.06, gain:0.07, bend:1.4, pan});
      tone({freq: 990, type:"triangle", dur:0.07, gain:0.06, bend:1.25, pan});
    }
    function death(pan=0){
      noise({dur:0.28, gain:0.16, hp:450, pan});
      tone({freq: 160, type:"sawtooth", dur:0.20, gain:0.08, bend:0.35, pan});
    }
    function bossRoar(pan=0){
      noise({dur:0.28, gain:0.12, hp:220, pan});
      tone({freq: 90, type:"square", dur:0.24, gain:0.06, bend:0.55, pan});
    }

    return { init, shoot, hit, explode, dash, pulse, pickup, death, bossRoar, toggleMute, isMuted, isReady, setMuted };
  })();

  // ======== State ========
  const STATE = { TITLE:0, BUNKER:1, PLAY:2, DEAD:3 };
  let state = STATE.TITLE;
  let paused = false;

  // Fullscreen handling
  const fs = {
    wanted: false,
    lastEsc: 0,
    toggle(){
      if(!document.fullscreenElement){
        fs.wanted = true;
        (canvas.requestFullscreen?.() || document.documentElement.requestFullscreen?.())?.catch(()=>{});
      } else {
        fs.wanted = false;
        document.exitFullscreen?.().catch(()=>{});
      }
    }
  };
  document.addEventListener("fullscreenchange", ()=>{
    if(fs.wanted && !document.fullscreenElement) fs.wanted = false;
  });

  // High score
  const HS_KEY = "club_chimp_zombie_highscore_v6";
  let highScore = Number(localStorage.getItem(HS_KEY) || 0);

  // Keys unlock (persistent)
  const KEY_UNLOCK = "club_decay_keys_v1";
  let keysUnlocked = Number(localStorage.getItem(KEY_UNLOCK) || 0);

  // ======== FX ========
  let shake = 0;
  let flash = 0;
  const sparks = [];
  const floats = [];
  const trails = [];
  const rings = [];
  const blood = [];

  const particles = (x,y,count,spread,speed,life,colA,colB)=>{
    for(let i=0;i<count;i++){
      const a = rand(0,Math.PI*2);
      const s = rand(speed*0.35, speed);
      sparks.push({
        x,y,
        vx: Math.cos(a)*s + rand(-spread,spread),
        vy: Math.sin(a)*s + rand(-spread,spread),
        life: rand(life*0.6, life),
        col: (Math.random()<0.5?colA:colB)
      });
    }
  };

  function addRing(x,y,rad,life,col){
    rings.push({x,y,rad,life,max:life,col});
  }

  function addBlood(x,y,amount=1,violent=false){
    for(let i=0;i<amount;i++){
      blood.push({
        x: x + rand(-7,7),
        y: y + rand(-7,7),
        r: rand(2, violent?8:6),
        a: rand(0.18, violent?0.45:0.32),
        life: rand(6.0, 18.0),
        drip: rand(0.0, 0.25)
      });
    }
    if(blood.length > 520){
      blood.splice(0, blood.length - 520);
    }
  }

  // ======== Big Map + Camera ========
  const MAP_W = 980;
  const MAP_H = 640;
  const camera = { x: 0, y: 0 };
  function updateCamera(){
    camera.x = clamp(player.x - W/2, 0, MAP_W - W);
    camera.y = clamp(player.y - H/2, 0, MAP_H - H);
  }

  // ======== Arena ========
  const arena = { x0: 34, y0: 30, x1: MAP_W-34, y1: MAP_H-34 };

  // ======== Floor Cache ========
  const FLOOR_TILE = 12;
  const floorCache = document.createElement('canvas');
  floorCache.width = MAP_W;
  floorCache.height = MAP_H;
  const fg = floorCache.getContext('2d', { alpha:false });

  function buildFloor(){
    fg.fillStyle = "#0b0a12";
    fg.fillRect(0,0,MAP_W,MAP_H);

    for(let i=0;i<16000;i++){
      const x = (Math.random()*MAP_W)|0;
      const y = (Math.random()*MAP_H)|0;
      const v = Math.random();
      fg.fillStyle = v<0.5 ? "rgba(255,255,255,0.015)" : "rgba(0,0,0,0.02)";
      fg.fillRect(x,y,1,1);
    }

    fg.strokeStyle = "rgba(255,255,255,0.05)";
    fg.lineWidth = 1;
    for(let x=0; x<MAP_W; x+=FLOOR_TILE){
      fg.beginPath(); fg.moveTo(x+0.5, 0); fg.lineTo(x+0.5, MAP_H); fg.stroke();
    }
    for(let y=0; y<MAP_H; y+=FLOOR_TILE){
      fg.beginPath(); fg.moveTo(0, y+0.5); fg.lineTo(MAP_W, y+0.5); fg.stroke();
    }

    fg.fillStyle = "rgba(179,0,255,0.06)";
    fg.fillRect(arena.x0, arena.y0, (arena.x1-arena.x0), (arena.y1-arena.y0));

    for(let i=0;i<200;i++){
      const x = rand(arena.x0+20, arena.x1-20);
      const y = rand(arena.y0+20, arena.y1-20);
      const w = rand(8,24), h = rand(2,6);
      fg.fillStyle = "rgba(255,255,255,0.018)";
      fg.fillRect(x,y,w,h);
    }
  }
  buildFloor();

  // ======== Sprites ========
  function drawChimp(px,py,dir,frame,aimAng, frenzyT){
    const x = Math.floor(px), y = Math.floor(py);
    const fur = "#6b4a2f";
    const dark = "#3b2416";
    const face = "#b88960";
    const eye = "#f4f4ff";
    const pupil = "#151018";
    const violet = "#b300ff";
    const teal = "#00ffd5";
    const bob = Math.floor(Math.sin(frame*0.3)*1);

    g.fillStyle = "rgba(0,0,0,0.35)";
    g.fillRect(x-6, y+8, 12, 3);

    if(frenzyT > 0){
      const a = 0.10 + 0.18*Math.sin(frame*0.25);
      g.fillStyle = `rgba(0,255,213,${a})`;
      g.fillRect(x-9, y-18+bob, 18, 24);
      g.fillStyle = `rgba(179,0,255,${a*0.65})`;
      g.fillRect(x-10, y-20+bob, 20, 28);
    }

    g.fillStyle = fur;  g.fillRect(x-5, y-6+bob, 10, 10);
    g.fillStyle = dark; g.fillRect(x-3, y-4+bob, 6, 6);

    g.fillStyle = fur;  g.fillRect(x-6, y-14+bob, 12, 10);
    g.fillStyle = face; g.fillRect(x-4, y-12+bob, 8, 6);

    const ex = dir>0 ? 2 : -4;
    g.fillStyle = eye;   g.fillRect(x+ex, y-12+bob, 3, 2);
    g.fillStyle = pupil; g.fillRect(x+ex+1, y-12+bob, 1, 1);

    g.fillStyle = violet; g.fillRect(x-5, y+1+bob, 10, 2);
    g.fillStyle = teal;   g.fillRect(x-1, y-2+bob, 2, 2);

    g.fillStyle = fur;
    g.fillRect(x-7, y-5+bob, 2, 8);
    g.fillRect(x+5, y-5+bob, 2, 8);

    const ax = x + Math.cos(aimAng)*10;
    const ay = y + Math.sin(aimAng)*10;
    g.strokeStyle = "rgba(0,255,213,0.28)";
    g.beginPath();
    g.moveTo(x, y-2+bob);
    g.lineTo(ax, ay);
    g.stroke();
  }

  function drawZombie(z){
    const x = Math.floor(z.x), y = Math.floor(z.y);
    const bob = Math.floor(Math.sin(z.t*0.2)*1);

    g.fillStyle = "rgba(0,0,0,0.35)";
    g.fillRect(x-5, y+7, 10, 3);

    g.fillStyle = z.elite ? "#23ff86" : "#5aa7ff";
    g.fillRect(x-4, y-6+bob, 8, 10);
    g.fillStyle = z.elite ? "#00c866" : "#2d6fe0";
    g.fillRect(x-5, y-14+bob, 10, 9);

    g.fillStyle = "#0a0a12";
    g.fillRect(x-3, y-12+bob, 2, 2);
    g.fillRect(x+1, y-12+bob, 2, 2);
    g.fillStyle = "#ff3b6b";
    g.fillRect(x-1, y-9+bob, 2, 1);

    g.fillStyle = z.elite ? "#00c866" : "#2d6fe0";
    g.fillRect(x-7, y-4+bob, 2, 7);
    g.fillRect(x+5, y-4+bob, 2, 7);

    if(z.burn > 0.1){
      g.fillStyle = "rgba(255,210,74,0.55)";
      g.fillRect(x-5, y-16+bob, 3, 1);
      g.fillStyle = "rgba(255,59,107,0.45)";
      g.fillRect(x-2, y-16+bob, 2, 1);
    }
  }

  function drawBoss(b){
    const x = Math.floor(b.x), y = Math.floor(b.y);
    const wob = Math.floor(Math.sin(b.t*0.12)*2);
    const base = (b.kind===0) ? "#ff3b6b" : (b.kind===1 ? "#b300ff" : "#00ffd5");
    const lite = (b.kind===0) ? "#ff7aa0" : (b.kind===1 ? "#d07bff" : "#7fffee");

    g.fillStyle = "rgba(0,0,0,0.45)";
    g.fillRect(x-16, y+18, 32, 6);

    g.fillStyle = base;
    g.fillRect(x-14, y-8+wob, 28, 28);
    g.fillStyle = lite;
    g.fillRect(x-16, y-26+wob, 32, 20);

    g.fillStyle = "#0a0a12";
    g.fillRect(x-9, y-18+wob, 6, 4);
    g.fillRect(x+3, y-18+wob, 6, 4);

    g.fillStyle = (b.kind===0) ? "#b300ff" : (b.kind===1 ? "#00ffd5" : "#ff3b6b");
    g.fillRect(x-7, y-17+wob, 2, 2);
    g.fillRect(x+5, y-17+wob, 2, 2);

    g.fillStyle = "#e8e8ff";
    g.fillRect(x-6, y-10+wob, 12, 3);

    g.fillStyle = "rgba(0,0,0,0.25)";
    g.fillRect(x-2, y-2+wob, 4, 6);

    g.fillStyle = (b.kind===0) ? "rgba(0,255,213,0.8)" : (b.kind===1 ? "rgba(255,59,107,0.75)" : "rgba(179,0,255,0.75)");
    g.fillRect(x-13, y-28+wob, 4, 4);
    g.fillRect(x+9, y-28+wob, 4, 4);
  }

  function drawArenaBackdrop(){
    g.drawImage(floorCache, camera.x, camera.y, W, H, 0, 0, W, H);

    const ox = camera.x, oy = camera.y;
    for(const b of blood){
      const x = Math.floor(b.x - ox);
      const y = Math.floor(b.y - oy);
      if(x<-12||x>W+12||y<-12||y>H+12) continue;
      const a = sat(b.life/18) * b.a;
      g.fillStyle = `rgba(255,59,107,${a})`;
      g.beginPath();
      g.arc(x, y, b.r, 0, Math.PI*2);
      g.fill();
      if(b.r > 4){
        g.fillStyle = `rgba(0,0,0,${a*0.20})`;
        g.fillRect(x-(b.r|0), y+(b.r|0), (b.r*2|0), 1);
      }
    }

    // subtle vignette + top strip
    g.fillStyle = "rgba(0,0,0,0.16)";
    g.fillRect(0,0,W,H);
    g.fillStyle = "rgba(0,0,0,0.22)";
    g.fillRect(0,0,W,18);

    const ax0 = arena.x0 - camera.x;
    const ay0 = arena.y0 - camera.y;
    const aw = (arena.x1 - arena.x0);
    const ah = (arena.y1 - arena.y0);

    g.strokeStyle = "rgba(0,255,213,0.14)";
    g.strokeRect(Math.floor(ax0)+1, Math.floor(ay0)+1, Math.floor(aw)-2, Math.floor(ah)-2);

    g.strokeStyle = "rgba(179,0,255,0.52)";
    g.strokeRect(Math.floor(ax0), Math.floor(ay0), Math.floor(aw), Math.floor(ah));

    g.fillStyle = "rgba(255,255,255,0.04)";
    g.fillRect(Math.floor(ax0)-1, Math.floor(ay0)-1, 8, 8);
    g.fillRect(Math.floor(ax0+aw)-7, Math.floor(ay0)-1, 8, 8);
    g.fillRect(Math.floor(ax0)-1, Math.floor(ay0+ah)-7, 8, 8);
    g.fillRect(Math.floor(ax0+aw)-7, Math.floor(ay0+ah)-7, 8, 8);
  }

  // ======== Weapons ========
  const WEAPONS = [
    { id:"pistol", name:"Pistol",  color:"#00ffd5",  fireRate: 8.8,  spread: 0.03,  speed: 280, dmg: 38,  pellets:1, recoil:0.45, price:0,  sfx:0 },
    { id:"smg",    name:"SMG",     color:"#7CFF6B",  fireRate: 16.5, spread: 0.07,  speed: 285, dmg: 16,  pellets:1, recoil:0.28, price:85, sfx:0 },
    { id:"ar",     name:"AR",      color:"#5aa7ff",  fireRate: 11.5, spread: 0.04,  speed: 305, dmg: 28,  pellets:1, recoil:0.34, price:135,sfx:0 },
    { id:"burst",  name:"Burst",   color:"#ffd24a",  fireRate: 4.4,  spread: 0.03,  speed: 320, dmg: 22,  pellets:3, burstGap:0.06, recoil:0.55, price:165,sfx:0 },
    { id:"shotgun",name:"Shotgun", color:"#ff3b6b",  fireRate: 1.85, spread: 0.22,  speed: 240, dmg: 23,  pellets:7, recoil:0.95, price:155,sfx:1 },
    { id:"sniper", name:"Sniper",  color:"#e8e8ff",  fireRate: 1.18, spread: 0.005, speed: 460, dmg: 128, pellets:1, recoil:1.25, price:250,sfx:1, crit:0.14 },
    { id:"laser",  name:"Laser",   color:"#b300ff",  fireRate: 12.5, spread: 0.01,  speed: 420, dmg: 30,  pellets:1, recoil:0.22, pierce:true, price:210,sfx:2 },
    { id:"rail",   name:"Railgun", color:"#00ffd5",  fireRate: 0.95, spread: 0.0,   speed: 560, dmg: 220, pellets:1, recoil:1.55, pierce:true, price:410,sfx:1, crit:0.20 },
    { id:"rocket", name:"Rocket",  color:"#ff3b6b",  fireRate: 0.95, spread: 0.02,  speed: 180, dmg: 82,  pellets:1, recoil:1.10, splash:34, price:320,sfx:1, boom:true },
    { id:"flame",  name:"Flame",   color:"#ffd24a",  fireRate: 24.0, spread: 0.14,  speed: 170, dmg: 9,   pellets:1, recoil:0.10, dot:2.4, price:240,sfx:0 },
    { id:"hammer", name:"Hammer",  color:"#ffd24a",  melee:true, dmg: 98, cooldown: 0.44, reach: 16, price:110,sfx:1 },

    // Key row (unlocks via Keys)
    { id:"nova",   name:"Nova Cannon",  color:"#ff3b6b", fireRate: 0.85, spread: 0.01, speed: 250, dmg: 98, pellets:1, recoil:1.25, splash:58, price:520, sfx:1, boom:true, key:1 },
    { id:"chain",  name:"Chain Laser",  color:"#b300ff", fireRate: 9.5,  spread: 0.01, speed: 460, dmg: 22, pellets:1, recoil:0.18, pierce:true, chain:2, price:480, sfx:2, key:1 },
    { id:"pike",   name:"Violet Pike",  color:"#00ffd5", fireRate: 1.2,  spread: 0.00, speed: 540, dmg: 160, pellets:1, recoil:1.35, pierce:true, lineSplash:22, price:560, sfx:1, crit:0.16, key:2 }
  ];
  const byId = Object.fromEntries(WEAPONS.map(w=>[w.id,w]));

  // ======== Skills (Q) ========
  const SKILLS = [
    { id:"pulse",   name:"Pulse",   desc:"Damage + slow in a ring", cd:6.0 },
    { id:"grenade", name:"Grenade", desc:"Big explosion projectile", cd:5.4 },
    { id:"rally",   name:"Rally",   desc:"Heal + frenzy fire-rate", cd:8.2 }
  ];
  const skillById = Object.fromEntries(SKILLS.map(s=>[s.id,s]));

  // ======== Objects ========
  const player = {
    x: MAP_W/2, y: MAP_H/2,
    vx: 0, vy: 0,
    hp: 100,
    dir: 1,
    invuln: 0,
    frame: 0,
    score: 0,
    cash: 0,
    timeAlive: 0,
    selected: [],
    slot: 0,
    shootCD: 0,
    meleeCD: 0,
    burstLeft: 0,
    burstCD: 0,
    dashCD: 0,
    dashing: 0,
    dashVX: 0,
    dashVY: 0,
    skillCD: 0,
    skillId: "pulse",
    frenzyT: 0,
    mercyT: 0
  };

  const bullets = [];
  const zombies = [];
  let boss = null;
  let bossesDefeated = 0;

  // crates between waves
  const crates = [];
  function spawnCrates(){
    crates.length = 0;
    const n = 2;
    for(let i=0;i<n;i++){
      const x = rand(arena.x0+40, arena.x1-40);
      const y = rand(arena.y0+40, arena.y1-40);
      crates.push({x,y,open:false,kind: (Math.random()<0.60 ? "cash" : "hp")});
    }
  }

  // key drop between waves
  const drops = []; // {x,y,kind:"key",picked:false}
  function spawnKeyDrop(force=false){
    if(force || Math.random() < 0.12){
      const x = rand(arena.x0+60, arena.x1-60);
      const y = rand(arena.y0+60, arena.y1-60);
      drops.push({x,y,kind:"key",picked:false, t:0});
    }
  }

  // ======== Difficulty Director ========
  const director = {
    intensity: 0,
    spawnJitter: 0,
    tick(dt){
      const waveBoost = (wave.n-1) * 0.060;
      const timeBoost = Math.min(1.0, player.timeAlive / 220) * 0.38;
      const mercy = player.mercyT > 0 ? 0.22 : 0;
      this.intensity = clamp(0.14 + waveBoost + timeBoost - mercy, 0, 2.0);
      this.spawnJitter = 0.08 + this.intensity*0.10;
    },
    hpMul(){
      return 1.0 + this.intensity*0.24;
    },
    spdMul(){
      return 1.0 + this.intensity*0.14;
    },
    eliteChance(){
      const base = clamp((wave.n - 3) / 18, 0, 0.22);
      return clamp(base + this.intensity*0.04, 0, 0.30);
    },
    aliveCap(){
      // controls “way too many” feel
      return clamp(16 + Math.floor(wave.n*2.2), 16, 42);
    }
  };

  function resetRun(){
    bullets.length = 0;
    zombies.length = 0;
    sparks.length = 0;
    floats.length = 0;
    trails.length = 0;
    rings.length = 0;
    crates.length = 0;
    drops.length = 0;
    boss = null;
    bossesDefeated = 0;
    shake = 0;
    flash = 0;
    blood.length = 0;

    player.x = MAP_W/2; player.y = MAP_H/2;
    player.vx = 0; player.vy = 0;
    player.hp = 100;
    player.invuln = 0;
    player.frame = 0;
    player.score = 0;
    player.cash = 0;
    player.timeAlive = 0;
    player.slot = 0;
    player.shootCD = 0;
    player.meleeCD = 0;
    player.burstLeft = 0;
    player.burstCD = 0;
    player.dashCD = 0;
    player.dashing = 0;
    player.dashVX = 0;
    player.dashVY = 0;
    player.skillCD = 0;
    player.frenzyT = 0;
    player.mercyT = 0;

    waveInit();
    updateCamera();
  }

  // ======== Title + Bunker ========
  let titleT = 0;

  // Bunker selection
  let bunkerCursor = 0;
  let bunkerSlots = ["pistol","shotgun","hammer"];
  let bunkerSlotFocus = 0;
  let bunkerSkillCursor = 0;

  function bunkerInit(){
    bunkerCursor = 0;
    bunkerSlots = ["pistol","shotgun","hammer"];
    bunkerSlotFocus = 0;
    bunkerSkillCursor = Math.max(0, SKILLS.findIndex(s=>s.id===player.skillId));
  }
  bunkerInit();

  // ======== Waves + Auto Shop ========
  const wave = {
    n: 1,
    phase: "REST",
    timer: 2.2,
    toSpawn: 0,
    spawned: 0,
    spawnCD: 0,
    shopPhase: "OPEN",
    restLock: 0.25,
    bossAddBudget: 0
  };

  let shopOpen = false;

  function waveInit(){
    wave.n = 1;
    wave.phase = "REST";
    wave.timer = 0.9;
    wave.toSpawn = 0;
    wave.spawned = 0;
    wave.spawnCD = 0;
    wave.shopPhase = "OPEN";
    wave.restLock = 0.25;
    wave.bossAddBudget = 0;
    spawnCrates();
    drops.length = 0;
    spawnKeyDrop(false);
    shopOpen = true;
  }

  function beginWave(){
    wave.phase = "FIGHT";
    wave.spawned = 0;

    // fixed amount per wave, gentle growth
    const raw = 7 + Math.floor(wave.n * 1.35);
    let cap = 26;
    if(wave.n >= 10) cap = 30;
    if(wave.n >= 15) cap = 34;

    // boss waves: slightly fewer normal spawns (so it feels cleaner)
    const bossWave = [5,10,15].includes(wave.n);
    wave.toSpawn = clamp(bossWave ? Math.floor(raw*0.82) : raw, 7, cap);

    // spawn pacing, but never endless
    wave.spawnCD = clamp(0.26 - (wave.n*0.0042), 0.12, 0.26);

    // boss adds are limited (no runaway pile)
    wave.bossAddBudget = bossWave ? clamp(2 + Math.floor(wave.n*0.12), 2, 5) : 0;

    shopOpen = false;
    wave.shopPhase = "CLOSED";

    particles(player.x, player.y, 16, 1.4, 65, 0.24, "#00ffd5", "#b300ff");
    shake = Math.max(shake, 1.2);
    Audio.pickup(0);
  }

  function endWave(){
    wave.phase = "REST";
    wave.timer = 0.85;
    wave.n++;
    wave.shopPhase = "OPEN";
    wave.restLock = 0.25;

    spawnCrates();
    drops.length = 0;
    spawnKeyDrop(false);
    shopOpen = true;
  }

  // ======== Shop ========
  const SHOP_EXCLUSIVE = ["ar","burst","sniper","laser","rocket","flame","rail","smg","nova","chain","pike"];
  let shopCursor = 0;
  let shopSlotFocus = 0;

  function canBuy(id){
    const w = byId[id];
    if(!w) return false;
    if(w.key && keysUnlocked < w.key) return false;
    if(player.selected.includes(id)) return false;
    return player.cash >= (w.price||0);
  }

  function buyWeapon(id){
    const w = byId[id];
    if(!w || !canBuy(id)) return;

    player.cash -= w.price;

    let slot = player.selected.findIndex(v=>!v);
    if(slot < 0) slot = shopSlotFocus;

    player.selected[slot] = id;
    player.slot = slot;

    particles(player.x, player.y, 18, 1.3, 80, 0.28, "#00ffd5", "#b300ff");
    shake = Math.max(shake, 1.6);
    Audio.pickup((slot-1)*0.15);
  }

  // ======== Spawning ========
  function spawnZombie(elite=false){
    if(zombies.length >= director.aliveCap()) return;

    const side = randi(0,3);
    let x,y;
    if(side===0){ x = arena.x0-10; y = rand(arena.y0, arena.y1); }
    if(side===1){ x = arena.x1+10; y = rand(arena.y0, arena.y1); }
    if(side===2){ x = rand(arena.x0, arena.x1); y = arena.y0-10; }
    if(side===3){ x = rand(arena.x0, arena.x1); y = arena.y1+10; }

    const hpBase = elite ? (92 + wave.n*4.8) : (58 + wave.n*3.1);
    const spdBase = elite ? rand(19,29) : rand(14,23);

    const hp = Math.floor(hpBase * director.hpMul());
    const spd = spdBase * director.spdMul();

    zombies.push({ x,y,vx:0,vy:0,hp,spd,t:rand(0,999), elite, burn:0, slow:0, bleed:0 });
  }

  function shouldSpawnBossThisWave(){
    if(bossesDefeated >= 3) return false;
    const targets = [5,10,15];
    return targets.includes(wave.n) && !boss;
  }

  function spawnBoss(){
    const side = randi(0,3);
    let x,y;
    if(side===0){ x = arena.x0-26; y = rand(arena.y0, arena.y1); }
    if(side===1){ x = arena.x1+26; y = rand(arena.y0, arena.y1); }
    if(side===2){ x = rand(arena.x0, arena.x1); y = arena.y0-26; }
    if(side===3){ x = rand(arena.x0, arena.x1); y = arena.y1+26; }

    const kind = bossesDefeated;

    // boss is smoother, less “stop”
    const waveEase = (wave.n===5) ? 0.82 : 1.0;
    const maxHp = Math.floor((1040 + wave.n*125 + kind*210) * waveEase * (1.0 + director.intensity*0.12));
    const spd = (15.0 + kind*1.7) * (1.0 + director.intensity*0.04);

    boss = { x,y, hp:maxHp, maxHp, spd, t:0, atkCD: 1.45, kind, slow:0 };
    particles(x,y,56,1.5,72,0.70,"#ff3b6b","#b300ff");
    addRing(x,y, 6, 0.40, "rgba(255,59,107,0.50)");
    shake = Math.max(shake, 2.6);
    flash = Math.max(flash, 0.10);
    Audio.bossRoar(0);
  }

  // ======== Combat Helpers ========
  function screenPanFromWorld(wx){
    const sx = (wx - camera.x) / W;
    return clamp((sx - 0.5) * 1.2, -0.9, 0.9);
  }

  function boomFX(x,y,rad,col){
    addRing(x,y, rad*0.35, 0.34, col);
    addRing(x,y, rad*0.18, 0.20, "rgba(255,255,255,0.20)");
    particles(x,y, 36, 2.1, 110, 0.60, col, "rgba(232,232,255,0.55)");
    particles(x,y, 18, 1.6, 76, 0.50, "rgba(255,59,107,0.60)", col);
    addBlood(x,y, 8, true);
    shake = Math.max(shake, 3.4);
    flash = Math.max(flash, 0.18);
    Audio.explode(screenPanFromWorld(x));
  }

  function applySplash(x,y,rad,dmg,col){
    const r2 = rad*rad;
    let hits = 0;
    for(const z of zombies){
      if(dist2(x,y,z.x,z.y) <= r2){
        z.hp -= Math.floor(dmg*0.78);
        z.bleed = Math.max(z.bleed, 0.10);
        hits++;
        particles(z.x,z.y,6,0.9,52,0.16,col,"rgba(232,232,255,0.45)");
        addBlood(z.x,z.y, 2, false);
      }
    }
    if(boss && dist2(x,y,boss.x,boss.y) <= (rad+18)*(rad+18)){
      boss.hp -= Math.floor(dmg*0.45);
      hits++;
      particles(boss.x,boss.y,10,1.0,60,0.18,col,"#ff3b6b");
      addBlood(boss.x,boss.y, 2, false);
    }
    return hits;
  }

  function applyLineSplash(x,y,rad,dmg,col){
    const r2 = rad*rad;
    let hits = 0;
    for(const z of zombies){
      if(dist2(x,y,z.x,z.y) <= r2){
        z.hp -= Math.floor(dmg*0.50);
        z.slow = Math.max(z.slow, 0.55);
        hits++;
        particles(z.x,z.y,6,1.0,58,0.16,col,"rgba(232,232,255,0.45)");
      }
    }
    if(hits>0){
      addRing(x,y, 5, 0.18, "rgba(0,255,213,0.35)");
    }
    return hits;
  }

  function chainFromHit(x,y,already,chainsLeft,dmg,col){
    if(chainsLeft<=0) return;
    // find nearest not already hit
    let best = null;
    let bestD = 9999999;
    for(const z of zombies){
      if(already.has(z)) continue;
      const d = dist2(x,y,z.x,z.y);
      if(d < bestD){
        bestD = d;
        best = z;
      }
    }
    if(best && bestD < (78*78)){
      already.add(best);
      best.hp -= Math.floor(dmg*0.80);
      best.slow = Math.max(best.slow, 0.75);
      particles(best.x,best.y,10,1.2,70,0.20,col,"rgba(232,232,255,0.45)");
      addRing(best.x,best.y, 6, 0.18, "rgba(179,0,255,0.30)");
      Audio.hit(screenPanFromWorld(best.x));
      chainFromHit(best.x,best.y,already,chainsLeft-1,dmg,col);
    }
  }

  function shootWeapon(w, ang){
    const ox = player.x;
    const oy = player.y-2;

    const makeBullet = (a)=>{
      bullets.push({
        x: ox + Math.cos(a)*6,
        y: oy + Math.sin(a)*6,
        vx: Math.cos(a)*w.speed,
        vy: Math.sin(a)*w.speed,
        dmg: w.dmg,
        life: 1.0,
        col: w.color,
        pierce: !!w.pierce,
        splash: w.splash || 0,
        dot: w.dot || 0,
        kind: w.id,
        crit: w.crit || 0,
        chain: w.chain || 0,
        lineSplash: w.lineSplash || 0
      });
    };

    if(w.burstGap){
      player.burstLeft = w.pellets;
      player.burstCD = 0;
      const a = ang + rand(-w.spread, w.spread);
      makeBullet(a);
      player.burstLeft--;
    } else {
      for(let p=0;p<(w.pellets||1);p++){
        const a = ang + rand(-w.spread, w.spread);
        makeBullet(a);
      }
    }

    particles(ox+Math.cos(ang)*7, oy+Math.sin(ang)*7, 5, 0.6, 46, 0.20, w.color, "rgba(232,232,255,0.55)");
    // lower “stomp” feel (less shake per shot)
    shake = Math.max(shake, Math.min(1.8, (w.recoil || 0.6)));

    const pan = screenPanFromWorld(ox);
    Audio.shoot(w.sfx||0, pan);
  }

  function meleeHit(w, ang){
    const reach = w.reach || 14;
    const hx = player.x + Math.cos(ang)*reach;
    const hy = player.y + Math.sin(ang)*reach;
    let hitAny = false;

    for(const z of zombies){
      if(dist2(hx,hy,z.x,z.y) < (12*12)){
        z.hp -= w.dmg;
        z.bleed = Math.max(z.bleed, 0.18);
        hitAny = true;
        particles(z.x,z.y,14,1.2,56,0.26,"#ffd24a","#ff3b6b");
        addBlood(z.x,z.y, 4, true);
        floats.push({x:z.x,y:z.y-6,vx:rand(-8,8),vy:rand(-18,-10),life:0.65,text:`-${w.dmg}`,col:"#ffd24a"});
        shake = Math.max(shake, 1.9);
        Audio.hit(screenPanFromWorld(z.x));
      }
    }

    if(boss && dist2(hx,hy,boss.x,boss.y) < (26*26)){
      boss.hp -= w.dmg;
      hitAny = true;
      particles(boss.x,boss.y,18,1.4,64,0.30,"#ffd24a","#b300ff");
      addBlood(boss.x,boss.y, 5, true);
      floats.push({x:boss.x,y:boss.y-18,vx:rand(-10,10),vy:rand(-20,-12),life:0.75,text:`-${w.dmg}`,col:"#ffd24a"});
      shake = Math.max(shake, 2.4);
      Audio.hit(screenPanFromWorld(boss.x));
    }

    particles(player.x+Math.cos(ang)*10, player.y+Math.sin(ang)*10, hitAny?9:5, 1.0, 40, 0.18, "#ffd24a", "rgba(255,255,255,0.40)");
  }

  function hurtPlayer(amount){
    if(player.invuln > 0) return;
    player.hp -= amount;
    player.invuln = 0.55;
    player.mercyT = Math.max(player.mercyT, 0.90);

    shake = Math.max(shake, 2.6);
    particles(player.x, player.y, 22, 1.4, 62, 0.45, "#ff3b6b", "#b300ff");
    addRing(player.x, player.y, 6, 0.22, "rgba(255,59,107,0.40)");
    Audio.hit(0);
  }

  // ======== Skills (Q) ========
  function doSkill(){
    if(player.skillCD > 0) return;

    const skill = skillById[player.skillId] || skillById.pulse;
    player.skillCD = skill.cd;

    if(skill.id === "pulse"){
      const rad = 70;
      const r2 = rad*rad;
      let hits = 0;

      for(const z of zombies){
        if(dist2(player.x,player.y,z.x,z.y) <= r2){
          z.hp -= 26;
          z.slow = Math.max(z.slow, 1.25);
          z.bleed = Math.max(z.bleed, 0.08);
          hits++;
          particles(z.x,z.y,9,1.0,56,0.20,"#00ffd5","#e8e8ff");
          addBlood(z.x,z.y, 1, false);
        }
      }
      if(boss && dist2(player.x,player.y,boss.x,boss.y) <= (rad+14)*(rad+14)){
        boss.hp -= 36;
        boss.slow = Math.max(boss.slow, 1.00);
        hits++;
        particles(boss.x,boss.y,14,1.2,64,0.24,"#00ffd5","#b300ff");
      }

      addRing(player.x, player.y, 8, 0.32, "rgba(0,255,213,0.52)");
      addRing(player.x, player.y, 16, 0.44, "rgba(179,0,255,0.16)");

      floats.push({x:player.x,y:player.y-18,vx:0,vy:-18,life:0.9,text: hits>0 ? "PULSE" : "PULSE (MISS)", col:"#00ffd5"});
      shake = Math.max(shake, 1.6);
      Audio.pulse(0);
      return;
    }

    if(skill.id === "grenade"){
      const aimWorldX = camera.x + mouse.x;
      const aimWorldY = camera.y + mouse.y;
      const ang = Math.atan2(aimWorldY - player.y, aimWorldX - player.x);

      bullets.push({
        x: player.x + Math.cos(ang)*10,
        y: player.y + Math.sin(ang)*10,
        vx: Math.cos(ang)*220,
        vy: Math.sin(ang)*220,
        dmg: 62,
        life: 0.85,
        col: "#ff3b6b",
        pierce:false,
        splash: 46,
        dot:0,
        kind:"grenade",
        crit:0,
        chain:0,
        lineSplash:0
      });

      particles(player.x, player.y, 16, 1.3, 76, 0.22, "#ff3b6b", "#b300ff");
      addRing(player.x, player.y, 6, 0.22, "rgba(255,59,107,0.32)");
      shake = Math.max(shake, 1.4);
      Audio.shoot(1, 0);
      return;
    }

    if(skill.id === "rally"){
      const heal = 22;
      player.hp = clamp(player.hp + heal, 0, 100);
      player.frenzyT = Math.max(player.frenzyT, 4.6);
      player.invuln = Math.max(player.invuln, 0.22);

      particles(player.x, player.y, 36, 1.8, 88, 0.50, "#7CFF6B", "#00ffd5");
      addRing(player.x, player.y, 10, 0.36, "rgba(124,255,107,0.38)");
      floats.push({x:player.x,y:player.y-18,vx:0,vy:-18,life:1.0,text:`RALLY +${heal}HP`,col:"#7CFF6B"});
      shake = Math.max(shake, 1.6);
      Audio.pickup(0);
      return;
    }
  }

  // ======== Movement skills ========
  function doDash(){
    if(player.dashCD > 0 || player.dashing > 0) return;

    let mx=0,my=0;
    if(isDown("left")) mx -= 1;
    if(isDown("right")) mx += 1;
    if(isDown("up")) my -= 1;
    if(isDown("down")) my += 1;

    const aimWorldX = camera.x + mouse.x;
    const aimWorldY = camera.y + mouse.y;

    if(mx===0 && my===0){
      const ang = Math.atan2(aimWorldY - player.y, aimWorldX - player.x);
      mx = Math.cos(ang);
      my = Math.sin(ang);
    } else {
      const len = Math.hypot(mx,my)||1;
      mx/=len; my/=len;
    }

    player.dashing = 0.14;
    player.dashCD = 0.80;
    player.invuln = Math.max(player.invuln, 0.18);

    const power = 260;
    player.dashVX = mx*power;
    player.dashVY = my*power;

    particles(player.x, player.y, 18, 1.3, 78, 0.22, "#00ffd5", "#b300ff");
    addRing(player.x, player.y, 6, 0.20, "rgba(0,255,213,0.30)");
    shake = Math.max(shake, 1.4);
    Audio.dash(0);
  }

  // ======== UI Text ========
  function drawText(txt,x,y,scale=1,color="#e8e8ff"){
    g.fillStyle = color;
    g.font = `${8*scale}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace`;
    g.fillText(txt, x, y);
  }

  // ======== Update ========
  function update(dt){
    // Global mute
    if(wasPressed("mute")){
      Audio.toggleMute();
      consume("mute");
      particles(MAP_W/2, MAP_H/2, 8, 1.0, 60, 0.18, "#00ffd5", "#b300ff");
      if(!Audio.isMuted()) Audio.pickup(0);
    }

    // Pause toggle
    if(wasPressed("pause") && state === STATE.PLAY){
      paused = !paused;
      consume("pause");
    }

    // Title
    if(state === STATE.TITLE){
      titleT += dt;
      if(wasPressed("enter") || wasPressed("interact") || wasPressed("punch")){
        state = STATE.BUNKER;
        bunkerInit();
        Audio.pickup(0);
      }
      pressed.clear();
      return;
    }

    if(paused){
      for(let i=sparks.length-1;i>=0;i--){
        const p = sparks[i];
        p.x += p.vx*dt*0.35;
        p.y += p.vy*dt*0.35;
        p.vx *= Math.pow(0.08, dt);
        p.vy *= Math.pow(0.08, dt);
        p.life -= dt*0.65;
        if(p.life<=0) sparks.splice(i,1);
      }
      for(let i=floats.length-1;i>=0;i--){
        const f = floats[i];
        f.y += f.vy*dt*0.25;
        f.life -= dt*0.65;
        if(f.life<=0) floats.splice(i,1);
      }
      for(let i=rings.length-1;i>=0;i--){
        const r = rings[i];
        r.life -= dt*0.65;
        r.rad += 60*dt*0.2;
        if(r.life<=0) rings.splice(i,1);
      }
      pressed.clear();
      return;
    }

    director.tick(dt);

    // timers
    player.dashCD = Math.max(0, player.dashCD - dt);
    player.skillCD = Math.max(0, player.skillCD - dt);
    player.invuln = Math.max(0, player.invuln - dt);
    player.frenzyT = Math.max(0, player.frenzyT - dt);
    player.mercyT = Math.max(0, player.mercyT - dt);
    flash = Math.max(0, flash - dt*2.6);

    // FX
    for(let i=sparks.length-1;i>=0;i--){
      const p = sparks[i];
      p.x += p.vx*dt;
      p.y += p.vy*dt;
      p.vx *= Math.pow(0.02, dt);
      p.vy *= Math.pow(0.02, dt);
      p.life -= dt;
      if(p.life<=0) sparks.splice(i,1);
    }
    for(let i=floats.length-1;i>=0;i--){
      const f = floats[i];
      f.x += f.vx*dt;
      f.y += f.vy*dt;
      f.vx *= Math.pow(0.25, dt);
      f.vy += 30*dt;
      f.life -= dt;
      if(f.life<=0) floats.splice(i,1);
    }
    for(let i=trails.length-1;i>=0;i--){
      const t = trails[i];
      t.life -= dt;
      if(t.life<=0) trails.splice(i,1);
    }
    for(let i=rings.length-1;i>=0;i--){
      const r = rings[i];
      r.life -= dt;
      r.rad += 120*dt;
      if(r.life<=0) rings.splice(i,1);
    }
    for(let i=blood.length-1;i>=0;i--){
      const b = blood[i];
      b.life -= dt;
      b.y += b.drip * dt * 18;
      if(b.life<=0) blood.splice(i,1);
    }

    // ===== BUNKER =====
    if(state === STATE.BUNKER){
      const visible = WEAPONS.filter(w => !w.key || keysUnlocked >= w.key);
      if(wasPressed("down")) bunkerCursor = (bunkerCursor+1) % visible.length;
      if(wasPressed("up")) bunkerCursor = (bunkerCursor-1+visible.length) % visible.length;

      if(wasPressed("slot1")) bunkerSlotFocus = 0;
      if(wasPressed("slot2")) bunkerSlotFocus = 1;
      if(wasPressed("slot3")) bunkerSlotFocus = 2;

      if(wasPressed("skill")){
        bunkerSkillCursor = (bunkerSkillCursor + 1) % SKILLS.length;
        player.skillId = SKILLS[bunkerSkillCursor].id;
        particles(MAP_W/2, MAP_H/2, 10, 1.2, 65, 0.20, "#00ffd5", "#b300ff");
        Audio.pickup(0);
      }

      if(wasPressed("enter") || wasPressed("interact")){
        const id = visible[bunkerCursor].id;
        bunkerSlots[bunkerSlotFocus] = id;
        particles(MAP_W/2, MAP_H/2, 10, 1.2, 65, 0.20, "#00ffd5", "#b300ff");
        Audio.pickup((bunkerSlotFocus-1)*0.2);
      }

      if(wasPressed("punch")){
        player.selected = bunkerSlots.slice(0,3);
        resetRun();
        state = STATE.PLAY;
        Audio.pickup(0);
      }

      pressed.clear();
      return;
    }

    // ===== DEAD =====
    if(state === STATE.DEAD){
      if(wasPressed("enter")){
        resetRun();
        state = STATE.PLAY;
        Audio.pickup(0);
      }
      if(wasPressed("esc")){
        state = STATE.BUNKER;
        bunkerInit();
      }
      pressed.clear();
      return;
    }

    // ===== PLAY =====
    if(state === STATE.PLAY){
      if(wasPressed("esc")){
        const now = performance.now();
        if(now - fs.lastEsc > 220){
          fs.lastEsc = now;
          if(shopOpen){
            shopOpen = false;
            wave.shopPhase = "READY";
          } else {
            fs.toggle();
          }
        }
        consume("esc");
      }

      player.timeAlive += dt;
      player.frame += 1;

      // REST phase logic
      if(wave.phase === "REST"){
        wave.restLock = Math.max(0, wave.restLock - dt);
        if(wave.shopPhase === "OPEN") shopOpen = true;

        // key drops drift
        for(const d of drops){ d.t += dt; }

        if(shopOpen){
          if(wasPressed("down")) shopCursor = (shopCursor+1) % SHOP_EXCLUSIVE.length;
          if(wasPressed("up")) shopCursor = (shopCursor-1+SHOP_EXCLUSIVE.length) % SHOP_EXCLUSIVE.length;

          if(wasPressed("slot1")) shopSlotFocus = 0;
          if(wasPressed("slot2")) shopSlotFocus = 1;
          if(wasPressed("slot3")) shopSlotFocus = 2;

          if(wasPressed("enter") || wasPressed("interact")){
            buyWeapon(SHOP_EXCLUSIVE[shopCursor]);
          }

          if(wasPressed("cont") && wave.restLock<=0){
            shopOpen = false;
            wave.shopPhase = "READY";
            wave.timer = 0;
          }

          pressed.clear();
          return;
        } else {
          // Open crates + pick up keys with E
          if(wasPressed("interact")){
            // keys
            for(const d of drops){
              if(d.picked) continue;
              if(d.kind==="key" && dist2(d.x,d.y,player.x,player.y) < (16*16)){
                d.picked = true;
                keysUnlocked += 1;
                localStorage.setItem(KEY_UNLOCK, String(keysUnlocked));
                floats.push({x:d.x,y:d.y-10,vx:rand(-10,10),vy:rand(-26,-16),life:1.0,text:`KEY +1`,col:"#b300ff"});
                particles(d.x,d.y,26,1.8,90,0.36,"#b300ff","#00ffd5");
                addRing(d.x,d.y, 8, 0.26, "rgba(179,0,255,0.45)");
                shake = Math.max(shake, 1.6);
                Audio.pickup(screenPanFromWorld(d.x));
                break;
              }
            }

            // crates
            for(const c of crates){
              if(c.open) continue;
              if(dist2(c.x,c.y,player.x,player.y) < (16*16)){
                c.open = true;
                if(c.kind === "cash"){
                  const gain = 62 + Math.floor(wave.n*11);
                  player.cash += gain;
                  player.score += gain * 0.75;
                  floats.push({x:c.x,y:c.y-10,vx:rand(-10,10),vy:rand(-24,-14),life:0.9,text:`+${gain}$`,col:"#00ffd5"});
                  particles(c.x,c.y,18,1.5,76,0.28,"#00ffd5","#b300ff");
                  Audio.pickup(screenPanFromWorld(c.x));
                } else {
                  const heal = 16 + Math.floor(wave.n*1.4);
                  player.hp = clamp(player.hp + heal, 0, 100);
                  floats.push({x:c.x,y:c.y-10,vx:rand(-10,10),vy:rand(-24,-14),life:0.9,text:`+${heal}HP`,col:"#7CFF6B"});
                  particles(c.x,c.y,16,1.3,70,0.26,"#7CFF6B","#00ffd5");
                  Audio.pickup(screenPanFromWorld(c.x));
                }
                shake = Math.max(shake, 1.2);
                break;
              }
            }
          }

          if(wasPressed("cont") && wave.restLock<=0){
            wave.timer = 0;
          }

          wave.timer -= dt;
          if(wave.timer <= 0){
            beginWave();
          }
        }
      }

      // Aim / movement
      let mx=0,my=0;
      if(isDown("left")) mx -= 1;
      if(isDown("right")) mx += 1;
      if(isDown("up")) my -= 1;
      if(isDown("down")) my += 1;

      const aimWorldX = camera.x + mouse.x;
      const aimWorldY = camera.y + mouse.y;
      const ang = Math.atan2(aimWorldY - player.y, aimWorldX - player.x);
      player.dir = Math.cos(ang) >= 0 ? 1 : -1;

      if(wasPressed("dash")) doDash();
      if(wasPressed("skill")) doSkill();

      const baseSpd = 64;
      if(player.dashing > 0){
        player.dashing = Math.max(0, player.dashing - dt);
        player.vx = player.dashVX;
        player.vy = player.dashVY;

        if(Math.random() < 0.55){
          trails.push({x:player.x, y:player.y, life:0.22});
        }
      } else {
        const len = Math.hypot(mx,my) || 1;
        mx /= len; my /= len;
        player.vx = lerp(player.vx, mx*baseSpd, 0.2);
        player.vy = lerp(player.vy, my*baseSpd, 0.2);
      }

      player.x += player.vx*dt;
      player.y += player.vy*dt;
      player.x = clamp(player.x, arena.x0+6, arena.x1-6);
      player.y = clamp(player.y, arena.y0+8, arena.y1-8);
      updateCamera();

      // swap weapons
      if(wasPressed("slot1")) player.slot = 0;
      if(wasPressed("slot2")) player.slot = 1;
      if(wasPressed("slot3")) player.slot = 2;

      const wId = player.selected[player.slot] || player.selected[0] || "pistol";
      const weapon = byId[wId] || byId.pistol;

      // burst timing
      if(player.burstLeft > 0){
        player.burstCD -= dt;
        if(player.burstCD <= 0){
          player.burstCD = byId.burst.burstGap;
          const a = ang + rand(-byId.burst.spread, byId.burst.spread);
          bullets.push({
            x: player.x + Math.cos(a)*6,
            y: player.y-2 + Math.sin(a)*6,
            vx: Math.cos(a)*byId.burst.speed,
            vy: Math.sin(a)*byId.burst.speed,
            dmg: byId.burst.dmg,
            life: 1.0,
            col: byId.burst.color,
            pierce:false,
            splash:0,
            dot:0,
            kind:"burst",
            crit:0,
            chain:0,
            lineSplash:0
          });
          particles(player.x+Math.cos(a)*7, player.y-2+Math.sin(a)*7, 4, 0.6, 45, 0.18, byId.burst.color, "rgba(232,232,255,0.50)");
          Audio.shoot(0, 0);
          player.burstLeft--;
        }
      }

      // cooldowns
      player.shootCD = Math.max(0, player.shootCD - dt);
      player.meleeCD = Math.max(0, player.meleeCD - dt);

      // wave logic (fixed budget, no endless)
      if(wave.phase === "FIGHT"){
        wave.spawnCD -= dt;

        const spawnNow = (wave.spawned < wave.toSpawn && wave.spawnCD <= 0);
        if(spawnNow){
          wave.spawnCD = clamp(
            0.26 - director.intensity*0.05 + rand(-director.spawnJitter, director.spawnJitter)*0.02,
            0.12, 0.30
          );
          const eliteChance = director.eliteChance();
          spawnZombie(Math.random() < eliteChance);
          wave.spawned++;
        }
        if(wave.spawned >= wave.toSpawn) wave.phase = "CLEAR";
        if(shouldSpawnBossThisWave()) spawnBoss();
      } else if(wave.phase === "CLEAR"){
        if(zombies.length === 0 && !boss){
          endWave();
        }
      }

      // combat
      const canCombat = (wave.phase !== "REST") || mouse.down || wasPressed("punch");
      if(canCombat){
        if(weapon.melee){
          if((mouse.down || wasPressed("punch")) && player.meleeCD <= 0){
            player.meleeCD = weapon.cooldown || 0.50;
            meleeHit(weapon, ang);
          }
        }else{
          const frenzyMul = player.frenzyT > 0 ? 1.28 : 1.0;
          const rate = (weapon.fireRate || 6) * frenzyMul;

          if(mouse.down && player.shootCD <= 0){
            player.shootCD = 1 / rate;
            shootWeapon(weapon, ang);
          }
          if(wasPressed("punch") && player.meleeCD <= 0){
            player.meleeCD = 0.42;
            meleeHit({dmg:32, reach:12}, ang);
          }
        }
      }

      // bullets
      for(let i=bullets.length-1;i>=0;i--){
        const b = bullets[i];
        b.life -= dt;
        b.x += b.vx*dt;
        b.y += b.vy*dt;

        if((b.kind==="grenade" || b.kind==="rocket" || b.kind==="nova") && b.life <= 0.02){
          const rr = (b.kind==="grenade") ? 54 : (b.kind==="nova" ? 70 : 44);
          boomFX(b.x,b.y, rr, "rgba(255,59,107,0.65)");
          applySplash(b.x,b.y, (b.kind==="grenade") ? 52 : (b.splash||30), b.dmg, b.col);
          bullets.splice(i,1);
          continue;
        }

        if(b.life<=0 || b.x<0 || b.x>MAP_W || b.y<0 || b.y>MAP_H){
          bullets.splice(i,1);
          continue;
        }

        if((b.kind==="laser" || b.kind==="rail" || b.kind==="chain" || b.kind==="pike") && Math.random()<0.32){
          sparks.push({x:b.x,y:b.y,vx:rand(-8,8),vy:rand(-8,8),life:0.10,col:"rgba(232,232,255,0.25)"});
        }

        // hits on zombies
        let hit = false;
        for(let j=zombies.length-1;j>=0;j--){
          const z = zombies[j];
          if(dist2(b.x,b.y,z.x,z.y) < (7*7)){
            const isCrit = (b.crit && Math.random() < b.crit);
            const dmg = isCrit ? Math.floor(b.dmg*1.45) : b.dmg;

            z.hp -= dmg;
            if(b.dot) z.burn = Math.max(z.burn, b.dot);
            z.bleed = Math.max(z.bleed, isCrit ? 0.22 : 0.10);

            particles(b.x,b.y, isCrit?12:7, 0.9, isCrit?78:50, 0.20, b.col, "rgba(232,232,255,0.45)");
            addBlood(z.x,z.y, isCrit?5:2, isCrit);
            Audio.hit(screenPanFromWorld(z.x));

            if(b.splash){
              applySplash(b.x,b.y,b.splash,dmg,b.col);
              boomFX(b.x,b.y, b.splash*1.05, `rgba(255,59,107,0.42)`);
            }
            if(b.lineSplash){
              applyLineSplash(b.x,b.y,b.lineSplash,dmg,b.col);
            }
            if(b.chain){
              const already = new Set([z]);
              chainFromHit(z.x,z.y,already,b.chain,dmg,b.col);
            }

            if(isCrit){
              addRing(z.x,z.y, 6, 0.20, "rgba(255,59,107,0.50)");
              shake = Math.max(shake, 1.5);
            }

            if(!b.pierce){
              bullets.splice(i,1);
            }

            if(z.hp<=0){
              zombies.splice(j,1);
              const reward = z.elite ? 44 : 26;
              player.score += reward;
              player.cash += Math.floor(reward * 0.90);

              particles(z.x,z.y,18,1.1,62,0.46,"#00ffd5","#b300ff");
              addBlood(z.x,z.y, 8, true);

              if(Math.random()<0.40){
                particles(z.x,z.y,12,1.5,82,0.30,"rgba(255,59,107,0.65)","rgba(232,232,255,0.25)");
              }
            }

            hit = true;
            break;
          }
        }
        if(hit) continue;

        // hits on boss
        if(boss && dist2(b.x,b.y,boss.x,boss.y) < (22*22)){
          const isCrit = (b.crit && Math.random() < (b.crit*0.65));
          const dmg = isCrit ? Math.floor(b.dmg*1.25) : b.dmg;

          boss.hp -= dmg;
          particles(b.x,b.y, isCrit?16:10, 1.0, isCrit?82:58, 0.20, b.col, "rgba(255,255,255,0.35)");
          addBlood(boss.x,boss.y, isCrit?5:2, isCrit);
          Audio.hit(screenPanFromWorld(boss.x));

          if(b.splash){
            applySplash(b.x,b.y,b.splash,dmg,b.col);
            boomFX(b.x,b.y, b.splash*1.0, `rgba(255,59,107,0.42)`);
          }
          if(b.lineSplash){
            applyLineSplash(b.x,b.y,b.lineSplash,dmg,b.col);
          }
          if(b.chain){
            const already = new Set();
            chainFromHit(boss.x,boss.y,already,Math.max(1, b.chain-1),dmg,b.col);
          }

          if(!b.pierce) bullets.splice(i,1);
          player.score += 3;
        }
      }

      // zombies
      for(let i=zombies.length-1;i>=0;i--){
        const z = zombies[i];
        z.t += 1;

        if(z.burn > 0){
          z.burn = Math.max(0, z.burn - dt);
          if(Math.random() < 0.22){
            z.hp -= 2;
            particles(z.x,z.y,1,0.2,18,0.10,"rgba(255,210,74,0.45)","rgba(255,59,107,0.35)");
          }
        }
        if(z.bleed > 0){
          z.bleed = Math.max(0, z.bleed - dt);
          if(Math.random() < 0.10){
            addBlood(z.x,z.y, 1, false);
          }
        }

        if(z.slow > 0) z.slow = Math.max(0, z.slow - dt);
        const slowMul = z.slow > 0 ? 0.55 : 1.0;

        const a = Math.atan2(player.y - z.y, player.x - z.x);
        z.vx = Math.cos(a)*z.spd*slowMul;
        z.vy = Math.sin(a)*z.spd*slowMul;
        z.x += z.vx*dt;
        z.y += z.vy*dt;

        z.x = clamp(z.x, arena.x0-12, arena.x1+12);
        z.y = clamp(z.y, arena.y0-12, arena.y1+12);

        if(dist2(z.x,z.y,player.x,player.y) < (10*10)){
          hurtPlayer(z.elite ? 12 : 8);
        }

        if(z.hp<=0){
          zombies.splice(i,1);
        }
      }

      // boss (limited adds, less “stomp” shake)
      if(boss){
        boss.t += 1;

        if(boss.slow > 0) boss.slow = Math.max(0, boss.slow - dt);
        const slowMul = boss.slow > 0 ? 0.62 : 1.0;

        const a = Math.atan2(player.y - boss.y, player.x - boss.x);
        const hpP = boss.hp / boss.maxHp;

        const drift = (boss.kind===1) ? (Math.sin(boss.t*0.05)*10) : (Math.sin(boss.t*0.04)*6);
        const spdBoost = hpP < 0.55 ? 1.15 : 1.0;
        boss.x += (Math.cos(a)*boss.spd*spdBoost*slowMul + drift)*dt;
        boss.y += (Math.sin(a)*boss.spd*spdBoost*slowMul - drift)*dt;

        boss.x = clamp(boss.x, arena.x0+18, arena.x1-18);
        boss.y = clamp(boss.y, arena.y0+20, arena.y1-18);

        boss.atkCD -= dt;
        if(boss.atkCD <= 0){
          // less spam, less screen abuse
          boss.atkCD =
              (boss.kind===0) ? (hpP < 0.5 ? 1.05 : 1.25)
            : (boss.kind===1) ? (hpP < 0.5 ? 1.10 : 1.35)
            :                 (hpP < 0.5 ? 1.05 : 1.30);

          particles(boss.x,boss.y,40,1.7,82,0.48,
            boss.kind===2 ? "#00ffd5" : "#ff3b6b",
            boss.kind===1 ? "#b300ff" : "#00ffd5"
          );
          addRing(boss.x,boss.y, 10, 0.28, "rgba(255,255,255,0.10)");
          shake = Math.max(shake, 2.4);
          flash = Math.max(flash, 0.08);

          const d = Math.sqrt(dist2(boss.x,boss.y,player.x,player.y));

          // hits you if close, but not constant “stomp”
          if(boss.kind===0){
            if(d < 40) hurtPlayer(hpP < 0.5 ? 16 : 13);
          } else if(boss.kind===1){
            if(d < 54) hurtPlayer(hpP < 0.5 ? 13 : 10);
          } else {
            if(d < 70){
              hurtPlayer(hpP < 0.5 ? 12 : 9);
              player.dashCD = Math.max(player.dashCD, 0.35);
            }
          }

          // limited adds total per boss wave
          if(wave.bossAddBudget > 0){
            const aliveRoom = Math.max(0, director.aliveCap() - zombies.length);
            const want = (hpP < 0.5) ? 1 : 1;
            const add = Math.min(want, wave.bossAddBudget, aliveRoom);
            for(let k=0;k<add;k++) spawnZombie(Math.random()<0.26);
            wave.bossAddBudget -= add;
          }
        }

        if(dist2(boss.x,boss.y,player.x,player.y) < (22*22)){
          hurtPlayer(14);
        }

        if(boss.hp <= 0){
          player.score += 900;
          player.cash += 360;
          boomFX(boss.x,boss.y, 86, "rgba(179,0,255,0.55)");
          boss = null;
          bossesDefeated++;

          // guaranteed key drop on boss kill
          drops.push({x:player.x+rand(-20,20), y:player.y+rand(-20,20), kind:"key", picked:false, t:0});
          Audio.pickup(0);

          wave.phase = "REST";
          wave.timer = 0.75;
          wave.shopPhase = "OPEN";
          wave.restLock = 0.20;
          spawnCrates();
          shopOpen = true;
        }
      }

      player.score += dt * (4 + wave.n*0.22);

      if(player.hp <= 0){
        state = STATE.DEAD;
        Audio.death(0);
        if(player.score > highScore){
          highScore = Math.floor(player.score);
          localStorage.setItem(HS_KEY, String(highScore));
        }
      }

      pressed.clear();
      return;
    }
  }

  // ======== Render ========
  function render(){
    const sx = shake>0 ? randi(-shake, shake) : 0;
    const sy = shake>0 ? randi(-shake, shake) : 0;
    shake = Math.max(0, shake - 0.55); // quicker decay, less stomp-feel

    updateCamera();

    // ===== TITLE =====
    if(state === STATE.TITLE){
      g.fillStyle = "#050214";
      g.fillRect(0,0,W,H);

      // star/noise sparkle
      for(let i=0;i<130;i++){
        const x = (Math.sin(titleT*0.7 + i*13.7)*0.5+0.5)*W;
        const y = (Math.cos(titleT*0.55 + i*9.3)*0.5+0.5)*H;
        const tw = (Math.sin(titleT*2.3 + i)*0.5+0.5);
        g.fillStyle = `rgba(232,232,255,${0.06+tw*0.10})`;
        g.fillRect(x|0,y|0,1,1);
      }

      // header panels
      g.fillStyle = "rgba(179,0,255,0.20)";
      g.fillRect(0,0,W,62);
      g.fillStyle = "rgba(0,255,213,0.10)";
      g.fillRect(0,62,W,10);

      // scanlines
      g.fillStyle = "rgba(0,0,0,0.10)";
      for(let y=0;y<H;y+=2) g.fillRect(0,y,W,1);

      drawText("CLUB DECAY", 34, 40, 2.6, "#e8e8ff");
      drawText("CHIMP VS ZOMBIES", 56, 58, 1.2, "rgba(0,255,213,0.92)");

      const pulse = 0.55 + 0.45*Math.sin(titleT*3.0);
      g.fillStyle = `rgba(179,0,255,${0.10 + pulse*0.12})`;
      g.fillRect(22, 78, W-44, 64);
      g.strokeStyle = "rgba(0,255,213,0.25)";
      g.strokeRect(22, 78, W-44, 64);

      drawText("ENTER / E / SPACE", 66, 102, 1.2, "#00ffd5");
      drawText("START", 132, 120, 1.6, "#e8e8ff");

      drawText("Press any key/click to enable audio", 36, 152, 0.95, "rgba(232,232,255,0.72)");
      drawText(`M toggles mute: ${Audio.isMuted() ? "ON" : "OFF"}`, 72, 166, 0.95, "rgba(232,232,255,0.62)");
      drawText(`Keys unlocked: ${keysUnlocked}`, 214, 166, 0.95, "rgba(179,0,255,0.85)");

      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(world, 0, 0, W, H, 0, 0, canvas.width, canvas.height);
      return;
    }

    drawArenaBackdrop();

    g.save();
    g.translate(sx, sy);

    // ===== BUNKER =====
    if(state === STATE.BUNKER){
      g.fillStyle = "#050214";
      g.fillRect(0,0,W,H);

      // luxe bunker frame
      g.fillStyle = "rgba(0,0,0,0.55)";
      g.fillRect(10,10,W-20,H-20);
      g.strokeStyle = "rgba(179,0,255,0.55)";
      g.strokeRect(10.5,10.5,W-21,H-21);
      g.strokeStyle = "rgba(0,255,213,0.18)";
      g.strokeRect(13.5,13.5,W-27,H-27);

      // ambient shimmer
      for(let i=0;i<80;i++){
        const x = (Math.random()*W)|0;
        const y = (Math.random()*H)|0;
        g.fillStyle = Math.random()<0.5 ? "rgba(179,0,255,0.04)" : "rgba(0,255,213,0.03)";
        g.fillRect(x,y,1,1);
      }

      drawText("CLUB DECAY", 22, 28, 2.2, "#e8e8ff");
      drawText("BUNKER LOADOUT", 22, 44, 1.05, "rgba(0,255,213,0.90)");
      drawText("W/S select · 1/2/3 choose slot · E/ENTER equip · SPACE deploy", 22, 58, 0.90, "rgba(232,232,255,0.62)");
      drawText(`KEYS: ${keysUnlocked}  (Bosses drop keys)`, 210, 58, 0.90, "rgba(179,0,255,0.80)");
      drawText("Q cycles SKILL", 22, 70, 0.90, "rgba(232,232,255,0.62)");
      drawText(`M mute: ${Audio.isMuted() ? "ON" : "OFF"}`, 220, 70, 0.90, "rgba(232,232,255,0.55)");

      const visible = WEAPONS.filter(w => !w.key || keysUnlocked >= w.key);
      const startY = 86;
      const showMax = 7; // cleaner bunker list
      let page = Math.floor(bunkerCursor / showMax);
      let s0 = page*showMax;
      let s1 = Math.min(visible.length, s0 + showMax);

      for(let i=s0;i<s1;i++){
        const w = visible[i];
        const row = i - s0;
        const y = startY + row*12;

        const cur = (i===bunkerCursor);
        if(cur){
          g.fillStyle = "rgba(0,255,213,0.10)";
          g.fillRect(18, y-9, W-36, 11);
          g.fillStyle = "rgba(179,0,255,0.16)";
          g.fillRect(18, y-9, 6, 11);
        }

        g.fillStyle = "rgba(255,255,255,0.06)";
        g.fillRect(22, y-8, 10, 10);
        g.fillStyle = w.color;
        g.fillRect(24, y-6, 6, 6);

        drawText(w.name.toUpperCase(), 40, y, 1.0, w.color);
        const meta = w.melee ? `MELEE dmg:${w.dmg}` : `dmg:${w.dmg} rate:${(w.fireRate||0).toFixed(1)}`;
        const tag = w.key ? `KEY-${w.key}` : "";
        drawText(meta, 178, y, 0.85, "rgba(232,232,255,0.55)");
        if(tag) drawText(tag, 282, y, 0.85, "rgba(179,0,255,0.80)");
      }

      // page hint
      if(visible.length > showMax){
        drawText(`LIST ${page+1}/${Math.ceil(visible.length/showMax)}`, 244, 86, 0.85, "rgba(232,232,255,0.45)");
      }

      // slots bar
      g.fillStyle = "rgba(0,0,0,0.55)";
      g.fillRect(12,H-40,W-24,30);
      g.strokeStyle = "rgba(255,255,255,0.10)";
      g.strokeRect(12.5,H-40.5,W-25,30);

      drawText("SLOTS:", 18, H-22, 0.95, "rgba(232,232,255,0.82)");
      for(let i=0;i<3;i++){
        const id = bunkerSlots[i];
        const w = byId[id] || byId.pistol;
        const x = 68+i*82;
        g.fillStyle = (i===bunkerSlotFocus) ? "rgba(179,0,255,0.36)" : "rgba(255,255,255,0.08)";
        g.fillRect(x, H-32, 76, 14);
        g.fillStyle = w.color;
        g.fillRect(x+3, H-29, 8, 8);
        drawText(`${i+1}:${w.name}`, x+14, H-20, 0.85, "#e8e8ff");
      }

      const sk = skillById[player.skillId] || skillById.pulse;
      g.fillStyle = "rgba(255,255,255,0.06)";
      g.fillRect(14, H-14, W-28, 12);
      drawText(`Q SKILL: ${sk.name.toUpperCase()} · ${sk.desc}`, 18, H-4, 0.9, "rgba(232,232,255,0.78)");

      g.restore();
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(world, 0, 0, W, H, 0, 0, canvas.width, canvas.height);
      return;
    }

    // ===== PLAY / DEAD =====
    const ox = camera.x, oy = camera.y;

    // trails
    for(const t of trails){
      const x = Math.floor(t.x - ox), y = Math.floor(t.y - oy);
      if(x<-10||x>W+10||y<-10||y>H+10) continue;
      g.fillStyle = `rgba(179,0,255,${0.16*(t.life/0.22)})`;
      g.fillRect(x-4,y-4,8,8);
      g.fillStyle = `rgba(0,255,213,${0.12*(t.life/0.22)})`;
      g.fillRect(x-2,y-2,4,4);
    }

    // crates
    for(const c of crates){
      const x = Math.floor(c.x - ox), y = Math.floor(c.y - oy);
      if(x<-10||x>W+10||y<-10||y>H+10) continue;
      g.fillStyle = c.open ? "rgba(255,255,255,0.08)" : "rgba(179,0,255,0.18)";
      g.fillRect(x-5,y-5,10,10);
      g.fillStyle = c.open ? "rgba(0,0,0,0.45)" : "rgba(0,255,213,0.22)";
      g.fillRect(x-3,y-3,6,6);
    }

    // drops (keys)
    for(const d of drops){
      if(d.picked) continue;
      const x = Math.floor(d.x - ox), y = Math.floor(d.y - oy);
      if(x<-12||x>W+12||y<-12||y>H+12) continue;
      const bob = Math.floor(Math.sin((d.t||0)*6)*2);
      g.fillStyle = "rgba(179,0,255,0.30)";
      g.fillRect(x-5, y-7+bob, 10, 14);
      g.fillStyle = "rgba(0,255,213,0.22)";
      g.fillRect(x-3, y-5+bob, 6, 10);
      g.fillStyle = "#e8e8ff";
      g.fillRect(x-1, y-1+bob, 2, 2);
    }

    // bullets
    for(const b of bullets){
      const sxp = Math.floor(b.x - ox);
      const syp = Math.floor(b.y - oy);
      if(sxp<-3 || sxp>W+3 || syp<-3 || syp>H+3) continue;
      g.fillStyle = b.col;
      const sz = (b.kind==="grenade" || b.kind==="nova") ? 4 : (b.kind==="rocket" ? 3 : 3);
      g.fillRect(sxp-1, syp-1, sz, sz);
      g.fillStyle = "rgba(255,255,255,0.18)";
      g.fillRect(sxp, syp, 1, 1);
    }

    // zombies
    for(const z of zombies){
      const sxz = z.x - ox, syz = z.y - oy;
      if(sxz<-24 || sxz>W+24 || syz<-24 || syz>H+24) continue;
      drawZombie({ ...z, x:sxz, y:syz });
    }

    // boss
    if(boss){
      drawBoss({ ...boss, x:boss.x-ox, y:boss.y-oy });
    }

    // shockwave rings
    for(const r of rings){
      const x = r.x - ox, y = r.y - oy;
      if(x<-120||x>W+120||y<-120||y>H+120) continue;
      const a = sat(r.life/r.max);
      g.globalAlpha = 0.62*a;
      g.strokeStyle = r.col;
      g.beginPath();
      g.arc(x, y, r.rad, 0, Math.PI*2);
      g.stroke();
      g.globalAlpha = 1;
    }

    // player
    const aimWorldX = camera.x + mouse.x;
    const aimWorldY = camera.y + mouse.y;
    const aimAng = Math.atan2(aimWorldY-player.y, aimWorldX-player.x);
    const blink = player.invuln>0 && (Math.floor(performance.now()/70)%2===0);
    if(!blink) drawChimp(player.x-ox, player.y-oy, player.dir, player.frame, aimAng, player.frenzyT);

    // particles
    for(const p of sparks){
      const spx = Math.floor(p.x - ox);
      const spy = Math.floor(p.y - oy);
      if(spx<0||spx>=W||spy<0||spy>=H) continue;
      g.fillStyle = p.col;
      g.fillRect(spx, spy, 1, 1);
    }
    for(const f of floats){
      const fx = Math.floor(f.x - ox);
      const fy = Math.floor(f.y - oy);
      if(fx<-40||fx>W+40||fy<-20||fy>H+20) continue;
      drawText(f.text, fx, fy, 1.0, f.col);
    }

    // ===== HUD =====
    g.fillStyle = "rgba(0,0,0,0.52)";
    g.fillRect(0,0,W,30);
    g.fillStyle = "rgba(179,0,255,0.12)";
    g.fillRect(0,28,W,2);

    drawText(`SCORE ${Math.floor(player.score)}`, 8, 12, 1.0, "#e8e8ff");
    drawText(`CASH ${Math.floor(player.cash)}$`, 110, 12, 1.0, "rgba(0,255,213,0.90)");
    drawText(`HI ${highScore}`, 232, 12, 1.0, "rgba(232,232,255,0.70)");
    drawText(`KEYS ${keysUnlocked}`, 274, 12, 0.9, "rgba(179,0,255,0.80)");

    drawText(`WAVE ${wave.n} ${wave.phase==="REST"?"(REST)":wave.phase==="FIGHT"?"(FIGHT)":"(CLEAR)"}`, 8, 24, 0.9, "rgba(232,232,255,0.70)");
    drawText(`DASH ${player.dashCD>0?player.dashCD.toFixed(1):"OK"}`, 160, 24, 0.9, "rgba(232,232,255,0.62)");

    const sk = skillById[player.skillId] || skillById.pulse;
    drawText(`Q ${sk.name.toUpperCase()} ${player.skillCD>0?player.skillCD.toFixed(0):"READY"}`, 236, 24, 0.9, "rgba(232,232,255,0.62)");

    const hpP = clamp(player.hp/100, 0, 1);
    g.fillStyle = "rgba(255,255,255,0.10)";
    g.fillRect(8, 34, 150, 8);
    g.fillStyle = hpP>0.4 ? "#7CFF6B" : "#ff3b6b";
    g.fillRect(8, 34, 150*hpP, 8);
    g.strokeStyle = "rgba(255,255,255,0.16)";
    g.strokeRect(8, 34, 150, 8);
    drawText(`HP`, 164, 41, 0.9, "rgba(232,232,255,0.78)");

    if(player.frenzyT > 0){
      const p = sat(player.frenzyT/4.6);
      g.fillStyle = "rgba(0,255,213,0.12)";
      g.fillRect(178, 34, 134*p, 8);
      drawText("FRENZY", 178, 41, 0.9, "rgba(0,255,213,0.85)");
    }

    if(boss){
      const bp = clamp(boss.hp/boss.maxHp, 0, 1);
      g.fillStyle = "rgba(0,0,0,0.50)";
      g.fillRect(8, 48, 304, 10);
      g.fillStyle = (boss.kind===0) ? "#ff3b6b" : (boss.kind===1 ? "#b300ff" : "#00ffd5");
      g.fillRect(8, 48, 304*bp, 10);
      g.strokeStyle = "rgba(255,255,255,0.16)";
      g.strokeRect(8, 48, 304, 10);
      const bname = (boss.kind===0) ? "BOSS I" : (boss.kind===1 ? "BOSS II" : "BOSS III");
      drawText(bname, 264, 56, 0.9, "#e8e8ff");
    }

    const mmW = 72, mmH = 40;
    const mmX = W - mmW - 8;
    const mmY = 34;
    g.fillStyle = "rgba(0,0,0,0.42)";
    g.fillRect(mmX, mmY, mmW, mmH);
    g.strokeStyle = "rgba(179,0,255,0.26)";
    g.strokeRect(mmX, mmY, mmW, mmH);

    const sxm = mmW / MAP_W;
    const sym = mmH / MAP_H;

    g.strokeStyle = "rgba(0,255,213,0.22)";
    g.strokeRect(mmX + arena.x0*sxm, mmY + arena.y0*sym, (arena.x1-arena.x0)*sxm, (arena.y1-arena.y0)*sym);

    g.fillStyle = "#e8e8ff";
    g.fillRect(Math.floor(mmX + player.x*sxm)-1, Math.floor(mmY + player.y*sym)-1, 3, 3);

    let shown = 0;
    for(const z of zombies){
      if(shown++ > 55) break;
      g.fillStyle = z.elite ? "rgba(35,255,134,0.85)" : "rgba(90,167,255,0.75)";
      g.fillRect(Math.floor(mmX + z.x*sxm), Math.floor(mmY + z.y*sym), 1, 1);
    }
    if(boss){
      g.fillStyle = "rgba(255,59,107,0.90)";
      g.fillRect(Math.floor(mmX + boss.x*sxm)-1, Math.floor(mmY + boss.y*sym)-1, 3, 3);
    }

    const yb = H-16;
    for(let i=0;i<3;i++){
      const id = player.selected[i];
      g.fillStyle = "rgba(255,255,255,0.07)";
      g.fillRect(8+i*104, yb, 96, 12);
      if(id){
        const w = byId[id];
        g.fillStyle = (i===player.slot) ? "rgba(179,0,255,0.34)" : "rgba(0,0,0,0.25)";
        g.fillRect(8+i*104, yb, 96, 12);
        g.fillStyle = w.color;
        g.fillRect(10+i*104, yb+2, 8, 8);
        drawText(`${i+1}:${w.name}`, 22+i*104, yb+10, 0.9, "#e8e8ff");
      } else {
        drawText(`${i+1}: -`, 22+i*104, yb+10, 0.9, "rgba(232,232,255,0.4)");
      }
    }

    if(wave.phase === "REST"){
      g.fillStyle = "rgba(0,0,0,0.55)";
      g.fillRect(44, 62, 232, 56);
      drawText("REST ROUND", 112, 80, 1.3, "#00ffd5");
      drawText("Shop auto-opens. C starts wave.", 64, 96, 1.0, "rgba(232,232,255,0.78)");
      drawText("Crates/Keys: E · Close shop: ESC", 56, 108, 1.0, "rgba(232,232,255,0.72)");
      const nxtBoss = bossesDefeated>=3 ? "NO MORE BOSSES" : `BOSS AT WAVE ${[5,10,15][bossesDefeated]}`;
      drawText(nxtBoss, 96, 120, 0.95, "rgba(232,232,255,0.55)");
    }

    if(shopOpen){
      g.fillStyle = "rgba(0,0,0,0.78)";
      g.fillRect(0,0,W,H);
      drawText("SHOP (BETWEEN WAVES)", 52, 26, 1.6, "#00ffd5");
      drawText(`CASH ${Math.floor(player.cash)}$`, 118, 44, 1.1, "rgba(232,232,255,0.9)");
      drawText("W/S select · E/ENTER buy · 1/2/3 target slot · C start", 16, 60, 0.95, "rgba(232,232,255,0.72)");

      g.fillStyle = "rgba(255,255,255,0.06)";
      g.fillRect(16, 68, W-32, 12);
      drawText("REPLACE SLOT:", 22, 78, 0.9, "rgba(232,232,255,0.72)");
      for(let i=0;i<3;i++){
        const id = player.selected[i];
        const w = id ? byId[id] : null;
        const bx = 124 + i*62;
        g.fillStyle = (i===shopSlotFocus) ? "rgba(179,0,255,0.32)" : "rgba(0,0,0,0.25)";
        g.fillRect(bx, 70, 56, 10);
        g.fillStyle = w ? w.color : "rgba(232,232,255,0.25)";
        g.fillRect(bx+2, 72, 6, 6);
        drawText(`${i+1}`, bx+12, 78, 0.9, "#e8e8ff");
        drawText(w ? w.name : "-", bx+24, 78, 0.9, "rgba(232,232,255,0.75)");
      }

      const startY = 92;
      for(let i=0;i<SHOP_EXCLUSIVE.length;i++){
        const id = SHOP_EXCLUSIVE[i];
        const w = byId[id];
        const yy = startY + i*10;
        if(yy > H-12) break;

        const cur = (i===shopCursor);
        const owned = player.selected.includes(id);
        const afford = canBuy(id);
        const gated = (w && w.key && keysUnlocked < w.key);

        if(cur){
          g.fillStyle = "rgba(179,0,255,0.20)";
          g.fillRect(16, yy-9, W-32, 11);
        }

        g.fillStyle = "rgba(255,255,255,0.06)";
        g.fillRect(20, yy-8, 10, 10);
        g.fillStyle = w.color;
        g.fillRect(22, yy-6, 6, 6);

        drawText(w.name.toUpperCase(), 36, yy, 1.0, w.color);
        drawText(`${w.price}$`, 190, yy, 1.0, "rgba(232,232,255,0.80)");

        let tag = owned ? "OWNED" : (afford ? "BUY" : "LOCKED");
        let col = owned ? "rgba(232,232,255,0.5)" : (afford ? "#7CFF6B" : "#ff3b6b");
        if(gated){
          tag = `KEY-${w.key}`;
          col = "rgba(179,0,255,0.85)";
        }
        drawText(tag, 252, yy, 1.0, col);
      }
    }

    if(state === STATE.DEAD){
      g.fillStyle = "rgba(0,0,0,0.70)";
      g.fillRect(0,0,W,H);
      drawText("YOU GOT ERASED.", 86, 64, 1.9, "#ff3b6b");
      drawText(`SCORE ${Math.floor(player.score)} | WAVE ${wave.n}`, 84, 88, 1.1, "#e8e8ff");
      drawText(`HIGH SCORE ${highScore}`, 104, 106, 1.1, "#00ffd5");
      drawText(`BOSSES DOWN ${bossesDefeated}/3`, 98, 120, 1.0, "rgba(232,232,255,0.72)");
      drawText("ENTER retry | ESC bunker", 86, 142, 1.0, "rgba(232,232,255,0.80)");
    }

    if(paused){
      g.fillStyle = "rgba(0,0,0,0.62)";
      g.fillRect(0,0,W,H);
      drawText("PAUSED", 132, 88, 1.8, "#e8e8ff");
      drawText("Press P to resume", 104, 108, 1.0, "rgba(232,232,255,0.75)");
    }

    if(flash > 0.001){
      g.fillStyle = `rgba(255,255,255,${flash*0.28})`;
      g.fillRect(0,0,W,H);
      g.fillStyle = `rgba(179,0,255,${flash*0.16})`;
      g.fillRect(0,0,W,H);
    }

    g.restore();

    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(world, 0, 0, W, H, 0, 0, canvas.width, canvas.height);
  }

  // ======== Loop ========
  function loop(now){
    const dt = Math.min(0.05, (now - last)/1000);
    last = now;
    acc += dt;
    while(acc >= DT){
      update(DT);
      acc -= DT;
    }
    render();
    requestAnimationFrame(loop);
  }

  // ======== Start ========
  resetRun();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
