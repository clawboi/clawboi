<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CLUB DECAY: Chimp vs Zombies</title>
  <style>
    :root{
      --bg:#05030a;
      --ui:#e8e8ff;
      --muted:#9aa0c6;
      --accent:#b300ff;
      --accent2:#00ffd5;
      --danger:#ff3b6b;
      --ok:#7CFF6B;
    }
    html,body{
      height:100%; margin:0;
      background: radial-gradient(1200px 800px at 50% 40%, #160a30 0%, #05030a 55%, #02010a 100%);
      color:var(--ui);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      overflow:hidden;
    }
    #wrap{height:100%; display:grid; place-items:center;}

    /* Fullscreen-friendly canvas */
    canvas{
      width:min(96vw, 1280px);
      height:auto;
      max-height:88vh;
      aspect-ratio: 16 / 9;

      image-rendering: pixelated;
      image-rendering: crisp-edges;
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 16px;
      background: #03020a;
      box-shadow:
        0 18px 70px rgba(0,0,0,0.70),
        0 0 0 1px rgba(179,0,255,0.20) inset,
        0 0 70px rgba(179,0,255,0.10);
    }
    .hint{
      position:fixed; left:14px; bottom:12px;
      font-size:12px; color:var(--muted);
      user-select:none;
      opacity:0.92;
    }
    .hint b{color:var(--ui)}
    .topright{
      position:fixed; right:14px; top:12px;
      font-size:12px; color:var(--muted);
      user-select:none;
      opacity:0.92;
      text-align:right;
    }
    .topright .tag{color:rgba(255,255,255,0.66)}
    a{color:var(--accent2)}
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="c" width="960" height="540"></canvas>
</div>

<div class="topright">
  CLUB DECAY MINI-GAME<br/>
  <span class="tag">One-file build · Waves + Auto Shop + Skills</span>
</div>

<div class="hint">
  <b>Move</b> WASD · <b>Aim/Shoot</b> Mouse · <b>Punch</b> Space · <b>Swap</b> 1/2/3 ·
  <b>Dash</b> Shift · <b>Pulse</b> Q · <b>Pause</b> P · <b>Continue</b> C (between waves) · <b>Interact</b> E · <b>Restart</b> Enter
</div>

<script>
(() => {
  // ======== Canvas & Pixel World ========
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });

  // Viewport logical res (rendered then upscaled)
  const W = 320, H = 180;
  const world = document.createElement('canvas');
  world.width = W; world.height = H;
  const g = world.getContext('2d', { alpha: false });

  // ======== Utilities ========
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const rand = (a,b)=>a+Math.random()*(b-a);
  const randi = (a,b)=> (a + Math.floor(Math.random()*(b-a+1)));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const dist2 = (ax,ay,bx,by)=>{ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; };

  // Fixed timestep
  let last = performance.now();
  let acc = 0;
  const DT = 1/60;

  // ======== Input ========
  const keys = new Set();
  const pressed = new Set();
  let mouse = { x: W/2, y: H/2, down:false };

  window.addEventListener('keydown', (e)=>{
    const k = e.key.toLowerCase();
    keys.add(k);
    pressed.add(k);
    if([" ", "arrowup","arrowdown","arrowleft","arrowright"].includes(e.key)) e.preventDefault();
  }, {passive:false});

  window.addEventListener('keyup', (e)=> keys.delete(e.key.toLowerCase()));

  canvas.addEventListener('mousemove', (e)=>{
    const rect = canvas.getBoundingClientRect();
    const sx = (e.clientX - rect.left) / rect.width;
    const sy = (e.clientY - rect.top) / rect.height;
    mouse.x = clamp(Math.floor(sx * W), 0, W-1);
    mouse.y = clamp(Math.floor(sy * H), 0, H-1);
  });

  canvas.addEventListener('mousedown', ()=>{ mouse.down=true; });
  window.addEventListener('mouseup', ()=>{ mouse.down=false; });

  // ======== State ========
  const STATE = { BUNKER:1, PLAY:2, DEAD:3 };
  let state = STATE.BUNKER;
  let paused = false;

  // High score
  const HS_KEY = "club_chimp_zombie_highscore_v3";
  let highScore = Number(localStorage.getItem(HS_KEY) || 0);

  // ======== FX ========
  let shake = 0;
  const sparks = [];   // {x,y,vx,vy,life,col}
  const floats = [];   // {x,y,vx,vy,life,text,col}
  const trails = [];   // dash trails {x,y,life}
  const particles = (x,y,count,spread,speed,life,colA,colB)=>{
    for(let i=0;i<count;i++){
      const a = rand(0,Math.PI*2);
      const s = rand(speed*0.35, speed);
      sparks.push({
        x,y,
        vx: Math.cos(a)*s + rand(-spread,spread),
        vy: Math.sin(a)*s + rand(-spread,spread),
        life: rand(life*0.6, life),
        col: (Math.random()<0.5?colA:colB)
      });
    }
  };

  // ======== Big Map + Camera ========
  const MAP_W = 1120;
  const MAP_H = 720;
  const camera = { x: 0, y: 0 };
  function updateCamera(){
    camera.x = clamp(player.x - W/2, 0, MAP_W - W);
    camera.y = clamp(player.y - H/2, 0, MAP_H - H);
  }

  // ======== Arena ========
  const arena = { x0: 36, y0: 30, x1: MAP_W-36, y1: MAP_H-36 };

  // ======== Calm “realistic” floor (NO disco, NO cycling) ========
  // Muted concrete grid + subtle static speckle (stable, non-flashing).
  const FLOOR_TILE = 12;
  const floorCache = document.createElement('canvas');
  floorCache.width = MAP_W;
  floorCache.height = MAP_H;
  const fg = floorCache.getContext('2d', { alpha:false });

  function buildFloor(){
    // base concrete
    fg.fillStyle = "#0b0a12";
    fg.fillRect(0,0,MAP_W,MAP_H);

    // faint mottling (static)
    for(let i=0;i<22000;i++){
      const x = (Math.random()*MAP_W)|0;
      const y = (Math.random()*MAP_H)|0;
      const v = Math.random();
      fg.fillStyle = v<0.5 ? "rgba(255,255,255,0.015)" : "rgba(0,0,0,0.02)";
      fg.fillRect(x,y,1,1);
    }

    // grid lines (very subtle)
    fg.strokeStyle = "rgba(255,255,255,0.05)";
    fg.lineWidth = 1;
    for(let x=0; x<MAP_W; x+=FLOOR_TILE){
      fg.beginPath();
      fg.moveTo(x+0.5, 0);
      fg.lineTo(x+0.5, MAP_H);
      fg.stroke();
    }
    for(let y=0; y<MAP_H; y+=FLOOR_TILE){
      fg.beginPath();
      fg.moveTo(0, y+0.5);
      fg.lineTo(MAP_W, y+0.5);
      fg.stroke();
    }

    // arena boundary tint (static)
    fg.fillStyle = "rgba(179,0,255,0.06)";
    fg.fillRect(arena.x0, arena.y0, (arena.x1-arena.x0), (arena.y1-arena.y0));

    // small scuffs
    for(let i=0;i<260;i++){
      const x = rand(arena.x0+20, arena.x1-20);
      const y = rand(arena.y0+20, arena.y1-20);
      const w = rand(8,24), h = rand(2,6);
      fg.fillStyle = "rgba(255,255,255,0.018)";
      fg.fillRect(x,y,w,h);
    }
  }
  buildFloor();

  // ======== Sprites ========
  function drawChimp(px,py,dir,frame,aimAng){
    const x = Math.floor(px), y = Math.floor(py);
    const fur = "#6b4a2f";
    const dark = "#3b2416";
    const face = "#b88960";
    const eye = "#f4f4ff";
    const pupil = "#151018";
    const violet = "#b300ff";
    const teal = "#00ffd5";
    const bob = Math.floor(Math.sin(frame*0.3)*1);

    g.fillStyle = "rgba(0,0,0,0.35)";
    g.fillRect(x-6, y+8, 12, 3);

    g.fillStyle = fur;  g.fillRect(x-5, y-6+bob, 10, 10);
    g.fillStyle = dark; g.fillRect(x-3, y-4+bob, 6, 6);

    g.fillStyle = fur;  g.fillRect(x-6, y-14+bob, 12, 10);
    g.fillStyle = face; g.fillRect(x-4, y-12+bob, 8, 6);

    const ex = dir>0 ? 2 : -4;
    g.fillStyle = eye;   g.fillRect(x+ex, y-12+bob, 3, 2);
    g.fillStyle = pupil; g.fillRect(x+ex+1, y-12+bob, 1, 1);

    g.fillStyle = violet; g.fillRect(x-5, y+1+bob, 10, 2);
    g.fillStyle = teal;   g.fillRect(x-1, y-2+bob, 2, 2);

    g.fillStyle = fur;
    g.fillRect(x-7, y-5+bob, 2, 8);
    g.fillRect(x+5, y-5+bob, 2, 8);

    // aim line
    const ax = x + Math.cos(aimAng)*10;
    const ay = y + Math.sin(aimAng)*10;
    g.strokeStyle = "rgba(0,255,213,0.28)";
    g.beginPath();
    g.moveTo(x, y-2+bob);
    g.lineTo(ax, ay);
    g.stroke();
  }

  function drawZombie(z){
    const x = Math.floor(z.x), y = Math.floor(z.y);
    const bob = Math.floor(Math.sin(z.t*0.2)*1);

    g.fillStyle = "rgba(0,0,0,0.35)";
    g.fillRect(x-5, y+7, 10, 3);

    g.fillStyle = z.elite ? "#23ff86" : "#5aa7ff";
    g.fillRect(x-4, y-6+bob, 8, 10);
    g.fillStyle = z.elite ? "#00c866" : "#2d6fe0";
    g.fillRect(x-5, y-14+bob, 10, 9);

    g.fillStyle = "#0a0a12";
    g.fillRect(x-3, y-12+bob, 2, 2);
    g.fillRect(x+1, y-12+bob, 2, 2);
    g.fillStyle = "#ff3b6b";
    g.fillRect(x-1, y-9+bob, 2, 1);

    g.fillStyle = z.elite ? "#00c866" : "#2d6fe0";
    g.fillRect(x-7, y-4+bob, 2, 7);
    g.fillRect(x+5, y-4+bob, 2, 7);

    // small burn indicator (stable)
    if(z.burn > 0.1){
      g.fillStyle = "rgba(255,210,74,0.55)";
      g.fillRect(x-5, y-16+bob, 3, 1);
      g.fillStyle = "rgba(255,59,107,0.45)";
      g.fillRect(x-2, y-16+bob, 2, 1);
    }
  }

  // Boss variants (every 5 waves, up to 3)
  function drawBoss(b){
    const x = Math.floor(b.x), y = Math.floor(b.y);
    const wob = Math.floor(Math.sin(b.t*0.12)*2);

    // color by type
    const base = (b.kind===0) ? "#ff3b6b" : (b.kind===1 ? "#b300ff" : "#00ffd5");
    const lite = (b.kind===0) ? "#ff7aa0" : (b.kind===1 ? "#d07bff" : "#7fffee");

    g.fillStyle = "rgba(0,0,0,0.45)";
    g.fillRect(x-16, y+18, 32, 6);

    g.fillStyle = base;
    g.fillRect(x-14, y-8+wob, 28, 28);
    g.fillStyle = lite;
    g.fillRect(x-16, y-26+wob, 32, 20);

    g.fillStyle = "#0a0a12";
    g.fillRect(x-9, y-18+wob, 6, 4);
    g.fillRect(x+3, y-18+wob, 6, 4);

    // eyes
    g.fillStyle = (b.kind===2) ? "#0a0a12" : "#0a0a12";
    g.fillStyle = (b.kind===2) ? "#0a0a12" : "#0a0a12";
    g.fillStyle = (b.kind===2) ? "#0a0a12" : "#0a0a12";
    g.fillStyle = (b.kind===2) ? "#0a0a12" : "#0a0a12";
    g.fillStyle = (b.kind===2) ? "#0a0a12" : "#0a0a12";

    g.fillStyle = (b.kind===0) ? "#b300ff" : (b.kind===1 ? "#00ffd5" : "#ff3b6b");
    g.fillRect(x-7, y-17+wob, 2, 2);
    g.fillRect(x+5, y-17+wob, 2, 2);

    g.fillStyle = "#e8e8ff";
    g.fillRect(x-6, y-10+wob, 12, 3);

    g.fillStyle = "rgba(0,0,0,0.25)";
    g.fillRect(x-2, y-2+wob, 4, 6);

    // corners
    g.fillStyle = (b.kind===0) ? "rgba(0,255,213,0.8)" : (b.kind===1 ? "rgba(255,59,107,0.75)" : "rgba(179,0,255,0.75)");
    g.fillRect(x-13, y-28+wob, 4, 4);
    g.fillRect(x+9, y-28+wob, 4, 4);
  }

  // ======== Backdrop ========
  function drawArenaBackdrop(){
    // floor slice (static, calm)
    g.drawImage(floorCache, camera.x, camera.y, W, H, 0, 0, W, H);

    // vignette + top shade for legibility
    g.fillStyle = "rgba(0,0,0,0.16)";
    g.fillRect(0,0,W,H);
    g.fillStyle = "rgba(0,0,0,0.22)";
    g.fillRect(0,0,W,18);

    // walls
    const ax0 = arena.x0 - camera.x;
    const ay0 = arena.y0 - camera.y;
    const aw = (arena.x1 - arena.x0);
    const ah = (arena.y1 - arena.y0);

    g.strokeStyle = "rgba(0,255,213,0.14)";
    g.strokeRect(Math.floor(ax0)+1, Math.floor(ay0)+1, Math.floor(aw)-2, Math.floor(ah)-2);

    g.strokeStyle = "rgba(179,0,255,0.52)";
    g.strokeRect(Math.floor(ax0), Math.floor(ay0), Math.floor(aw), Math.floor(ah));

    // subtle corner plates (static)
    g.fillStyle = "rgba(255,255,255,0.04)";
    g.fillRect(Math.floor(ax0)-1, Math.floor(ay0)-1, 8, 8);
    g.fillRect(Math.floor(ax0+aw)-7, Math.floor(ay0)-1, 8, 8);
    g.fillRect(Math.floor(ax0)-1, Math.floor(ay0+ah)-7, 8, 8);
    g.fillRect(Math.floor(ax0+aw)-7, Math.floor(ay0+ah)-7, 8, 8);
  }

  // ======== Weapons ========
  const WEAPONS = [
    { id:"pistol", name:"Pistol",  color:"#00ffd5",  fireRate: 7.5,  spread: 0.03,  speed: 260, dmg: 34,  pellets:1, recoil:0.75, price:0 },
    { id:"smg",    name:"SMG",     color:"#7CFF6B",  fireRate: 15.0, spread: 0.07,  speed: 270, dmg: 15,  pellets:1, recoil:0.45, price:90 },
    { id:"ar",     name:"AR",      color:"#5aa7ff",  fireRate: 10.5, spread: 0.04,  speed: 290, dmg: 26,  pellets:1, recoil:0.6,  price:140 },
    { id:"burst",  name:"Burst",   color:"#ffd24a",  fireRate: 4.0,  spread: 0.03,  speed: 310, dmg: 20,  pellets:3, burstGap:0.06, recoil:1.0, price:170 },
    { id:"shotgun",name:"Shotgun", color:"#ff3b6b",  fireRate: 1.7,  spread: 0.22,  speed: 230, dmg: 22,  pellets:7, recoil:2.4, price:160 },
    { id:"sniper", name:"Sniper",  color:"#e8e8ff",  fireRate: 1.1,  spread: 0.005, speed: 420, dmg: 120, pellets:1, recoil:3.2, price:260 },
    { id:"laser",  name:"Laser",   color:"#b300ff",  fireRate: 11.0, spread: 0.01,  speed: 380, dmg: 28,  pellets:1, recoil:0.35, pierce:true, price:220 },
    { id:"rail",   name:"Railgun", color:"#00ffd5",  fireRate: 0.85, spread: 0.0,   speed: 520, dmg: 210, pellets:1, recoil:4.0, pierce:true, price:420 },
    { id:"rocket", name:"Rocket",  color:"#ff3b6b",  fireRate: 0.9,  spread: 0.02,  speed: 170, dmg: 80,  pellets:1, recoil:2.6, splash:28, price:330 },
    { id:"flame",  name:"Flame",   color:"#ffd24a",  fireRate: 22.0, spread: 0.14,  speed: 160, dmg: 9,   pellets:1, recoil:0.18, dot:2.2, price:250 },
    { id:"hammer", name:"Hammer",  color:"#ffd24a",  melee:true, dmg: 95, cooldown: 0.44, reach: 16, price:120 }
  ];
  const byId = Object.fromEntries(WEAPONS.map(w=>[w.id,w]));

  // ======== Objects ========
  const player = {
    x: MAP_W/2, y: MAP_H/2,
    vx: 0, vy: 0,
    hp: 100,
    dir: 1,
    invuln: 0,
    frame: 0,
    score: 0,
    cash: 0,
    timeAlive: 0,
    selected: [],
    slot: 0,
    shootCD: 0,
    meleeCD: 0,
    burstLeft: 0,
    burstCD: 0,

    // Dash
    dashCD: 0,
    dashing: 0,
    dashVX: 0,
    dashVY: 0,

    // Skill: Pulse (EMP-ish)
    pulseCD: 0
  };

  const bullets = []; // {x,y,vx,vy,dmg,life,col,pierce,splash,dot}
  const zombies = []; // {x,y,vx,vy,hp,spd,t,elite,burn,slow}
  let boss = null;    // {x,y,hp,maxHp,spd,t,atkCD,kind,slow}
  let bossesDefeated = 0;

  // “More to do”: crates between waves
  const crates = []; // {x,y,open:false,kind}
  function spawnCrates(){
    crates.length = 0;
    const n = 2;
    for(let i=0;i<n;i++){
      const x = rand(arena.x0+40, arena.x1-40);
      const y = rand(arena.y0+40, arena.y1-40);
      crates.push({x,y,open:false,kind: (Math.random()<0.60 ? "cash" : "hp")});
    }
  }

  function resetRun(){
    bullets.length = 0;
    zombies.length = 0;
    sparks.length = 0;
    floats.length = 0;
    trails.length = 0;
    crates.length = 0;
    boss = null;
    bossesDefeated = 0;
    shake = 0;

    player.x = MAP_W/2; player.y = MAP_H/2;
    player.vx = 0; player.vy = 0;
    player.hp = 100;
    player.invuln = 0;
    player.frame = 0;
    player.score = 0;
    player.cash = 0;
    player.timeAlive = 0;
    player.slot = 0;
    player.shootCD = 0;
    player.meleeCD = 0;
    player.burstLeft = 0;
    player.burstCD = 0;
    player.dashCD = 0;
    player.dashing = 0;
    player.dashVX = 0;
    player.dashVY = 0;
    player.pulseCD = 0;

    waveInit();
    updateCamera();
  }

  // ======== Bunker ========
  let bunkerCursor = 0;
  let bunkerPicked = [];
  function bunkerInit(){
    bunkerCursor = 0;
    bunkerPicked = ["pistol","shotgun","hammer"];
  }
  bunkerInit();

  // ======== Waves + Auto Shop ========
  const wave = {
    n: 1,
    phase: "REST",     // REST | FIGHT | CLEAR
    timer: 2.2,
    toSpawn: 0,
    spawned: 0,
    spawnCD: 0,
    // Between-wave shop flow:
    shopPhase: "OPEN", // OPEN | CLOSED (still resting) | READY (press C)
    restLock: 0.35
  };

  let shopOpen = false;

  function waveInit(){
    wave.n = 1;
    wave.phase = "REST";
    wave.timer = 1.2;
    wave.toSpawn = 0;
    wave.spawned = 0;
    wave.spawnCD = 0;
    wave.shopPhase = "OPEN";
    wave.restLock = 0.35;
    spawnCrates();
    shopOpen = true; // auto-open shop every rest round
  }

  function beginWave(){
    wave.phase = "FIGHT";
    wave.spawned = 0;

    const base = 6 + Math.floor(wave.n * 1.6);
    wave.toSpawn = clamp(base, 6, 26);
    wave.spawnCD = 0.18;

    // close shop on wave start
    shopOpen = false;
    wave.shopPhase = "CLOSED";

    particles(player.x, player.y, 18, 1.6, 70, 0.26, "#00ffd5", "#b300ff");
    shake = Math.max(shake, 2);
  }

  function endWave(){
    wave.phase = "REST";
    wave.timer = 1.4;
    wave.n++;
    wave.shopPhase = "OPEN";
    wave.restLock = 0.35;

    spawnCrates();
    shopOpen = true; // auto-open each rest
  }

  // ======== Shop ========
  const SHOP_EXCLUSIVE = ["ar","burst","sniper","laser","rocket","flame","rail","smg"];
  let shopCursor = 0;

  function canBuy(id){
    const w = byId[id];
    if(!w) return false;
    if(player.selected.includes(id)) return false;
    return player.cash >= (w.price||0);
  }

  function buyWeapon(id){
    const w = byId[id];
    if(!w) return;
    if(!canBuy(id)) return;

    player.cash -= w.price;

    // Put into first empty, else replace current slot
    let slot = player.selected.findIndex(v=>!v);
    if(slot < 0) slot = player.slot;
    player.selected[slot] = id;

    particles(player.x, player.y, 22, 1.4, 85, 0.30, "#00ffd5", "#b300ff");
    shake = Math.max(shake, 3);
  }

  // ======== Spawning ========
  function spawnZombie(elite=false){
    const side = randi(0,3);
    let x,y;
    if(side===0){ x = arena.x0-10; y = rand(arena.y0, arena.y1); }
    if(side===1){ x = arena.x1+10; y = rand(arena.y0, arena.y1); }
    if(side===2){ x = rand(arena.x0, arena.x1); y = arena.y0-10; }
    if(side===3){ x = rand(arena.x0, arena.x1); y = arena.y1+10; }

    const hp = elite ? (95 + wave.n*6) : (60 + wave.n*4);
    const spd = elite ? rand(20,30) : rand(15,24);
    zombies.push({ x,y,vx:0,vy:0,hp,spd,t:rand(0,999), elite, burn:0, slow:0 });
  }

  // Boss every 5 rounds, up to 3 bosses (waves 5,10,15).
  function shouldSpawnBossThisWave(){
    if(bossesDefeated >= 3) return false;
    const targets = [5,10,15];
    return targets.includes(wave.n) && !boss;
  }

  function spawnBoss(){
    const side = randi(0,3);
    let x,y;
    if(side===0){ x = arena.x0-26; y = rand(arena.y0, arena.y1); }
    if(side===1){ x = arena.x1+26; y = rand(arena.y0, arena.y1); }
    if(side===2){ x = rand(arena.x0, arena.x1); y = arena.y0-26; }
    if(side===3){ x = rand(arena.x0, arena.x1); y = arena.y1+26; }

    // 3 distinct boss kinds
    const kind = bossesDefeated; // 0,1,2
    const maxHp = 1200 + wave.n*140 + kind*220;
    const spd = 16 + kind*2;

    boss = { x,y, hp:maxHp, maxHp, spd, t:0, atkCD: 1.20, kind, slow:0 };
    particles(x,y,70,1.6,75,0.75,"#ff3b6b","#b300ff");
    shake = 6;
  }

  // ======== Combat ========
  function shootWeapon(w, ang){
    const ox = player.x;
    const oy = player.y-2;

    const makeBullet = (a)=>{
      bullets.push({
        x: ox + Math.cos(a)*6,
        y: oy + Math.sin(a)*6,
        vx: Math.cos(a)*w.speed,
        vy: Math.sin(a)*w.speed,
        dmg: w.dmg,
        life: 1.0,
        col: w.color,
        pierce: !!w.pierce,
        splash: w.splash || 0,
        dot: w.dot || 0
      });
    };

    if(w.burstGap){
      player.burstLeft = w.pellets;
      player.burstCD = 0;
      const a = ang + rand(-w.spread, w.spread);
      makeBullet(a);
      player.burstLeft--;
    } else {
      for(let p=0;p<(w.pellets||1);p++){
        const a = ang + rand(-w.spread, w.spread);
        makeBullet(a);
      }
    }

    particles(ox+Math.cos(ang)*7, oy+Math.sin(ang)*7, 6, 0.6, 52, 0.22, w.color, "rgba(232,232,255,0.55)");
    shake = Math.max(shake, w.recoil || 0.6);
  }

  function applySplash(x,y,rad,dmg,col){
    const r2 = rad*rad;
    for(const z of zombies){
      if(dist2(x,y,z.x,z.y) <= r2){
        z.hp -= Math.floor(dmg*0.75);
        particles(z.x,z.y,8,0.9,55,0.18,col,"rgba(232,232,255,0.45)");
      }
    }
    if(boss && dist2(x,y,boss.x,boss.y) <= (rad+18)*(rad+18)){
      boss.hp -= Math.floor(dmg*0.45);
      particles(boss.x,boss.y,12,1.1,65,0.22,col,"#ff3b6b");
    }
  }

  function meleeHit(w, ang){
    const reach = w.reach || 14;
    const hx = player.x + Math.cos(ang)*reach;
    const hy = player.y + Math.sin(ang)*reach;
    let hitAny = false;

    for(const z of zombies){
      if(dist2(hx,hy,z.x,z.y) < (12*12)){
        z.hp -= w.dmg;
        hitAny = true;
        particles(z.x,z.y,16,1.2,60,0.30,"#ffd24a","#ff3b6b");
        floats.push({x:z.x,y:z.y-6,vx:rand(-8,8),vy:rand(-18,-10),life:0.65,text:`-${w.dmg}`,col:"#ffd24a"});
        shake = Math.max(shake, 3.6);
      }
    }

    if(boss && dist2(hx,hy,boss.x,boss.y) < (26*26)){
      boss.hp -= w.dmg;
      hitAny = true;
      particles(boss.x,boss.y,20,1.5,70,0.36,"#ffd24a","#b300ff");
      floats.push({x:boss.x,y:boss.y-18,vx:rand(-10,10),vy:rand(-20,-12),life:0.75,text:`-${w.dmg}`,col:"#ffd24a"});
      shake = Math.max(shake, 5.6);
    }

    particles(player.x+Math.cos(ang)*10, player.y+Math.sin(ang)*10, hitAny?10:6, 1.0, 42, 0.20, "#ffd24a", "rgba(255,255,255,0.40)");
  }

  function hurtPlayer(amount){
    if(player.invuln > 0) return;
    player.hp -= amount;
    player.invuln = 0.55;
    shake = Math.max(shake, 6);
    particles(player.x, player.y, 28, 1.6, 70, 0.50, "#ff3b6b", "#b300ff");
  }

  // ======== Skills ========
  // Dash: Shift. Short burst, tiny invuln window, trail.
  function doDash(){
    if(player.dashCD > 0 || player.dashing > 0) return;

    let mx=0,my=0;
    if(keys.has("a")) mx -= 1;
    if(keys.has("d")) mx += 1;
    if(keys.has("w")) my -= 1;
    if(keys.has("s")) my += 1;

    // if no input, dash toward aim
    const aimWorldX = camera.x + mouse.x;
    const aimWorldY = camera.y + mouse.y;

    if(mx===0 && my===0){
      const ang = Math.atan2(aimWorldY - player.y, aimWorldX - player.x);
      mx = Math.cos(ang);
      my = Math.sin(ang);
    } else {
      const len = Math.hypot(mx,my)||1;
      mx/=len; my/=len;
    }

    player.dashing = 0.14;
    player.dashCD = 0.85;
    player.invuln = Math.max(player.invuln, 0.18);

    const power = 260;
    player.dashVX = mx*power;
    player.dashVY = my*power;

    particles(player.x, player.y, 22, 1.4, 85, 0.25, "#00ffd5", "#b300ff");
    shake = Math.max(shake, 3);
  }

  // Pulse: Q. Short-radius shock that damages + slows.
  function doPulse(){
    if(player.pulseCD > 0) return;
    player.pulseCD = 6.5;

    const rad = 66;
    const r2 = rad*rad;
    let hits = 0;

    for(const z of zombies){
      if(dist2(player.x,player.y,z.x,z.y) <= r2){
        z.hp -= 22;
        z.slow = Math.max(z.slow, 1.25);
        hits++;
        particles(z.x,z.y,8,1.0,55,0.22,"#00ffd5","#e8e8ff");
      }
    }
    if(boss && dist2(player.x,player.y,boss.x,boss.y) <= (rad+12)*(rad+12)){
      boss.hp -= 30;
      boss.slow = Math.max(boss.slow, 1.0);
      hits++;
      particles(boss.x,boss.y,14,1.2,65,0.26,"#00ffd5","#b300ff");
    }

    // ring FX (stable, not flashing)
    for(let i=0;i<42;i++){
      const a = (i/42)*Math.PI*2;
      sparks.push({
        x: player.x + Math.cos(a)*rad,
        y: player.y + Math.sin(a)*rad,
        vx: Math.cos(a)*38,
        vy: Math.sin(a)*38,
        life: 0.35,
        col: "rgba(0,255,213,0.65)"
      });
    }

    floats.push({x:player.x,y:player.y-18,vx:0,vy:-18,life:0.9,text: hits>0 ? "PULSE" : "PULSE (MISS)", col:"#00ffd5"});
    shake = Math.max(shake, 4);
  }

  // ======== UI Text ========
  function drawText(txt,x,y,scale=1,color="#e8e8ff"){
    g.fillStyle = color;
    g.font = `${8*scale}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace`;
    g.fillText(txt, x, y);
  }
  function niceTime(s){
    const m = Math.floor(s/60);
    const r = Math.floor(s%60).toString().padStart(2,"0");
    return `${m}:${r}`;
  }

  // ======== Update ========
  function update(dt){
    // Always allow pause toggle even when paused (fixes “P won’t resume”)
    if(pressed.has("p") && state === STATE.PLAY){
      paused = !paused;
      pressed.delete("p");
    }

    // If paused, still tick tiny UI/fx (very minimal)
    if(paused){
      for(let i=sparks.length-1;i>=0;i--){
        const p = sparks[i];
        p.x += p.vx*dt*0.35;
        p.y += p.vy*dt*0.35;
        p.vx *= Math.pow(0.08, dt);
        p.vy *= Math.pow(0.08, dt);
        p.life -= dt*0.65;
        if(p.life<=0) sparks.splice(i,1);
      }
      for(let i=floats.length-1;i>=0;i--){
        const f = floats[i];
        f.y += f.vy*dt*0.25;
        f.life -= dt*0.65;
        if(f.life<=0) floats.splice(i,1);
      }
      pressed.clear();
      return;
    }

    // FX
    for(let i=sparks.length-1;i>=0;i--){
      const p = sparks[i];
      p.x += p.vx*dt;
      p.y += p.vy*dt;
      p.vx *= Math.pow(0.02, dt);
      p.vy *= Math.pow(0.02, dt);
      p.life -= dt;
      if(p.life<=0) sparks.splice(i,1);
    }
    for(let i=floats.length-1;i>=0;i--){
      const f = floats[i];
      f.x += f.vx*dt;
      f.y += f.vy*dt;
      f.vx *= Math.pow(0.25, dt);
      f.vy += 30*dt;
      f.life -= dt;
      if(f.life<=0) floats.splice(i,1);
    }
    for(let i=trails.length-1;i>=0;i--){
      const t = trails[i];
      t.life -= dt;
      if(t.life<=0) trails.splice(i,1);
    }

    // Bunker screen
    if(state === STATE.BUNKER){
      if(pressed.has("arrowdown") || pressed.has("s")) bunkerCursor = (bunkerCursor+1) % WEAPONS.length;
      if(pressed.has("arrowup") || pressed.has("w")) bunkerCursor = (bunkerCursor-1+WEAPONS.length) % WEAPONS.length;

      if(pressed.has("enter") || pressed.has("e")){
        const id = WEAPONS[bunkerCursor].id;
        const idx = bunkerPicked.indexOf(id);
        if(idx>=0) bunkerPicked.splice(idx,1);
        else{
          if(bunkerPicked.length < 3) bunkerPicked.push(id);
          else bunkerPicked[bunkerPicked.length-1] = id;
        }
      }
      if(pressed.has(" ")){
        if(bunkerPicked.length === 0) bunkerPicked = ["pistol"];
        player.selected = bunkerPicked.slice(0,3);
        resetRun();
        state = STATE.PLAY;
      }
      pressed.clear();
      return;
    }

    // Dead
    if(state === STATE.DEAD){
      if(pressed.has("enter")){
        resetRun();
        state = STATE.PLAY;
      }
      if(pressed.has("escape")){
        state = STATE.BUNKER;
        bunkerInit();
      }
      pressed.clear();
      return;
    }

    // Play
    if(state === STATE.PLAY){
      player.timeAlive += dt;
      player.frame += 1;

      // skill cooldowns
      player.dashCD = Math.max(0, player.dashCD - dt);
      player.pulseCD = Math.max(0, player.pulseCD - dt);

      // Auto shop behavior between waves:
      // REST always opens shop first, then you press C to continue.
      if(wave.phase === "REST"){
        wave.restLock = Math.max(0, wave.restLock - dt);

        if(wave.shopPhase === "OPEN"){
          shopOpen = true;
        }

        // allow you to close shop (ESC) and then press C to start
        if(shopOpen){
          if(pressed.has("arrowdown") || pressed.has("s")) shopCursor = (shopCursor+1) % SHOP_EXCLUSIVE.length;
          if(pressed.has("arrowup") || pressed.has("w")) shopCursor = (shopCursor-1+SHOP_EXCLUSIVE.length) % SHOP_EXCLUSIVE.length;
          if(pressed.has("enter") || pressed.has("e")){
            buyWeapon(SHOP_EXCLUSIVE[shopCursor]);
          }
          if(pressed.has("escape")){
            shopOpen = false;
            wave.shopPhase = "READY";
          }
          // You can still open crates while shop is up? keep it simple: shop captures inputs.
          pressed.clear();
          return;
        } else {
          // crates + continue prompt
          if(pressed.has("e")){
            for(const c of crates){
              if(c.open) continue;
              if(dist2(c.x,c.y,player.x,player.y) < (16*16)){
                c.open = true;
                if(c.kind === "cash"){
                  const gain = 65 + Math.floor(wave.n*12);
                  player.cash += gain;
                  player.score += gain * 0.75;
                  floats.push({x:c.x,y:c.y-10,vx:rand(-10,10),vy:rand(-24,-14),life:0.9,text:`+${gain}$`,col:"#00ffd5"});
                  particles(c.x,c.y,20,1.6,80,0.30,"#00ffd5","#b300ff");
                } else {
                  const heal = 16 + Math.floor(wave.n*1.5);
                  player.hp = clamp(player.hp + heal, 0, 100);
                  floats.push({x:c.x,y:c.y-10,vx:rand(-10,10),vy:rand(-24,-14),life:0.9,text:`+${heal}HP`,col:"#7CFF6B"});
                  particles(c.x,c.y,18,1.4,75,0.28,"#7CFF6B","#00ffd5");
                }
                shake = Math.max(shake, 2);
                break;
              }
            }
          }

          // press C to start next wave (rest lock prevents accidental instant start)
          if(pressed.has("c") && wave.restLock<=0){
            wave.timer = 0;
          }

          wave.timer -= dt;
          if(wave.timer <= 0){
            beginWave();
          }
        }
      }

      // movement / aim computed regardless (feels responsive)
      let mx=0,my=0;
      if(keys.has("a")) mx -= 1;
      if(keys.has("d")) mx += 1;
      if(keys.has("w")) my -= 1;
      if(keys.has("s")) my += 1;

      // aim world
      const aimWorldX = camera.x + mouse.x;
      const aimWorldY = camera.y + mouse.y;
      const ang = Math.atan2(aimWorldY - player.y, aimWorldX - player.x);
      player.dir = Math.cos(ang) >= 0 ? 1 : -1;

      // dash
      if(pressed.has("shift")) doDash();

      // pulse
      if(pressed.has("q")) doPulse();

      // invuln
      player.invuln = Math.max(0, player.invuln - dt);

      // handle dash movement override
      const baseSpd = 64;
      if(player.dashing > 0){
        player.dashing = Math.max(0, player.dashing - dt);
        player.vx = player.dashVX;
        player.vy = player.dashVY;

        // trail stamps
        if(Math.random() < 0.55){
          trails.push({x:player.x, y:player.y, life:0.22});
        }
      } else {
        const len = Math.hypot(mx,my) || 1;
        mx /= len; my /= len;
        player.vx = lerp(player.vx, mx*baseSpd, 0.2);
        player.vy = lerp(player.vy, my*baseSpd, 0.2);
      }

      player.x += player.vx*dt;
      player.y += player.vy*dt;

      player.x = clamp(player.x, arena.x0+6, arena.x1-6);
      player.y = clamp(player.y, arena.y0+8, arena.y1-8);
      updateCamera();

      // swap weapons
      if(pressed.has("1")) player.slot = 0;
      if(pressed.has("2")) player.slot = 1;
      if(pressed.has("3")) player.slot = 2;

      const wId = player.selected[player.slot] || player.selected[0] || "pistol";
      const weapon = byId[wId] || byId.pistol;

      // burst timing
      if(player.burstLeft > 0){
        player.burstCD -= dt;
        if(player.burstCD <= 0){
          player.burstCD = byId.burst.burstGap;
          const a = ang + rand(-byId.burst.spread, byId.burst.spread);
          bullets.push({
            x: player.x + Math.cos(a)*6,
            y: player.y-2 + Math.sin(a)*6,
            vx: Math.cos(a)*byId.burst.speed,
            vy: Math.sin(a)*byId.burst.speed,
            dmg: byId.burst.dmg,
            life: 1.0,
            col: byId.burst.color,
            pierce:false,
            splash:0,
            dot:0
          });
          particles(player.x+Math.cos(a)*7, player.y-2+Math.sin(a)*7, 4, 0.6, 45, 0.20, byId.burst.color, "rgba(232,232,255,0.50)");
          player.burstLeft--;
        }
      }

      // cooldowns
      player.shootCD = Math.max(0, player.shootCD - dt);
      player.meleeCD = Math.max(0, player.meleeCD - dt);

      // wave logic
      if(wave.phase === "FIGHT"){
        // spawn controlled
        wave.spawnCD -= dt;
        if(wave.spawned < wave.toSpawn && wave.spawnCD <= 0){
          wave.spawnCD = 0.22;
          const eliteChance = clamp((wave.n - 3) / 12, 0, 0.35);
          spawnZombie(Math.random() < eliteChance);
          wave.spawned++;
        }
        if(wave.spawned >= wave.toSpawn) wave.phase = "CLEAR";

        // boss milestone: every 5 rounds, up to 3
        if(shouldSpawnBossThisWave()){
          spawnBoss();
        }
      } else if(wave.phase === "CLEAR"){
        if(zombies.length === 0 && !boss){
          endWave();
        }
      }

      // Combat allowed in FIGHT/CLEAR (and also if you shoot)
      const canCombat = (wave.phase !== "REST") || mouse.down || pressed.has(" ");
      if(canCombat){
        if(weapon.melee){
          if((mouse.down || pressed.has(" ")) && player.meleeCD <= 0){
            player.meleeCD = weapon.cooldown || 0.50;
            meleeHit(weapon, ang);
          }
        }else{
          const rate = weapon.fireRate || 6;
          if(mouse.down && player.shootCD <= 0){
            player.shootCD = 1 / rate;
            shootWeapon(weapon, ang);
          }
          if(pressed.has(" ") && player.meleeCD <= 0){
            player.meleeCD = 0.42;
            meleeHit({dmg:30, reach:12}, ang);
          }
        }
      }

      // bullets
      for(let i=bullets.length-1;i>=0;i--){
        const b = bullets[i];
        b.life -= dt;
        b.x += b.vx*dt;
        b.y += b.vy*dt;

        if(b.life<=0 || b.x<0 || b.x>MAP_W || b.y<0 || b.y>MAP_H){
          bullets.splice(i,1);
          continue;
        }

        // hit zombies
        for(let j=zombies.length-1;j>=0;j--){
          const z = zombies[j];
          if(dist2(b.x,b.y,z.x,z.y) < (7*7)){
            z.hp -= b.dmg;
            if(b.dot) z.burn = Math.max(z.burn, b.dot);
            particles(b.x,b.y,8,0.8,52,0.20,b.col,"rgba(232,232,255,0.45)");

            if(b.splash) applySplash(b.x,b.y,b.splash,b.dmg,b.col);

            if(!b.pierce) bullets.splice(i,1);

            if(z.hp<=0){
              zombies.splice(j,1);
              const reward = z.elite ? 44 : 26;
              player.score += reward;
              player.cash += Math.floor(reward * 0.85);
              particles(z.x,z.y,14,1.1,62,0.40,"#00ffd5","#b300ff");
            }
            break;
          }
        }

        // hit boss
        if(boss && dist2(b.x,b.y,boss.x,boss.y) < (22*22)){
          boss.hp -= b.dmg;
          if(b.splash) applySplash(b.x,b.y,b.splash,b.dmg,b.col);
          particles(b.x,b.y,12,1.0,62,0.22,b.col,"rgba(255,255,255,0.35)");
          if(!b.pierce) bullets.splice(i,1);
          player.score += 3;
        }
      }

      // zombies update
      for(let i=zombies.length-1;i>=0;i--){
        const z = zombies[i];
        z.t += 1;

        // burn DOT
        if(z.burn > 0){
          z.burn = Math.max(0, z.burn - dt);
          if(Math.random() < 0.22){
            z.hp -= 2;
            particles(z.x,z.y,1,0.2,18,0.12,"rgba(255,210,74,0.45)","rgba(255,59,107,0.35)");
          }
        }

        // slow from pulse
        if(z.slow > 0) z.slow = Math.max(0, z.slow - dt);
        const slowMul = z.slow > 0 ? 0.55 : 1.0;

        const a = Math.atan2(player.y - z.y, player.x - z.x);
        z.vx = Math.cos(a)*z.spd*slowMul;
        z.vy = Math.sin(a)*z.spd*slowMul;
        z.x += z.vx*dt;
        z.y += z.vy*dt;

        z.x = clamp(z.x, arena.x0-12, arena.x1+12);
        z.y = clamp(z.y, arena.y0-12, arena.y1+12);

        if(dist2(z.x,z.y,player.x,player.y) < (10*10)){
          hurtPlayer(z.elite ? 12 : 8);
        }
      }

      // boss update (3 types)
      if(boss){
        boss.t += 1;

        if(boss.slow > 0) boss.slow = Math.max(0, boss.slow - dt);
        const slowMul = boss.slow > 0 ? 0.62 : 1.0;

        const a = Math.atan2(player.y - boss.y, player.x - boss.x);
        const hpP = boss.hp / boss.maxHp;

        // Kind behaviors:
        // 0: Bruiser (charges more)
        // 1: Warper (side-step drift)
        // 2: Siren (summons + pulse hit)
        const drift = (boss.kind===1) ? (Math.sin(boss.t*0.05)*12) : (Math.sin(boss.t*0.04)*7);
        const spdBoost = hpP < 0.6 ? 1.25 : 1.0;

        boss.x += (Math.cos(a)*boss.spd*spdBoost*slowMul + drift)*dt;
        boss.y += (Math.sin(a)*boss.spd*spdBoost*slowMul - drift)*dt;

        boss.x = clamp(boss.x, arena.x0+18, arena.x1-18);
        boss.y = clamp(boss.y, arena.y0+20, arena.y1-18);

        boss.atkCD -= dt;
        if(boss.atkCD <= 0){
          // attack cadence differs by kind
          boss.atkCD = (boss.kind===0) ? (hpP < 0.5 ? 0.85 : 1.05)
                     : (boss.kind===1) ? (hpP < 0.5 ? 0.95 : 1.15)
                     : (hpP < 0.5 ? 0.90 : 1.10);

          // FX
          particles(boss.x,boss.y,52,2.0,90,0.55,
            boss.kind===2 ? "#00ffd5" : "#ff3b6b",
            boss.kind===1 ? "#b300ff" : "#00ffd5"
          );
          shake = Math.max(shake, 8);

          const d = Math.sqrt(dist2(boss.x,boss.y,player.x,player.y));

          // Kind effects
          if(boss.kind===0){
            // Bruiser: heavier close hit
            if(d < 40) hurtPlayer(hpP < 0.5 ? 20 : 15);
            for(let k=0;k<(hpP<0.5?3:2);k++) spawnZombie(Math.random()<0.30);
          } else if(boss.kind===1){
            // Warper: mid-range chip + more elites
            if(d < 54) hurtPlayer(hpP < 0.5 ? 14 : 11);
            for(let k=0;k<(hpP<0.5?2:2);k++) spawnZombie(Math.random()<0.45);
          } else {
            // Siren: pulse wave slows you + summons
            if(d < 70){
              hurtPlayer(hpP < 0.5 ? 12 : 10);
              // mini slow on player (implemented as small invuln reduction, feels like “drag”)
              player.dashCD = Math.max(player.dashCD, 0.35);
            }
            for(let k=0;k<(hpP<0.5?4:3);k++) spawnZombie(Math.random()<0.28);
          }
        }

        if(dist2(boss.x,boss.y,player.x,player.y) < (22*22)){
          hurtPlayer(16);
        }

        if(boss.hp <= 0){
          player.score += 900;
          player.cash += 340;
          particles(boss.x,boss.y,140,2.6,130,1.05,"#b300ff","#00ffd5");
          shake = 10;
          boss = null;
          bossesDefeated++;

          // after boss: rest with auto-shop
          wave.phase = "REST";
          wave.timer = 1.2;
          wave.shopPhase = "OPEN";
          wave.restLock = 0.35;
          spawnCrates();
          shopOpen = true;
        }
      }

      // score drip (tiny)
      player.score += dt * (4 + wave.n*0.22);

      // death
      if(player.hp <= 0){
        state = STATE.DEAD;
        if(player.score > highScore){
          highScore = Math.floor(player.score);
          localStorage.setItem(HS_KEY, String(highScore));
        }
      }

      pressed.clear();
      return;
    }
  }

  // ======== Render ========
  function render(){
    const sx = shake>0 ? randi(-shake, shake) : 0;
    const sy = shake>0 ? randi(-shake, shake) : 0;
    shake = Math.max(0, shake - 0.35);

    updateCamera();
    drawArenaBackdrop();

    g.save();
    g.translate(sx, sy);

    // ===== BUNKER (better cover / start screen) =====
    if(state === STATE.BUNKER){
      // dark poster base
      g.fillStyle = "#050214";
      g.fillRect(0,0,W,H);

      // static “cover” panels (no flicker)
      g.fillStyle = "rgba(179,0,255,0.18)";
      g.fillRect(0,0,W,54);
      g.fillStyle = "rgba(0,255,213,0.10)";
      g.fillRect(0,54,W,10);

      // subtle diagonal texture
      g.fillStyle = "rgba(255,255,255,0.03)";
      for(let i=-H;i<W;i+=10){
        g.fillRect(i, 0, 3, H);
      }

      // title block
      drawText("CLUB DECAY", 18, 20, 2.2, "#e8e8ff");
      drawText("CHIMP VS ZOMBIES", 18, 38, 1.25, "rgba(0,255,213,0.92)");
      drawText("BUNKER LOADOUT", 18, 56, 1.0, "rgba(232,232,255,0.78)");
      drawText("W/S or ↑/↓ select · ENTER toggle · SPACE deploy", 18, 70, 0.95, "rgba(232,232,255,0.62)");
      drawText("SHIFT dash · Q pulse · P pause", 18, 82, 0.95, "rgba(232,232,255,0.56)");

      // list
      const startY = 100;
      for(let i=0;i<WEAPONS.length;i++){
        const w = WEAPONS[i];
        const y = startY + i*12;
        if(y > H-22) break;

        const picked = bunkerPicked.includes(w.id);
        const cur = (i===bunkerCursor);

        if(cur){
          g.fillStyle = "rgba(0,255,213,0.10)";
          g.fillRect(12, y-9, W-24, 11);
          g.fillStyle = "rgba(179,0,255,0.15)";
          g.fillRect(12, y-9, 6, 11);
        }

        g.fillStyle = picked ? "rgba(0,255,213,0.16)" : "rgba(255,255,255,0.05)";
        g.fillRect(16, y-8, 10, 10);
        if(picked){
          g.fillStyle = "#00ffd5";
          g.fillRect(18, y-6, 6, 2);
          g.fillRect(22, y-4, 2, 4);
        }

        drawText(w.name.toUpperCase(), 34, y, 1.0, w.color);
        const meta = w.melee ? `MELEE dmg:${w.dmg}` : `dmg:${w.dmg} rate:${w.fireRate.toFixed(1)}`;
        drawText(meta, 182, y, 0.85, "rgba(232,232,255,0.55)");
      }

      // slots bar
      g.fillStyle = "rgba(0,0,0,0.35)";
      g.fillRect(0,H-18,W,18);
      drawText("SLOTS:", 18, H-6, 0.95, "rgba(232,232,255,0.82)");
      for(let i=0;i<3;i++){
        const id = bunkerPicked[i];
        g.fillStyle = "rgba(255,255,255,0.06)";
        g.fillRect(70+i*82, H-16, 76, 12);
        if(id){
          const w = byId[id];
          g.fillStyle = w.color;
          g.fillRect(72+i*82, H-14, 8, 8);
          drawText(`${i+1}:${w.name}`, 84+i*82, H-6, 0.85, "#e8e8ff");
        } else {
          drawText(`${i+1}: -`, 84+i*82, H-6, 0.85, "rgba(232,232,255,0.4)");
        }
      }

      g.restore();
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(world, 0, 0, W, H, 0, 0, canvas.width, canvas.height);
      return;
    }

    // ===== PLAY / DEAD =====
    const ox = camera.x, oy = camera.y;

    // dash trails (subtle, stable)
    for(const t of trails){
      const x = Math.floor(t.x - ox), y = Math.floor(t.y - oy);
      if(x<-10||x>W+10||y<-10||y>H+10) continue;
      g.fillStyle = `rgba(179,0,255,${0.18*(t.life/0.22)})`;
      g.fillRect(x-4,y-4,8,8);
      g.fillStyle = `rgba(0,255,213,${0.14*(t.life/0.22)})`;
      g.fillRect(x-2,y-2,4,4);
    }

    // crates
    for(const c of crates){
      const x = Math.floor(c.x - ox), y = Math.floor(c.y - oy);
      if(x<-10||x>W+10||y<-10||y>H+10) continue;
      g.fillStyle = c.open ? "rgba(255,255,255,0.08)" : "rgba(179,0,255,0.18)";
      g.fillRect(x-5,y-5,10,10);
      g.fillStyle = c.open ? "rgba(0,0,0,0.45)" : "rgba(0,255,213,0.22)";
      g.fillRect(x-3,y-3,6,6);
    }

    // bullets
    for(const b of bullets){
      const sxp = Math.floor(b.x - ox);
      const syp = Math.floor(b.y - oy);
      if(sxp<-3 || sxp>W+3 || syp<-3 || syp>H+3) continue;
      g.fillStyle = b.col;
      g.fillRect(sxp-1, syp-1, 3, 3);
      g.fillStyle = "rgba(255,255,255,0.18)";
      g.fillRect(sxp, syp, 1, 1);
    }

    // zombies
    for(const z of zombies){
      const sxz = z.x - ox, syz = z.y - oy;
      if(sxz<-24 || sxz>W+24 || syz<-24 || syz>H+24) continue;
      drawZombie({ ...z, x:sxz, y:syz });
    }

    // boss
    if(boss){
      drawBoss({ ...boss, x:boss.x-ox, y:boss.y-oy });
    }

    // player
    const aimWorldX = camera.x + mouse.x;
    const aimWorldY = camera.y + mouse.y;
    const aimAng = Math.atan2(aimWorldY-player.y, aimWorldX-player.x);
    const blink = player.invuln>0 && (Math.floor(performance.now()/70)%2===0);
    if(!blink) drawChimp(player.x-ox, player.y-oy, player.dir, player.frame, aimAng);

    // sparks
    for(const p of sparks){
      const spx = Math.floor(p.x - ox);
      const spy = Math.floor(p.y - oy);
      if(spx<0||spx>=W||spy<0||spy>=H) continue;
      g.fillStyle = p.col;
      g.fillRect(spx, spy, 1, 1);
    }
    // floats
    for(const f of floats){
      const fx = Math.floor(f.x - ox);
      const fy = Math.floor(f.y - oy);
      if(fx<-40||fx>W+40||fy<-20||fy>H+20) continue;
      drawText(f.text, fx, fy, 1.0, f.col);
    }

    // ===== HUD =====
    // top bar
    g.fillStyle = "rgba(0,0,0,0.52)";
    g.fillRect(0,0,W,30);
    g.fillStyle = "rgba(179,0,255,0.12)";
    g.fillRect(0,28,W,2);

    drawText(`SCORE ${Math.floor(player.score)}`, 8, 12, 1.0, "#e8e8ff");
    drawText(`CASH ${Math.floor(player.cash)}$`, 110, 12, 1.0, "rgba(0,255,213,0.90)");
    drawText(`HI ${highScore}`, 232, 12, 1.0, "rgba(232,232,255,0.70)");
    drawText(`WAVE ${wave.n} ${wave.phase==="REST"?"(REST)":wave.phase==="FIGHT"?"(FIGHT)":"(CLEAR)"}`, 8, 24, 0.9, "rgba(232,232,255,0.70)");
    drawText(`DASH ${player.dashCD>0?player.dashCD.toFixed(1):"OK"}`, 214, 24, 0.9, "rgba(232,232,255,0.62)");
    drawText(`Q ${player.pulseCD>0?player.pulseCD.toFixed(0):"READY"}`, 276, 24, 0.9, "rgba(232,232,255,0.62)");

    // HP bar
    const hpP = clamp(player.hp/100, 0, 1);
    g.fillStyle = "rgba(255,255,255,0.10)";
    g.fillRect(8, 34, 170, 10);
    g.fillStyle = hpP>0.4 ? "#7CFF6B" : "#ff3b6b";
    g.fillRect(8, 34, 170*hpP, 10);
    g.strokeStyle = "rgba(255,255,255,0.16)";
    g.strokeRect(8, 34, 170, 10);
    drawText(`HP`, 184, 43, 0.9, "rgba(232,232,255,0.78)");

    // Boss bar
    if(boss){
      const bp = clamp(boss.hp/boss.maxHp, 0, 1);
      g.fillStyle = "rgba(0,0,0,0.50)";
      g.fillRect(8, 48, 304, 10);
      g.fillStyle = (boss.kind===0) ? "#ff3b6b" : (boss.kind===1 ? "#b300ff" : "#00ffd5");
      g.fillRect(8, 48, 304*bp, 10);
      g.strokeStyle = "rgba(255,255,255,0.16)";
      g.strokeRect(8, 48, 304, 10);
      const bname = (boss.kind===0) ? "BOSS I" : (boss.kind===1 ? "BOSS II" : "BOSS III");
      drawText(bname, 264, 56, 0.9, "#e8e8ff");
    }

    // minimap
    const mmW = 84, mmH = 48;
    const mmX = W - mmW - 8;
    const mmY = 34;
    g.fillStyle = "rgba(0,0,0,0.42)";
    g.fillRect(mmX, mmY, mmW, mmH);
    g.strokeStyle = "rgba(179,0,255,0.26)";
    g.strokeRect(mmX, mmY, mmW, mmH);

    const sxm = mmW / MAP_W;
    const sym = mmH / MAP_H;

    g.strokeStyle = "rgba(0,255,213,0.22)";
    g.strokeRect(mmX + arena.x0*sxm, mmY + arena.y0*sym, (arena.x1-arena.x0)*sxm, (arena.y1-arena.y0)*sym);

    g.fillStyle = "#e8e8ff";
    g.fillRect(Math.floor(mmX + player.x*sxm)-1, Math.floor(mmY + player.y*sym)-1, 3, 3);

    let shown = 0;
    for(const z of zombies){
      if(shown++ > 55) break;
      g.fillStyle = z.elite ? "rgba(35,255,134,0.85)" : "rgba(90,167,255,0.75)";
      g.fillRect(Math.floor(mmX + z.x*sxm), Math.floor(mmY + z.y*sym), 1, 1);
    }
    if(boss){
      g.fillStyle = "rgba(255,59,107,0.90)";
      g.fillRect(Math.floor(mmX + boss.x*sxm)-1, Math.floor(mmY + boss.y*sym)-1, 3, 3);
    }

    // weapon slots
    const y = H-16;
    for(let i=0;i<3;i++){
      const id = player.selected[i];
      g.fillStyle = "rgba(255,255,255,0.07)";
      g.fillRect(8+i*104, y, 96, 12);
      if(id){
        const w = byId[id];
        g.fillStyle = (i===player.slot) ? "rgba(179,0,255,0.34)" : "rgba(0,0,0,0.25)";
        g.fillRect(8+i*104, y, 96, 12);
        g.fillStyle = w.color;
        g.fillRect(10+i*104, y+2, 8, 8);
        drawText(`${i+1}:${w.name}`, 22+i*104, y+10, 0.9, "#e8e8ff");
      } else {
        drawText(`${i+1}: -`, 22+i*104, y+10, 0.9, "rgba(232,232,255,0.4)");
      }
    }

    // REST hint (and boss schedule)
    if(wave.phase === "REST"){
      g.fillStyle = "rgba(0,0,0,0.55)";
      g.fillRect(50, 64, 220, 46);
      drawText("REST ROUND", 112, 80, 1.3, "#00ffd5");
      drawText("Shop is open. ESC to close.", 76, 96, 1.0, "rgba(232,232,255,0.78)");
      drawText("Open crates: E · Start wave: C", 70, 108, 1.0, "rgba(232,232,255,0.72)");
      const nxtBoss = bossesDefeated>=3 ? "NO MORE BOSSES" : `BOSS AT WAVE ${[5,10,15][bossesDefeated]}`;
      drawText(nxtBoss, 96, 120, 0.95, "rgba(232,232,255,0.55)");
    }

    // SHOP overlay
    if(shopOpen){
      g.fillStyle = "rgba(0,0,0,0.78)";
      g.fillRect(0,0,W,H);
      drawText("SHOP (BETWEEN WAVES)", 52, 30, 1.6, "#00ffd5");
      drawText(`CASH ${Math.floor(player.cash)}$`, 118, 48, 1.1, "rgba(232,232,255,0.9)");
      drawText("W/S or ↑/↓ select · E/ENTER buy · ESC close", 16, 64, 1.0, "rgba(232,232,255,0.72)");

      const startY = 84;
      for(let i=0;i<SHOP_EXCLUSIVE.length;i++){
        const id = SHOP_EXCLUSIVE[i];
        const w = byId[id];
        const yy = startY + i*12;
        const cur = (i===shopCursor);
        const owned = player.selected.includes(id);
        const afford = canBuy(id);

        if(cur){
          g.fillStyle = "rgba(179,0,255,0.20)";
          g.fillRect(16, yy-9, W-32, 11);
        }
        g.fillStyle = "rgba(255,255,255,0.06)";
        g.fillRect(20, yy-8, 10, 10);

        g.fillStyle = w.color;
        g.fillRect(22, yy-6, 6, 6);

        drawText(w.name.toUpperCase(), 36, yy, 1.0, w.color);
        drawText(`${w.price}$`, 200, yy, 1.0, "rgba(232,232,255,0.80)");

        const tag = owned ? "OWNED" : (afford ? "BUY" : "LOCKED");
        const col = owned ? "rgba(232,232,255,0.5)" : (afford ? "#7CFF6B" : "#ff3b6b");
        drawText(tag, 252, yy, 1.0, col);
      }
    }

    // DEAD overlay
    if(state === STATE.DEAD){
      g.fillStyle = "rgba(0,0,0,0.70)";
      g.fillRect(0,0,W,H);
      drawText("YOU GOT ERASED.", 86, 64, 1.9, "#ff3b6b");
      drawText(`SCORE ${Math.floor(player.score)} | WAVE ${wave.n}`, 84, 88, 1.1, "#e8e8ff");
      drawText(`HIGH SCORE ${highScore}`, 104, 106, 1.1, "#00ffd5");
      drawText(`BOSSES DOWN ${bossesDefeated}/3`, 98, 120, 1.0, "rgba(232,232,255,0.72)");
      drawText("ENTER retry | ESC bunker", 86, 142, 1.0, "rgba(232,232,255,0.80)");
    }

    // PAUSED overlay
    if(paused){
      g.fillStyle = "rgba(0,0,0,0.62)";
      g.fillRect(0,0,W,H);
      drawText("PAUSED", 132, 88, 1.8, "#e8e8ff");
      drawText("Press P to resume", 104, 108, 1.0, "rgba(232,232,255,0.75)");
    }

    g.restore();
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(world, 0, 0, W, H, 0, 0, canvas.width, canvas.height);
  }

  // ======== Loop ========
  function loop(now){
    const dt = Math.min(0.05, (now - last)/1000);
    last = now;
    acc += dt;
    while(acc >= DT){
      update(DT);
      acc -= DT;
    }
    render();
    requestAnimationFrame(loop);
  }

  // Start
  resetRun();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>


