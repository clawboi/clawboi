<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>MYSTERY</title>
<style>
:root{
  --bg:#000;
  --fg:#fff;
  --violet:#8a2eff;
  --glass: rgba(255,255,255,.06);
  --glass2: rgba(138,46,255,.12);
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  background:var(--bg);
  color:var(--fg);
  font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  overflow:hidden;
}

/* soft violet fog */
body:before{
  content:"";
  position:fixed;
  inset:-30%;
  pointer-events:none;
  z-index:0;
  background:
    radial-gradient(circle at 20% 20%, rgba(138,46,255,.22), transparent 60%),
    radial-gradient(circle at 80% 30%, rgba(138,46,255,.12), transparent 70%),
    radial-gradient(circle at 48% 88%, rgba(138,46,255,.10), transparent 72%),
    radial-gradient(circle at 60% 60%, rgba(255,255,255,.03), transparent 72%);
  mix-blend-mode:screen;
  filter:blur(44px) saturate(1.2);
  animation:fog 18s ease-in-out infinite;
}
@keyframes fog{
  0%,100%{transform:translate(0,0) scale(1)}
  50%{transform:translate(-2.5%,3.5%) scale(1.02)}
}

/* scanlines */
.scan{
  position:fixed; inset:0;
  pointer-events:none;
  z-index:6;
  opacity:.08;
  mix-blend-mode:overlay;
  background:repeating-linear-gradient(to bottom,
    rgba(255,255,255,.06) 0px, rgba(255,255,255,.06) 1px, transparent 3px, transparent 6px);
}

/* canvas */
#c{
  position:fixed;
  inset:0;
  width:100%;
  height:100%;
  z-index:1;
  image-rendering:pixelated;
}

/* reactive aura layer */
#aura{
  position:fixed;
  inset:0;
  z-index:2;
  pointer-events:none;
  opacity:.0;
  background:
    radial-gradient(circle at 50% 50%, rgba(138,46,255,.26), transparent 55%),
    radial-gradient(circle at 25% 70%, rgba(138,46,255,.16), transparent 60%),
    radial-gradient(circle at 80% 30%, rgba(255,255,255,.06), transparent 70%);
  mix-blend-mode:screen;
  filter:blur(26px);
  transition:opacity .12s linear;
}

/* brand + back */
.brand{
  position:fixed; top:14px; left:14px;
  z-index:12;
  font-size:11px;
  letter-spacing:.34em;
  text-transform:uppercase;
  opacity:.78;
  text-shadow:0 0 18px rgba(138,46,255,.35);
}
.brand a{color:#fff;text-decoration:none}

.back{
  position:fixed;
  right:16px;
  top:16px;
  z-index:12;
  font-size:10px;
  letter-spacing:.32em;
  text-transform:uppercase;
  opacity:.65;
}
.back a{color:#fff;text-decoration:none}
.back a:hover{opacity:1}

/* realm HUD */
.hud{
  position:fixed;
  left:50%;
  top:54px;
  transform:translateX(-50%);
  z-index:12;
  text-align:center;
  pointer-events:none;
}
.realm{
  font-size:12px;
  letter-spacing:.46em;
  text-transform:uppercase;
  text-shadow:0 0 18px rgba(138,46,255,.45), 0 0 60px rgba(138,46,255,.18);
  opacity:.92;
}
.tip{
  margin-top:8px;
  font-size:10px;
  letter-spacing:.28em;
  text-transform:uppercase;
  opacity:.55;
}

/* controls bottom right */
.controls{
  position:fixed;
  right:14px;
  bottom:14px;
  z-index:12;
  display:flex;
  gap:10px;
  align-items:center;
}
.btn{
  border:0;
  cursor:pointer;
  padding:10px 12px;
  border-radius:999px;
  background:var(--glass);
  color:#fff;
  letter-spacing:.26em;
  font-size:10px;
  text-transform:uppercase;
  backdrop-filter:blur(10px);
}
.btn:hover{background:rgba(138,46,255,.14)}
.btn:active{transform:translateY(1px)}
.pill{
  padding:10px 12px;
  border-radius:999px;
  background:rgba(138,46,255,.10);
  letter-spacing:.26em;
  font-size:10px;
  text-transform:uppercase;
  opacity:.75;
}

/* audio dock bottom left */
.audioDock{
  position:fixed;
  left:14px;
  bottom:14px;
  z-index:12;
  display:flex;
  align-items:center;
  gap:10px;
  padding:10px 12px;
  border-radius:999px;
  background:rgba(0,0,0,.35);
  border:1px solid rgba(255,255,255,.08);
  backdrop-filter: blur(12px);
}
.audioDock .label{
  font-size:10px;
  letter-spacing:.28em;
  text-transform:uppercase;
  opacity:.8;
}
.slider{
  width:110px;
  accent-color: var(--violet);
}
.miniBtn{
  border:0;
  cursor:pointer;
  padding:8px 10px;
  border-radius:999px;
  background:rgba(255,255,255,.06);
  color:#fff;
  font-size:10px;
  letter-spacing:.22em;
  text-transform:uppercase;
}
.miniBtn:hover{background:rgba(138,46,255,.14)}
.track{
  border:1px solid rgba(255,255,255,.10);
  background:rgba(255,255,255,.04);
  color:#fff;
  border-radius:999px;
  padding:8px 10px;
  font-size:10px;
  letter-spacing:.18em;
  text-transform:uppercase;
}

/* whisper */
.whisper{
  position:fixed;
  left:50%;
  bottom:70px;
  transform:translateX(-50%);
  z-index:12;
  font-size:10px;
  letter-spacing:.32em;
  text-transform:uppercase;
  opacity:0;
  pointer-events:none;
  transition:opacity .12s linear, transform .12s linear;
  text-shadow:0 0 18px rgba(138,46,255,.30);
}
.whisper.on{opacity:.78; transform:translateX(-50%) translateY(-2px)}

/* flash */
.flash{
  position:fixed; inset:0;
  background:#fff;
  opacity:0;
  pointer-events:none;
  z-index:11;
}
.flash.active{animation:flash .14s}
@keyframes flash{
  0%{opacity:0}
  50%{opacity:.28}
  100%{opacity:0}
}

/* START OVERLAY for iOS audio unlock */
.overlay{
  position:fixed;
  inset:0;
  z-index:50;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:24px;
  background: radial-gradient(circle at 50% 50%, rgba(138,46,255,.16), rgba(0,0,0,.92) 60%);
  backdrop-filter: blur(10px);
}
.card{
  width:min(560px, 100%);
  border-radius:22px;
  padding:18px 18px 16px;
  border:1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.45);
  box-shadow: 0 0 80px rgba(138,46,255,.20);
}
.card h1{
  margin:0;
  font-size:12px;
  letter-spacing:.48em;
  text-transform:uppercase;
  opacity:.92;
}
.card p{
  margin:12px 0 14px;
  font-size:11px;
  letter-spacing:.18em;
  line-height:1.6;
  opacity:.72;
  text-transform:uppercase;
}
.bigBtn{
  width:100%;
  border:0;
  cursor:pointer;
  padding:14px 16px;
  border-radius:999px;
  background: rgba(138,46,255,.18);
  color:#fff;
  font-size:11px;
  letter-spacing:.36em;
  text-transform:uppercase;
  backdrop-filter: blur(10px);
}
.bigBtn:hover{background: rgba(138,46,255,.26)}
.smallRow{
  display:flex;
  gap:10px;
  margin-top:10px;
}
.smallRow button{
  flex:1;
  border:1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.04);
  color:#fff;
  border-radius:999px;
  padding:10px 12px;
  font-size:10px;
  letter-spacing:.24em;
  text-transform:uppercase;
  cursor:pointer;
}
.smallRow button:hover{background: rgba(255,255,255,.07)}
.note{
  margin-top:10px;
  font-size:10px;
  letter-spacing:.18em;
  opacity:.55;
  text-transform:uppercase;
}

@media (prefers-reduced-motion: reduce){
  body:before{animation:none!important}
}
</style>
</head>

<body>
<canvas id="c"></canvas>
<div id="aura"></div>

<div class="scan"></div>
<div class="flash" id="flash"></div>
<div class="whisper" id="whisper">TOUCH THE VOID</div>

<div class="brand"><a href="index.html">CLAWBOI</a></div>
<div class="back"><a href="secret.html">RETURN TO TRANSMISSION</a></div>

<div class="hud">
  <div class="realm" id="realmName">GRAVITY DROP</div>
  <div class="tip" id="realmTip">TAP / SPACE = SPAWN • HOLD = CHARGE • NEXT = NEW REALM</div>
</div>

<div class="controls">
  <span class="pill" id="realmIdx">01/05</span>
  <button class="btn" id="prevBtn">◀ PREV</button>
  <button class="btn" id="nextBtn">NEXT ▶</button>
</div>

<div class="audioDock">
  <span class="label" id="trackLabel">TRACK</span>
  <select class="track" id="trackSelect" aria-label="Track select">
    <option value="audio/mansion.mp3">MANSION</option>
    <option value="audio/zahh.mp3">ZAHH</option>
    <option value="audio/body-count.mp3">BODY COUNT</option>
    <option value="audio/n0-water.mp3">N0 WATER</option>
    <option value="audio/rant.mp3">RANT</option>
  </select>
  <button class="miniBtn" id="playBtn">PLAY</button>
  <input class="slider" id="vol" type="range" min="0" max="1" step="0.01" value="0.72" />
</div>

<!-- iOS-friendly start gate -->
<div class="overlay" id="startOverlay">
  <div class="card">
    <h1>MYSTERY REALM HOPPER</h1>
    <p>ONE TAP TO OPEN THE GATE. AUDIO UNLOCKS. REALMS WAKE UP. YOU BECOME THE INPUT.</p>
    <button class="bigBtn" id="startBtn">START / UNMUTE</button>
    <div class="smallRow">
      <button id="startSilent">START SILENT</button>
      <button id="startAuto">AUTO PLAY</button>
    </div>
    <div class="note">IPHONE REQUIRES A TAP BEFORE MUSIC CAN PLAY.</div>
  </div>
</div>

<script>
/* =======================
   MYSTERY: REALM HOPPER (LEGENDARY)
   - iOS-safe audio unlock
   - MP3 player + track select
   - audio-reactive glow
   - your original realms preserved
======================= */

const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d", { alpha: true });
const aura = document.getElementById("aura");

const flash = document.getElementById("flash");
const whisper = document.getElementById("whisper");

const realmNameEl = document.getElementById("realmName");
const realmTipEl  = document.getElementById("realmTip");
const realmIdxEl  = document.getElementById("realmIdx");

const prevBtn = document.getElementById("prevBtn");
const nextBtn = document.getElementById("nextBtn");

const startOverlay = document.getElementById("startOverlay");
const startBtn = document.getElementById("startBtn");
const startSilent = document.getElementById("startSilent");
const startAuto = document.getElementById("startAuto");

const trackSelect = document.getElementById("trackSelect");
const playBtn = document.getElementById("playBtn");
const vol = document.getElementById("vol");

const clamp = (n,a,b)=> Math.max(a, Math.min(b,n));
const rand  = (a,b)=> a + Math.random()*(b-a);
const rint  = (a,b)=> Math.floor(rand(a,b+1));
const pick  = (arr)=> arr[Math.floor(Math.random()*arr.length)];

let W=innerWidth, H=innerHeight, dpr=1;
function resize(){
  dpr = Math.min(2, window.devicePixelRatio||1);
  W = innerWidth; H = innerHeight;
  canvas.width = Math.floor(W*dpr);
  canvas.height= Math.floor(H*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener("resize", resize);
resize();

/* ====== AUDIO (MP3) + ANALYSER ====== */
let audioOn = false;
let audio = new Audio();
audio.loop = true;
audio.preload = "auto";
audio.crossOrigin = "anonymous";
audio.src = trackSelect.value;

let ac=null, srcNode=null, analyser=null, data=null, master=null;

function ensureAudioGraph(){
  if(ac) return;
  ac = new (window.AudioContext||window.webkitAudioContext)();
  master = ac.createGain();
  master.gain.value = parseFloat(vol.value);
  master.connect(ac.destination);

  analyser = ac.createAnalyser();
  analyser.fftSize = 1024;
  data = new Uint8Array(analyser.frequencyBinCount);

  srcNode = ac.createMediaElementSource(audio);
  srcNode.connect(analyser);
  analyser.connect(master);
}

async function unlockAndPlay(){
  try{
    ensureAudioGraph();
    await ac.resume?.();
    await audio.play();
    audioOn = true;
    playBtn.textContent = "PAUSE";
  }catch(e){
    // If blocked, user can tap again
    console.log("Audio play blocked:", e);
  }
}

function pauseAudio(){
  audio.pause();
  playBtn.textContent = "PLAY";
}

function toggleAudio(){
  if(!audioOn || audio.paused) unlockAndPlay();
  else { pauseAudio(); }
}

vol.addEventListener("input", ()=>{
  const v = parseFloat(vol.value);
  audio.volume = 1; // keep media element full, control via gain
  if(master) master.gain.value = v;
});

trackSelect.addEventListener("change", async ()=>{
  const wasPlaying = audioOn && !audio.paused;
  audio.src = trackSelect.value;
  audio.load();
  say("TRACK SHIFT", 220);
  if(wasPlaying){
    await unlockAndPlay();
  }
});

playBtn.addEventListener("click", toggleAudio);

/* ====== UI effects ====== */
function doFlash(){
  flash.classList.add("active");
  setTimeout(()=>flash.classList.remove("active"),120);
}
function say(msg, ms=320){
  whisper.textContent = msg;
  whisper.classList.add("on");
  clearTimeout(say._t);
  say._t = setTimeout(()=>whisper.classList.remove("on"), ms);
}

/* ====== Stars ====== */
const stars = [];
function initStars(){
  stars.length=0;
  const n = Math.floor((W*H)/12000);
  for(let i=0;i<n;i++){
    stars.push({x:Math.random()*W, y:Math.random()*H, r:Math.random()*1.6+0.2, a:Math.random()*0.6+0.08, s:Math.random()*0.18+0.02});
  }
}
initStars();

function drawStars(speed=1){
  for(const s of stars){
    s.y += s.s*speed;
    if(s.y>H+4){ s.y=-4; s.x=Math.random()*W; }
    ctx.fillStyle = `rgba(255,255,255,${s.a})`;
    ctx.fillRect(s.x, s.y, s.r, s.r);
  }
}

/* ====== Audio reactive energy ====== */
let energy = 0;
function updateEnergy(){
  if(!audioOn || !analyser) { energy *= 0.92; return; }
  analyser.getByteFrequencyData(data);
  // sample low-mid bands for "pulse"
  let sum=0, n=0;
  for(let i=6;i<60;i++){ sum += data[i]; n++; }
  const avg = (sum/(n||1))/255; // 0..1
  energy = energy*0.82 + avg*0.18;
  aura.style.opacity = String(clamp(energy*1.35, 0, 0.85));
}

/* =======================
   REALMS (your originals)
======================= */
let realmIndex = 0;

const realms = [
  {
    name:"GRAVITY DROP",
    tip:"TAP / SPACE = SPAWN • HOLD = HEAVY DROP • DRAG = PUSH",
    init(){
      balls.length=0;
      wind = 0;
      say("DROP SOMETHING");
    },
    action(x,y,charged){
      spawnBall(x,y, charged ? 22 : 12, charged ? 1.35 : 1.0);
      blip(charged?0.16:0.10);
    },
    update(dt){
      ctx.fillStyle = "rgba(0,0,0,0.22)";
      ctx.fillRect(0,0,W,H);

      drawStars(1.2);

      ctx.fillStyle = `rgba(138,46,255,${0.06 + energy*0.10})`;
      ctx.fillRect(0, H-60, W, 60);

      stepBalls(dt);
      drawBalls();
    }
  },
  {
    name:"RAIN ROOM",
    tip:"TAP = THUNDER • HOLD = FLOOD • SPACE = SPLASH",
    init(){
      drops.length=0; ripples.length=0;
      rainRate = 520;
      flood = 0;
      say("LET IT POUR");
    },
    action(x,y,charged){
      if(charged){
        flood = clamp(flood + 0.35, 0, 1.0);
        say("FLOOD RISING", 260);
        doFlash();
      }else{
        thunder(x,y);
      }
    },
    update(dt){
      ctx.fillStyle = "rgba(0,0,0,0.24)";
      ctx.fillRect(0,0,W,H);

      drawStars(0.9);

      const count = Math.floor((rainRate * (1+flood*0.8)) * dt);
      for(let i=0;i<count;i++){
        drops.push({
          x: Math.random()*W,
          y: -20,
          vx: rand(-30,30),
          vy: rand(680,980) * (1+flood*0.35),
          len: rand(10,22),
          a: rand(0.10,0.26)
        });
      }

      const waterH = 70 + flood*120;
      ctx.fillStyle = `rgba(138,46,255,${0.06 + energy*0.14})`;
      ctx.fillRect(0, H-waterH, W, waterH);

      for(let i=drops.length-1;i>=0;i--){
        const d = drops[i];
        d.x += d.vx*dt;
        d.y += d.vy*dt;
        ctx.strokeStyle = `rgba(255,255,255,${d.a})`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(d.x, d.y);
        ctx.lineTo(d.x - d.vx*0.02, d.y - d.len);
        ctx.stroke();

        if(d.y > H-waterH){
          ripples.push({x:d.x, y:H-waterH, r:1, a:0.45 + energy*0.25});
          drops.splice(i,1);
          if(ripples.length>160) ripples.splice(0, ripples.length-160);
        }
      }

      for(let i=ripples.length-1;i>=0;i--){
        const r = ripples[i];
        r.r += (90 + flood*80 + energy*90) * dt;
        r.a *= 0.965;
        if(r.a < 0.02){ ripples.splice(i,1); continue; }
        ctx.strokeStyle = `rgba(138,46,255,${r.a})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(r.x, r.y, r.r, 0, Math.PI*2);
        ctx.stroke();
      }
    }
  },
  {
    name:"FIREWORK TEMPLE",
    tip:"TAP = FIREWORK • HOLD = MEGA BLAST • SPACE = SPARK SHOWER",
    init(){
      sparks.length=0; rockets.length=0;
      say("LIGHT THE SKY");
    },
    action(x,y,charged){
      if(charged){
        megaFirework(x,y);
        doFlash();
      }else{
        launchRocket(x,y);
      }
    },
    update(dt){
      ctx.fillStyle = "rgba(0,0,0,0.22)";
      ctx.fillRect(0,0,W,H);

      drawStars(1.4);

      ctx.fillStyle = `rgba(138,46,255,${0.04 + energy*0.10})`;
      ctx.fillRect(0,H-110,W,110);

      stepFireworks(dt);
      drawFireworks();
    }
  },
  {
    name:"ORBIT CHAMBER",
    tip:"TAP = SPAWN ORBITER • HOLD = GRAVITY WELL • DRAG = SLINGSHOT",
    init(){
      orbs.length=0;
      wells.length=0;
      say("MAKE A SYSTEM");
    },
    action(x,y,charged){
      if(charged){
        wells.push({x,y, r: 10, a: 0.9, p: 1.0});
        say("GRAVITY WELL", 220);
        doFlash();
      }else{
        orbs.push(makeOrb(x,y));
      }
    },
    update(dt){
      ctx.fillStyle = "rgba(0,0,0,0.20)";
      ctx.fillRect(0,0,W,H);

      drawStars(0.8);

      for(let i=wells.length-1;i>=0;i--){
        const w = wells[i];
        w.r += 220*dt*(1+energy*0.7);
        w.a *= 0.975;
        w.p *= 0.985;
        if(w.a < 0.03){ wells.splice(i,1); continue; }
        ctx.strokeStyle = `rgba(138,46,255,${w.a})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(w.x, w.y, w.r, 0, Math.PI*2);
        ctx.stroke();
      }

      for(const o of orbs){
        o.vx *= 0.998; o.vy *= 0.998;

        for(const w of wells){
          const dx = w.x - o.x;
          const dy = w.y - o.y;
          const d2 = dx*dx + dy*dy + 40;
          const f = (5200 * w.p * (1+energy*0.8)) / d2;
          o.vx += dx * f * dt;
          o.vy += dy * f * dt;
        }

        o.x += o.vx*dt;
        o.y += o.vy*dt;

        if(o.x < -40) o.x=W+40;
        if(o.x > W+40) o.x=-40;
        if(o.y < -40) o.y=H+40;
        if(o.y > H+40) o.y=-40;

        o.phase += dt*(0.8+o.s*0.8);
      }

      for(const o of orbs){
        const pulse = 0.6 + 0.4*Math.sin(o.phase*3.2);
        ctx.beginPath();
        ctx.fillStyle = `rgba(138,46,255,${0.18 + pulse*0.20 + energy*0.20})`;
        ctx.arc(o.x, o.y, o.r*2.6, 0, Math.PI*2);
        ctx.fill();

        ctx.beginPath();
        ctx.fillStyle = `rgba(255,255,255,${0.40 + pulse*0.30 + energy*0.20})`;
        ctx.arc(o.x, o.y, o.r, 0, Math.PI*2);
        ctx.fill();
      }
    }
  },
  {
    name:"SHARD GARDEN",
    tip:"TAP = GROW CRYSTALS • HOLD = SHOCKWAVE • SPACE = BLOOM BURST",
    init(){
      shards.length=0; waves.length=0;
      say("PLANT LIGHT");
    },
    action(x,y,charged){
      if(charged){
        waves.push({x,y, r: 1, a: 0.55 + energy*0.25});
        doFlash();
        say("SHOCKWAVE", 220);
      }else{
        growShard(x,y);
      }
    },
    update(dt){
      ctx.fillStyle = "rgba(0,0,0,0.24)";
      ctx.fillRect(0,0,W,H);

      drawStars(1.0);

      for(let i=waves.length-1;i>=0;i--){
        const w = waves[i];
        w.r += 520*dt*(1+energy*0.8);
        w.a *= 0.965;
        if(w.a < 0.02){ waves.splice(i,1); continue; }
        ctx.strokeStyle = `rgba(138,46,255,${w.a})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(w.x,w.y,w.r,0,Math.PI*2);
        ctx.stroke();
      }

      for(const s of shards){
        s.t += dt;
        s.wob = Math.sin(s.t*2.4 + s.seed)*0.6;
      }
      drawShards();
    }
  }
];

function setRealm(idx){
  realmIndex = (idx + realms.length) % realms.length;
  realmNameEl.textContent = realms[realmIndex].name;
  realmTipEl.textContent  = realms[realmIndex].tip;
  realmIdxEl.textContent  = String(realmIndex+1).padStart(2,"0") + "/0" + realms.length;
  initStars();
  realms[realmIndex].init();
  say(pick(["REALM SHIFT","GATE OPEN","SIGNAL BENDS","NEW PHYSICS"]), 240);
}

/* ====== tiny synth SFX (kept, but soft) ====== */
function blip(g=0.10){
  // If WebAudio exists, we can add a tiny osc for clicks without fighting the MP3.
  if(!ac) return;
  const o=ac.createOscillator();
  const gn=ac.createGain();
  o.type="triangle"; o.frequency.value=rint(180,520);
  gn.gain.value=0.0001;
  o.connect(gn); gn.connect(master);
  const t=ac.currentTime;
  gn.gain.setValueAtTime(0.0001,t);
  gn.gain.exponentialRampToValueAtTime(g,t+0.01);
  gn.gain.exponentialRampToValueAtTime(0.0001,t+0.06);
  o.start(t); o.stop(t+0.09);
}

/* ====== REALM 1 physics balls ====== */
const balls = [];
let wind = 0;
function spawnBall(x,y, r=12, mass=1){
  balls.push({ x,y, vx: rand(-180,180), vy: rand(-120,60), r, m: mass, hue: rint(260,310), life: 0 });
  if(balls.length > 90) balls.splice(0, balls.length-90);
}
function stepBalls(dt){
  wind = wind*0.97 + rand(-12,12)*0.02;
  for(const b of balls){
    b.life += dt;
    b.vx += wind*dt;
    b.vy += 980*dt;
    b.x += b.vx*dt;
    b.y += b.vy*dt;

    if(b.x < b.r){ b.x=b.r; b.vx*=-0.82; }
    if(b.x > W-b.r){ b.x=W-b.r; b.vx*=-0.82; }

    const floor = H - 20;
    if(b.y > floor-b.r){
      b.y = floor-b.r;
      b.vy *= -0.78;
      b.vx *= 0.96;
    }
    if(b.y < b.r){ b.y=b.r; b.vy*=-0.7; }
  }

  for(let i=0;i<balls.length;i++){
    for(let j=i+1;j<balls.length;j++){
      const a=balls[i], b=balls[j];
      const dx=b.x-a.x, dy=b.y-a.y;
      const d=Math.hypot(dx,dy);
      const min=a.r+b.r;
      if(d>0 && d<min){
        const nx=dx/d, ny=dy/d;
        const push=(min-d)*0.55;
        a.x -= nx*push; a.y -= ny*push;
        b.x += nx*push; b.y += ny*push;
        const k = 240;
        a.vx -= nx*k*0.5; a.vy -= ny*k*0.5;
        b.vx += nx*k*0.5; b.vy += ny*k*0.5;
      }
    }
  }
}
function drawBalls(){
  for(const b of balls){
    ctx.beginPath();
    ctx.fillStyle = `hsla(${b.hue}, 100%, 60%, ${0.10 + energy*0.10})`;
    ctx.arc(b.x, b.y, b.r*2.8, 0, Math.PI*2);
    ctx.fill();

    ctx.beginPath();
    ctx.fillStyle = `hsla(${b.hue}, 100%, 72%, 0.72)`;
    ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
    ctx.fill();

    ctx.beginPath();
    ctx.fillStyle = `rgba(255,255,255,${0.30 + energy*0.25})`;
    ctx.arc(b.x - b.r*0.25, b.y - b.r*0.25, b.r*0.28, 0, Math.PI*2);
    ctx.fill();
  }
}

/* ====== REALM 2 rain ====== */
const drops = [];
const ripples = [];
let rainRate = 520;
let flood = 0;

function thunder(x,y){
  doFlash();
  say("THUNDER", 180);
  ctx.save();
  ctx.globalAlpha = 0.45 + energy*0.25;
  ctx.strokeStyle = "rgba(255,255,255,0.9)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  let lx = x, ly = 0;
  ctx.moveTo(lx, ly);
  const steps = 10;
  for(let i=0;i<steps;i++){
    lx += rand(-30,30);
    ly += H/(steps+2);
    ctx.lineTo(lx, ly);
  }
  ctx.stroke();
  ctx.restore();

  for(let i=0;i<8;i++){
    ripples.push({x:x+rand(-40,40), y:H-(70+flood*120), r:1, a:0.45 + energy*0.35});
  }
  if(ripples.length>160) ripples.splice(0, ripples.length-160);
}

/* ====== REALM 3 fireworks ====== */
const rockets = [];
const sparks = [];

function launchRocket(x,y){
  rockets.push({
    x, y: H + 30,
    vx: rand(-40,40),
    vy: -rand(820,1060),
    targetY: clamp(y, 90, H*0.72),
    hue: rint(260,315)
  });
  if(rockets.length>14) rockets.splice(0, rockets.length-14);
}

function explode(x,y,hue, power=1){
  const count = Math.floor(70*power);
  for(let i=0;i<count;i++){
    const a = Math.random()*Math.PI*2;
    const sp = rand(120, 520)*power*(1+energy*0.6);
    sparks.push({
      x,y,
      vx: Math.cos(a)*sp,
      vy: Math.sin(a)*sp,
      r: rand(1.2,2.6)*power,
      hue,
      a: rand(0.40,0.95),
      trail:false
    });
  }
  if(sparks.length>1400) sparks.splice(0, sparks.length-1400);
}

function megaFirework(x,y){
  const hue = rint(260,320);
  for(let i=0;i<4;i++){
    explode(x+rand(-40,40), y+rand(-40,40), hue + rint(-10,10), 1.25);
  }
}

function stepFireworks(dt){
  for(let i=rockets.length-1;i>=0;i--){
    const r = rockets[i];
    r.x += r.vx*dt;
    r.y += r.vy*dt;
    r.vy += 280*dt;

    if(Math.random()<0.65){
      sparks.push({
        x:r.x, y:r.y,
        vx: rand(-40,40),
        vy: rand(40,160),
        r: rand(0.8,1.6),
        hue:r.hue,
        a: rand(0.08,0.22),
        trail:true
      });
    }

    if(r.y <= r.targetY || r.vy > -40){
      explode(r.x, r.y, r.hue, 1.0);
      rockets.splice(i,1);
    }
  }

  for(let i=sparks.length-1;i>=0;i--){
    const s = sparks[i];
    s.x += s.vx*dt;
    s.y += s.vy*dt;
    s.vx *= 0.992;
    s.vy *= 0.992;
    s.vy += (s.trail?220:520)*dt;
    s.a *= s.trail ? 0.965 : 0.985;

    if(s.y > H+60 || s.a < 0.03) sparks.splice(i,1);
  }
}

function drawFireworks(){
  for(const r of rockets){
    ctx.beginPath();
    ctx.fillStyle = `hsla(${r.hue},100%,70%,0.85)`;
    ctx.arc(r.x,r.y,3,0,Math.PI*2);
    ctx.fill();
  }
  for(const s of sparks){
    ctx.beginPath();
    ctx.fillStyle = `hsla(${s.hue},100%,70%,${s.a})`;
    ctx.arc(s.x,s.y,s.r,0,Math.PI*2);
    ctx.fill();

    if(!s.trail){
      ctx.beginPath();
      ctx.fillStyle = `hsla(${s.hue},100%,60%,${s.a*0.10})`;
      ctx.arc(s.x,s.y,s.r*6,0,Math.PI*2);
      ctx.fill();
    }
  }
}

/* ====== REALM 4 orbit ====== */
const orbs = [];
const wells = [];
function makeOrb(x,y){
  const s = rand(0.4,1.2);
  return { x,y, vx: rand(-90,90), vy: rand(-90,90), r: rand(2.2,4.2), s, phase: rand(0,10) };
}

/* ====== REALM 5 shards ====== */
const shards = [];
const waves = [];
function growShard(x,y){
  const h = rint(260,320);
  const height = rand(18, 90);
  const w = rand(4, 14);
  shards.push({ x,y, h, height, w, t:0, seed: rand(0,999), tilt: rand(-0.5,0.5) });
  if(shards.length>120) shards.splice(0, shards.length-120);
}
function drawShards(){
  for(const s of shards){
    const sway = s.wob || 0;
    const tilt = s.tilt + sway*0.06;
    const topX = s.x + tilt*s.height;
    const topY = s.y - s.height;

    ctx.strokeStyle = `hsla(${s.h}, 100%, 60%, ${0.16 + energy*0.14})`;
    ctx.lineWidth = s.w*2.4;
    ctx.beginPath();
    ctx.moveTo(s.x, s.y);
    ctx.lineTo(topX, topY);
    ctx.stroke();

    ctx.strokeStyle = `hsla(${s.h}, 100%, 74%, 0.82)`;
    ctx.lineWidth = s.w;
    ctx.beginPath();
    ctx.moveTo(s.x, s.y);
    ctx.lineTo(topX, topY);
    ctx.stroke();

    ctx.beginPath();
    ctx.fillStyle = `rgba(255,255,255,${0.45 + energy*0.25})`;
    ctx.arc(topX, topY, 2.2, 0, Math.PI*2);
    ctx.fill();
  }
}

/* ====== INPUT ====== */
let pointerDown=false, downT=0, downX=0, downY=0;
let lastX=W/2, lastY=H/2;

function realmAction(x,y,charged){
  realms[realmIndex].action(x,y,charged);
}

addEventListener("pointermove", (e)=>{
  lastX=e.clientX; lastY=e.clientY;
  if(pointerDown && realms[realmIndex].name==="GRAVITY DROP"){
    const dx = e.clientX - downX;
    const dy = e.clientY - downY;
    if(Math.abs(dx)+Math.abs(dy) > 14){
      for(const b of balls){
        const d = Math.hypot(b.x-e.clientX, b.y-e.clientY);
        if(d < 120){
          b.vx += dx*0.22;
          b.vy += dy*0.12;
        }
      }
      downX = e.clientX; downY = e.clientY;
    }
  }
}, {passive:true});

addEventListener("pointerdown", (e)=>{
  pointerDown=true;
  downT=performance.now();
  downX=e.clientX; downY=e.clientY;
  lastX=downX; lastY=downY;
  say(pick(["TOUCH RECEIVED","SIGNAL FOUND","A NEW MOVE","DO IT AGAIN"]), 200);
}, {passive:true});

addEventListener("pointerup", (e)=>{
  if(!pointerDown) return;
  pointerDown=false;

  const ms = performance.now()-downT;
  const charged = ms > 520;
  realmAction(e.clientX, e.clientY, charged);
}, {passive:true});

addEventListener("keydown", (e)=>{
  const k = e.key;
  if(k === "ArrowRight"){ setRealm(realmIndex+1); return; }
  if(k === "ArrowLeft"){ setRealm(realmIndex-1); return; }

  if(k === " " || k === "Enter"){
    e.preventDefault();
    realmAction(lastX, lastY, false);
    return;
  }
  if(k.toLowerCase() === "b"){
    realmAction(lastX, lastY, true);
  }
}, {passive:false});

prevBtn.onclick = ()=> setRealm(realmIndex-1);
nextBtn.onclick = ()=> setRealm(realmIndex+1);

/* ====== LOOP ====== */
let lastT = performance.now();
function loop(t){
  const dt = clamp((t-lastT)/1000, 0, 0.033);
  lastT = t;

  updateEnergy();
  realms[realmIndex].update(dt);

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ====== START ====== */
function startWorld({withAudio}){
  startOverlay.style.display = "none";
  setRealm(0);
  say("TAP OR PRESS SPACE", 520);
  if(withAudio){
    unlockAndPlay();
  }else{
    ensureAudioGraph(); // create analyser for future, but don't play
  }
}

startBtn.onclick = ()=> startWorld({withAudio:true});
startAuto.onclick = ()=> startWorld({withAudio:true});
startSilent.onclick = ()=> startWorld({withAudio:false});

/* friendly: tap anywhere on overlay starts too */
startOverlay.addEventListener("click", (e)=>{
  if(e.target === startOverlay) startWorld({withAudio:true});
});
</script>
</body>
</html>
