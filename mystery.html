<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>MYSTERY</title>
<style>
:root{
  --bg:#000;
  --fg:#fff;
  --violet:#8a2eff;
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  background:var(--bg);
  color:var(--fg);
  font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  overflow:hidden;
}

/* soft violet fog */
body:before{
  content:"";
  position:fixed;
  inset:-30%;
  pointer-events:none;
  z-index:0;
  background:
    radial-gradient(circle at 20% 20%, rgba(138,46,255,.22), transparent 60%),
    radial-gradient(circle at 80% 30%, rgba(138,46,255,.12), transparent 70%),
    radial-gradient(circle at 48% 88%, rgba(138,46,255,.10), transparent 72%),
    radial-gradient(circle at 60% 60%, rgba(255,255,255,.03), transparent 72%);
  mix-blend-mode:screen;
  filter:blur(44px) saturate(1.2);
  animation:fog 18s ease-in-out infinite;
}
@keyframes fog{
  0%,100%{transform:translate(0,0) scale(1)}
  50%{transform:translate(-2.5%,3.5%) scale(1.02)}
}

/* scanlines */
.scan{
  position:fixed; inset:0;
  pointer-events:none;
  z-index:6;
  opacity:.08;
  mix-blend-mode:overlay;
  background:repeating-linear-gradient(to bottom,
    rgba(255,255,255,.06) 0px, rgba(255,255,255,.06) 1px, transparent 3px, transparent 6px);
}

/* full canvas */
#c{
  position:fixed;
  inset:0;
  width:100%;
  height:100%;
  z-index:1;
  image-rendering:pixelated;
}

/* brand + back */
.brand{
  position:fixed; top:14px; left:14px;
  z-index:12;
  font-size:11px;
  letter-spacing:.34em;
  text-transform:uppercase;
  opacity:.78;
  text-shadow:0 0 18px rgba(138,46,255,.35);
}
.brand a{color:#fff;text-decoration:none}

.back{
  position:fixed;
  right:16px;
  top:16px;
  z-index:12;
  font-size:10px;
  letter-spacing:.32em;
  text-transform:uppercase;
  opacity:.65;
}
.back a{color:#fff;text-decoration:none}
.back a:hover{opacity:1}

/* realm HUD */
.hud{
  position:fixed;
  left:50%;
  top:54px;
  transform:translateX(-50%);
  z-index:12;
  text-align:center;
  pointer-events:none;
}
.realm{
  font-size:12px;
  letter-spacing:.46em;
  text-transform:uppercase;
  text-shadow:0 0 18px rgba(138,46,255,.45), 0 0 60px rgba(138,46,255,.18);
  opacity:.92;
}
.tip{
  margin-top:8px;
  font-size:10px;
  letter-spacing:.28em;
  text-transform:uppercase;
  opacity:.55;
}

/* controls bottom right */
.controls{
  position:fixed;
  right:14px;
  bottom:14px;
  z-index:12;
  display:flex;
  gap:10px;
  align-items:center;
}
.btn{
  border:0;
  cursor:pointer;
  padding:10px 12px;
  border-radius:999px;
  background:rgba(255,255,255,.06);
  color:#fff;
  letter-spacing:.26em;
  font-size:10px;
  text-transform:uppercase;
  backdrop-filter:blur(10px);
}
.btn:hover{background:rgba(138,46,255,.14)}
.btn:active{transform:translateY(1px)}
.pill{
  padding:10px 12px;
  border-radius:999px;
  background:rgba(138,46,255,.10);
  letter-spacing:.26em;
  font-size:10px;
  text-transform:uppercase;
  opacity:.75;
}

/* whisper */
.whisper{
  position:fixed;
  left:50%;
  bottom:70px;
  transform:translateX(-50%);
  z-index:12;
  font-size:10px;
  letter-spacing:.32em;
  text-transform:uppercase;
  opacity:0;
  pointer-events:none;
  transition:opacity .12s linear, transform .12s linear;
  text-shadow:0 0 18px rgba(138,46,255,.30);
}
.whisper.on{opacity:.78; transform:translateX(-50%) translateY(-2px)}

/* flash */
.flash{
  position:fixed; inset:0;
  background:#fff;
  opacity:0;
  pointer-events:none;
  z-index:11;
}
.flash.active{animation:flash .14s}
@keyframes flash{
  0%{opacity:0}
  50%{opacity:.28}
  100%{opacity:0}
}

@media (prefers-reduced-motion: reduce){
  body:before{animation:none!important}
}
</style>
</head>

<body>
<canvas id="c"></canvas>

<div class="scan"></div>
<div class="flash" id="flash"></div>
<div class="whisper" id="whisper">TOUCH THE VOID</div>

<div class="brand"><a href="index.html">CLAWBOI</a></div>
<div class="back"><a href="secret.html">RETURN TO TRANSMISSION</a></div>

<div class="hud">
  <div class="realm" id="realmName">GRAVITY DROP</div>
  <div class="tip" id="realmTip">TAP / SPACE = SPAWN • HOLD = CHARGE • NEXT = NEW REALM</div>
</div>

<div class="controls">
  <span class="pill" id="realmIdx">01/05</span>
  <button class="btn" id="prevBtn">◀ PREV</button>
  <button class="btn" id="nextBtn">NEXT ▶</button>
</div>

<script>
/* =======================
   MYSTERY: REALM HOPPER
   - no typing
   - blank world
   - inputs trigger different toys
   - next switches realms
======================= */

const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d", { alpha: true });

const flash = document.getElementById("flash");
const whisper = document.getElementById("whisper");

const realmNameEl = document.getElementById("realmName");
const realmTipEl  = document.getElementById("realmTip");
const realmIdxEl  = document.getElementById("realmIdx");

const prevBtn = document.getElementById("prevBtn");
const nextBtn = document.getElementById("nextBtn");

const clamp = (n,a,b)=> Math.max(a, Math.min(b,n));
const rand  = (a,b)=> a + Math.random()*(b-a);
const rint  = (a,b)=> Math.floor(rand(a,b+1));
const pick  = (arr)=> arr[Math.floor(Math.random()*arr.length)];

let W=innerWidth, H=innerHeight, dpr=1;
function resize(){
  dpr = Math.min(2, window.devicePixelRatio||1);
  W = innerWidth; H = innerHeight;
  canvas.width = Math.floor(W*dpr);
  canvas.height= Math.floor(H*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener("resize", resize);
resize();

/* ====== tiny audio (optional, no files) ====== */
let audioOn=false, ac=null, master=null;
function ensureAudio(){
  if(ac) return;
  ac = new (window.AudioContext||window.webkitAudioContext)();
  master = ac.createGain();
  master.gain.value = 0.10;
  master.connect(ac.destination);
}
async function unlockAudio(){
  try{
    ensureAudio();
    await ac.resume?.();
    audioOn=true;
  }catch(e){}
}
addEventListener("pointerdown", unlockAudio, {passive:true});
addEventListener("keydown", unlockAudio);

function blip(type="triangle", f=220, dur=0.06, g=0.16){
  if(!audioOn || !ac) return;
  const o=ac.createOscillator();
  const gn=ac.createGain();
  o.type=type; o.frequency.value=f;
  gn.gain.value=0.0001;
  o.connect(gn); gn.connect(master);
  const t=ac.currentTime;
  gn.gain.setValueAtTime(0.0001,t);
  gn.gain.exponentialRampToValueAtTime(g,t+0.01);
  gn.gain.exponentialRampToValueAtTime(0.0001,t+dur);
  o.start(t); o.stop(t+dur+0.02);
}
function boom(){
  if(!audioOn || !ac) return;
  const o=ac.createOscillator();
  const gn=ac.createGain();
  o.type="sawtooth";
  o.frequency.setValueAtTime(140, ac.currentTime);
  o.frequency.exponentialRampToValueAtTime(40, ac.currentTime+0.14);
  gn.gain.value=0.14;
  o.connect(gn); gn.connect(master);
  o.start();
  setTimeout(()=>o.stop(), 160);
}

/* ====== UI effects ====== */
function doFlash(){
  flash.classList.add("active");
  setTimeout(()=>flash.classList.remove("active"),120);
}
function say(msg, ms=320){
  whisper.textContent = msg;
  whisper.classList.add("on");
  clearTimeout(say._t);
  say._t = setTimeout(()=>whisper.classList.remove("on"), ms);
}

/* ====== shared particles ====== */
const stars = [];
function initStars(){
  stars.length=0;
  const n = Math.floor((W*H)/12000);
  for(let i=0;i<n;i++){
    stars.push({x:Math.random()*W, y:Math.random()*H, r:Math.random()*1.6+0.2, a:Math.random()*0.6+0.08, s:Math.random()*0.18+0.02});
  }
}
initStars();

function drawStars(speed=1){
  for(const s of stars){
    s.y += s.s*speed;
    if(s.y>H+4){ s.y=-4; s.x=Math.random()*W; }
    ctx.fillStyle = `rgba(255,255,255,${s.a})`;
    ctx.fillRect(s.x, s.y, s.r, s.r);
  }
}

/* =======================
   REALMS
======================= */
let realmIndex = 0;

const realms = [
  {
    name:"GRAVITY DROP",
    tip:"TAP / SPACE = SPAWN • HOLD = HEAVY DROP • DRAG = PUSH",
    init(){
      balls.length=0;
      wind = 0;
      say("DROP SOMETHING");
    },
    action(x,y,charged){
      spawnBall(x,y, charged ? 22 : 12, charged ? 1.35 : 1.0);
      blip("square", rint(90,260), charged?0.10:0.06, charged?0.22:0.16);
    },
    update(dt){
      // subtle violet gradient wash
      ctx.fillStyle = "rgba(0,0,0,0.24)";
      ctx.fillRect(0,0,W,H);

      drawStars(1.2);

      // ground glow
      ctx.fillStyle = "rgba(138,46,255,0.10)";
      ctx.fillRect(0, H-60, W, 60);

      stepBalls(dt);
      drawBalls();
    }
  },
  {
    name:"RAIN ROOM",
    tip:"TAP = THUNDER • HOLD = FLOOD • SPACE = SPLASH",
    init(){
      drops.length=0; ripples.length=0;
      rainRate = 520;
      flood = 0;
      say("LET IT POUR");
    },
    action(x,y,charged){
      if(charged){
        flood = clamp(flood + 0.35, 0, 1.0);
        say("FLOOD RISING", 260);
        boom();
      }else{
        thunder(x,y);
      }
    },
    update(dt){
      ctx.fillStyle = "rgba(0,0,0,0.26)";
      ctx.fillRect(0,0,W,H);

      drawStars(0.9);

      // rain spawn
      const count = Math.floor((rainRate * (1+flood*0.8)) * dt);
      for(let i=0;i<count;i++){
        drops.push({
          x: Math.random()*W,
          y: -20,
          vx: rand(-30,30),
          vy: rand(680,980) * (1+flood*0.35),
          len: rand(10,22),
          a: rand(0.10,0.26)
        });
      }

      // puddle
      const waterH = 70 + flood*120;
      ctx.fillStyle = "rgba(138,46,255,0.08)";
      ctx.fillRect(0, H-waterH, W, waterH);

      // drops update
      for(let i=drops.length-1;i>=0;i--){
        const d = drops[i];
        d.x += d.vx*dt;
        d.y += d.vy*dt;
        ctx.strokeStyle = `rgba(255,255,255,${d.a})`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(d.x, d.y);
        ctx.lineTo(d.x - d.vx*0.02, d.y - d.len);
        ctx.stroke();

        if(d.y > H-waterH){
          // ripple
          ripples.push({x:d.x, y:H-waterH, r:1, a:0.45});
          drops.splice(i,1);
          if(ripples.length>160) ripples.splice(0, ripples.length-160);
        }
      }

      // ripples draw
      for(let i=ripples.length-1;i>=0;i--){
        const r = ripples[i];
        r.r += (90 + flood*80) * dt;
        r.a *= 0.965;
        if(r.a < 0.02){ ripples.splice(i,1); continue; }
        ctx.strokeStyle = `rgba(138,46,255,${r.a})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(r.x, r.y, r.r, 0, Math.PI*2);
        ctx.stroke();
      }
    }
  },
  {
    name:"FIREWORK TEMPLE",
    tip:"TAP = FIREWORK • HOLD = MEGA BLAST • SPACE = SPARK SHOWER",
    init(){
      sparks.length=0; rockets.length=0;
      say("LIGHT THE SKY");
    },
    action(x,y,charged){
      if(charged){
        megaFirework(x,y);
        boom();
        doFlash();
      }else{
        launchRocket(x,y);
        blip("triangle", rint(180,520), 0.07, 0.16);
      }
    },
    update(dt){
      ctx.fillStyle = "rgba(0,0,0,0.24)";
      ctx.fillRect(0,0,W,H);

      drawStars(1.4);

      // faint floor haze
      ctx.fillStyle = "rgba(138,46,255,0.05)";
      ctx.fillRect(0,H-110,W,110);

      stepFireworks(dt);
      drawFireworks();
    }
  },
  {
    name:"ORBIT CHAMBER",
    tip:"TAP = SPAWN ORBITER • HOLD = GRAVITY WELL • DRAG = SLINGSHOT",
    init(){
      orbs.length=0;
      wells.length=0;
      say("MAKE A SYSTEM");
    },
    action(x,y,charged){
      if(charged){
        wells.push({x,y, r: 10, a: 0.9, p: 1.0});
        say("GRAVITY WELL", 220);
        boom();
      }else{
        orbs.push(makeOrb(x,y));
        blip("sine", rint(120,420), 0.07, 0.12);
      }
    },
    update(dt){
      ctx.fillStyle = "rgba(0,0,0,0.22)";
      ctx.fillRect(0,0,W,H);

      drawStars(0.8);

      // wells
      for(let i=wells.length-1;i>=0;i--){
        const w = wells[i];
        w.r += 220*dt;
        w.a *= 0.975;
        w.p *= 0.985;
        if(w.a < 0.03){ wells.splice(i,1); continue; }
        ctx.strokeStyle = `rgba(138,46,255,${w.a})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(w.x, w.y, w.r, 0, Math.PI*2);
        ctx.stroke();
      }

      // orbs physics with gentle orbit + well pull
      for(const o of orbs){
        // base drift
        o.vx *= 0.998; o.vy *= 0.998;

        for(const w of wells){
          const dx = w.x - o.x;
          const dy = w.y - o.y;
          const d2 = dx*dx + dy*dy + 40;
          const f = (5200 * w.p) / d2;
          o.vx += dx * f * dt;
          o.vy += dy * f * dt;
        }

        o.x += o.vx*dt;
        o.y += o.vy*dt;

        // wrap
        if(o.x < -40) o.x=W+40;
        if(o.x > W+40) o.x=-40;
        if(o.y < -40) o.y=H+40;
        if(o.y > H+40) o.y=-40;

        o.phase += dt*(0.8+o.s*0.8);
      }

      // draw orbs
      for(const o of orbs){
        const pulse = 0.6 + 0.4*Math.sin(o.phase*3.2);
        ctx.beginPath();
        ctx.fillStyle = `rgba(138,46,255,${0.22 + pulse*0.22})`;
        ctx.arc(o.x, o.y, o.r*2.6, 0, Math.PI*2);
        ctx.fill();

        ctx.beginPath();
        ctx.fillStyle = `rgba(255,255,255,${0.45 + pulse*0.30})`;
        ctx.arc(o.x, o.y, o.r, 0, Math.PI*2);
        ctx.fill();
      }
    }
  },
  {
    name:"SHARD GARDEN",
    tip:"TAP = GROW CRYSTALS • HOLD = SHOCKWAVE • SPACE = BLOOM BURST",
    init(){
      shards.length=0; waves.length=0;
      say("PLANT LIGHT");
    },
    action(x,y,charged){
      if(charged){
        waves.push({x,y, r: 1, a: 0.55});
        boom();
        say("SHOCKWAVE", 220);
      }else{
        growShard(x,y);
        blip("triangle", rint(220,760), 0.06, 0.14);
      }
    },
    update(dt){
      ctx.fillStyle = "rgba(0,0,0,0.26)";
      ctx.fillRect(0,0,W,H);

      drawStars(1.0);

      // waves
      for(let i=waves.length-1;i>=0;i--){
        const w = waves[i];
        w.r += 520*dt;
        w.a *= 0.965;
        if(w.a < 0.02){ waves.splice(i,1); continue; }
        ctx.strokeStyle = `rgba(138,46,255,${w.a})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(w.x,w.y,w.r,0,Math.PI*2);
        ctx.stroke();
      }

      // shards
      for(const s of shards){
        s.t += dt;
        s.wob = Math.sin(s.t*2.4 + s.seed)*0.6;
      }

      drawShards();
    }
  }
];

function setRealm(idx){
  realmIndex = (idx + realms.length) % realms.length;
  realmNameEl.textContent = realms[realmIndex].name;
  realmTipEl.textContent  = realms[realmIndex].tip;
  realmIdxEl.textContent  = String(realmIndex+1).padStart(2,"0") + "/0" + realms.length;
  initStars();
  realms[realmIndex].init();
}

/* =======================
   REALM 1: Physics balls
======================= */
const balls = [];
let wind = 0;

function spawnBall(x,y, r=12, mass=1){
  balls.push({
    x, y,
    vx: rand(-180,180),
    vy: rand(-120,60),
    r,
    m: mass,
    spin: rand(-2,2),
    hue: rint(260,310),
    life: 0
  });
  if(balls.length > 90) balls.splice(0, balls.length-90);
}

function stepBalls(dt){
  // gentle wind drift
  wind = wind*0.97 + rand(-12,12)*0.02;

  for(const b of balls){
    b.life += dt;

    b.vx += wind*dt;
    b.vy += 980*dt; // gravity

    // integrate
    b.x += b.vx*dt;
    b.y += b.vy*dt;

    // walls
    if(b.x < b.r){ b.x=b.r; b.vx*=-0.82; blip("sine", 180, 0.04, 0.06); }
    if(b.x > W-b.r){ b.x=W-b.r; b.vx*=-0.82; blip("sine", 180, 0.04, 0.06); }

    // floor
    const floor = H - 20;
    if(b.y > floor-b.r){
      b.y = floor-b.r;
      b.vy *= -0.78;
      b.vx *= 0.96;
      if(Math.abs(b.vy) > 220) blip("square", rint(90,220), 0.05, 0.08);
    }

    // ceiling
    if(b.y < b.r){ b.y=b.r; b.vy*=-0.7; }
  }

  // simple ball-ball repel
  for(let i=0;i<balls.length;i++){
    for(let j=i+1;j<balls.length;j++){
      const a=balls[i], b=balls[j];
      const dx=b.x-a.x, dy=b.y-a.y;
      const d=Math.hypot(dx,dy);
      const min=a.r+b.r;
      if(d>0 && d<min){
        const nx=dx/d, ny=dy/d;
        const push=(min-d)*0.55;
        a.x -= nx*push; a.y -= ny*push;
        b.x += nx*push; b.y += ny*push;
        const k = 240; // impulse
        a.vx -= nx*k*0.5; a.vy -= ny*k*0.5;
        b.vx += nx*k*0.5; b.vy += ny*k*0.5;
      }
    }
  }
}

function drawBalls(){
  for(const b of balls){
    // glow
    ctx.beginPath();
    ctx.fillStyle = `hsla(${b.hue}, 100%, 60%, 0.14)`;
    ctx.arc(b.x, b.y, b.r*2.8, 0, Math.PI*2);
    ctx.fill();

    // core
    ctx.beginPath();
    ctx.fillStyle = `hsla(${b.hue}, 100%, 72%, 0.75)`;
    ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
    ctx.fill();

    // highlight
    ctx.beginPath();
    ctx.fillStyle = `rgba(255,255,255,0.40)`;
    ctx.arc(b.x - b.r*0.25, b.y - b.r*0.25, b.r*0.28, 0, Math.PI*2);
    ctx.fill();
  }
}

/* =======================
   REALM 2: Rain
======================= */
const drops = [];
const ripples = [];
let rainRate = 520;
let flood = 0;

function thunder(x,y){
  doFlash();
  say("THUNDER", 180);
  blip("square", rint(40,120), 0.09, 0.20);
  // jag lightning
  ctx.save();
  ctx.globalAlpha = 0.45;
  ctx.strokeStyle = "rgba(255,255,255,0.9)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  let lx = x, ly = 0;
  ctx.moveTo(lx, ly);
  const steps = 10;
  for(let i=0;i<steps;i++){
    lx += rand(-30,30);
    ly += H/(steps+2);
    ctx.lineTo(lx, ly);
  }
  ctx.stroke();
  ctx.restore();

  // ripple burst
  for(let i=0;i<8;i++){
    ripples.push({x:x+rand(-40,40), y:H-(70+flood*120), r:1, a:0.55});
  }
  if(ripples.length>160) ripples.splice(0, ripples.length-160);
}

/* =======================
   REALM 3: Fireworks
======================= */
const rockets = [];
const sparks = [];

function launchRocket(x,y){
  rockets.push({
    x, y: H + 30,
    vx: rand(-40,40),
    vy: -rand(820,1060),
    targetX: x,
    targetY: clamp(y, 90, H*0.72),
    hue: rint(260,315),
    life: 0
  });
  if(rockets.length>14) rockets.splice(0, rockets.length-14);
}

function explode(x,y,hue, power=1){
  const count = Math.floor(70*power);
  for(let i=0;i<count;i++){
    const a = Math.random()*Math.PI*2;
    const sp = rand(120, 520)*power;
    sparks.push({
      x,y,
      vx: Math.cos(a)*sp,
      vy: Math.sin(a)*sp,
      r: rand(1.2,2.6)*power,
      hue,
      a: rand(0.40,0.95),
      life: 0
    });
  }
  if(sparks.length>1400) sparks.splice(0, sparks.length-1400);
}

function megaFirework(x,y){
  const hue = rint(260,320);
  for(let i=0;i<4;i++){
    explode(x+rand(-40,40), y+rand(-40,40), hue + rint(-10,10), 1.25);
  }
}

function stepFireworks(dt){
  // rockets
  for(let i=rockets.length-1;i>=0;i--){
    const r = rockets[i];
    r.life += dt;
    r.x += r.vx*dt;
    r.y += r.vy*dt;
    r.vy += 280*dt; // gravity
    // trail
    if(Math.random()<0.65){
      sparks.push({
        x:r.x, y:r.y,
        vx: rand(-40,40),
        vy: rand(40,160),
        r: rand(0.8,1.6),
        hue:r.hue,
        a: rand(0.08,0.22),
        life: 0,
        trail:true
      });
    }
    if(r.y <= r.targetY || r.vy > -40){
      explode(r.x, r.y, r.hue, 1.0);
      blip("triangle", rint(180,520), 0.08, 0.18);
      rockets.splice(i,1);
    }
  }

  // sparks
  for(let i=sparks.length-1;i>=0;i--){
    const s = sparks[i];
    s.life += dt;
    s.x += s.vx*dt;
    s.y += s.vy*dt;
    s.vx *= 0.992;
    s.vy *= 0.992;
    s.vy += (s.trail?220:520)*dt;
    s.a *= s.trail ? 0.965 : 0.985;

    if(s.y > H+60 || s.a < 0.03){
      sparks.splice(i,1);
    }
  }
}

function drawFireworks(){
  // rockets
  for(const r of rockets){
    ctx.beginPath();
    ctx.fillStyle = `hsla(${r.hue},100%,70%,0.85)`;
    ctx.arc(r.x,r.y,3,0,Math.PI*2);
    ctx.fill();
  }
  // sparks
  for(const s of sparks){
    ctx.beginPath();
    ctx.fillStyle = `hsla(${s.hue},100%,70%,${s.a})`;
    ctx.arc(s.x,s.y,s.r,0,Math.PI*2);
    ctx.fill();

    // glow
    if(!s.trail){
      ctx.beginPath();
      ctx.fillStyle = `hsla(${s.hue},100%,60%,${s.a*0.10})`;
      ctx.arc(s.x,s.y,s.r*6,0,Math.PI*2);
      ctx.fill();
    }
  }
}

/* =======================
   REALM 4: Orbit
======================= */
const orbs = [];
const wells = [];
function makeOrb(x,y){
  const s = rand(0.4,1.2);
  return {
    x,y,
    vx: rand(-90,90),
    vy: rand(-90,90),
    r: rand(2.2,4.2),
    s,
    phase: rand(0,10)
  };
}

/* =======================
   REALM 5: Shards
======================= */
const shards = [];
const waves = [];

function growShard(x,y){
  const h = rint(260,320);
  const height = rand(18, 90);
  const w = rand(4, 14);
  shards.push({
    x,y,
    h,
    height,
    w,
    t: 0,
    seed: rand(0,999),
    tilt: rand(-0.5,0.5)
  });
  if(shards.length>120) shards.splice(0, shards.length-120);
}

function drawShards(){
  for(const s of shards){
    const sway = s.wob || 0;
    const tilt = s.tilt + sway*0.06;
    const topX = s.x + tilt*s.height;
    const topY = s.y - s.height;

    // glow
    ctx.strokeStyle = `hsla(${s.h}, 100%, 60%, 0.20)`;
    ctx.lineWidth = s.w*2.4;
    ctx.beginPath();
    ctx.moveTo(s.x, s.y);
    ctx.lineTo(topX, topY);
    ctx.stroke();

    // core
    ctx.strokeStyle = `hsla(${s.h}, 100%, 74%, 0.85)`;
    ctx.lineWidth = s.w;
    ctx.beginPath();
    ctx.moveTo(s.x, s.y);
    ctx.lineTo(topX, topY);
    ctx.stroke();

    // tip highlight
    ctx.beginPath();
    ctx.fillStyle = "rgba(255,255,255,0.55)";
    ctx.arc(topX, topY, 2.2, 0, Math.PI*2);
    ctx.fill();
  }
}

/* =======================
   INPUT: click / tap / hold / drag / keys
======================= */
let pointerDown=false, downT=0, downX=0, downY=0;
let lastX=W/2, lastY=H/2;

function realmAction(x,y,charged){
  realms[realmIndex].action(x,y,charged);
}

addEventListener("pointermove", (e)=>{
  lastX=e.clientX; lastY=e.clientY;
  // Drag pushes in physics realm
  if(pointerDown && realms[realmIndex].name==="GRAVITY DROP"){
    const dx = e.clientX - downX;
    const dy = e.clientY - downY;
    if(Math.abs(dx)+Math.abs(dy) > 14){
      for(const b of balls){
        const d = Math.hypot(b.x-e.clientX, b.y-e.clientY);
        if(d < 120){
          b.vx += dx*0.22;
          b.vy += dy*0.12;
        }
      }
      downX = e.clientX; downY = e.clientY;
    }
  }
}, {passive:true});

addEventListener("pointerdown", (e)=>{
  pointerDown=true;
  downT=performance.now();
  downX=e.clientX; downY=e.clientY;
  lastX=downX; lastY=downY;
  say(pick(["TOUCH RECEIVED","SIGNAL FOUND","A NEW MOVE","DO IT AGAIN"]), 200);
}, {passive:true});

addEventListener("pointerup", (e)=>{
  if(!pointerDown) return;
  pointerDown=false;

  const ms = performance.now()-downT;
  const charged = ms > 520;

  realmAction(e.clientX, e.clientY, charged);
}, {passive:true});

// keys
addEventListener("keydown", (e)=>{
  const k = e.key;
  if(k === "ArrowRight"){ setRealm(realmIndex+1); blip("sine", 420, 0.06, 0.10); return; }
  if(k === "ArrowLeft"){ setRealm(realmIndex-1); blip("sine", 340, 0.06, 0.10); return; }

  if(k === " " || k === "Enter"){
    e.preventDefault();
    realmAction(lastX, lastY, false);
    return;
  }

  // extra: “B” triggers big version
  if(k.toLowerCase() === "b"){
    realmAction(lastX, lastY, true);
  }
}, {passive:false});

// buttons
prevBtn.onclick = ()=>{ setRealm(realmIndex-1); blip("sine", 320, 0.06, 0.10); };
nextBtn.onclick = ()=>{ setRealm(realmIndex+1); blip("sine", 420, 0.06, 0.10); };

/* =======================
   LOOP
======================= */
let lastT = performance.now();
function loop(t){
  const dt = clamp((t-lastT)/1000, 0, 0.033);
  lastT = t;

  // realm updates draw their own “fade”
  realms[realmIndex].update(dt);

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* =======================
   START
======================= */
setRealm(0);
say("TAP OR PRESS SPACE", 520);
</script>
</body>
</html>
