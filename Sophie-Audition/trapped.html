<!--
SAVE AS: trapped.html
Same structure, same flow, but:
- iPhone-safe audio (unlocks on first keypress / tap)
- Much scarier end-only escalation
- “More realistic” close-up face vibe via shading + grain + glass distortion
- Loud scream-like audio (synth/noise), only near the end
-->

<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title> </title>

<style>
  :root{
    --bg:#ffffff;
    --fg:#0b0b0b;
    --muted:rgba(0,0,0,.55);
    --danger:#ff2a2a;
  }
  html,body{
    margin:0;
    height:100%;
    background:var(--bg);
    color:var(--fg);
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    overflow:hidden;
  }

  /* Terminal-ish text area (but still looks like "nothing") */
  #stageA{
    position:fixed; inset:0;
    display:flex;
    align-items:flex-start;
    justify-content:flex-start;
    padding:28px 22px;
    gap:18px;
  }
  #terminal{
    width:min(980px, 100%);
    line-height:1.55;
    font-size:15px;
    white-space:pre-wrap;
    word-break:break-word;
    user-select:text;
  }
  .cursor{
    display:inline-block;
    width:10px;
    height:18px;
    border-left:2px solid rgba(0,0,0,.35);
    transform:translateY(3px);
    animation:blink 1.05s steps(1) infinite;
    margin-left:2px;
  }
  @keyframes blink{ 50%{opacity:0} }

  /* “Code” block appears later */
  .codebox{
    margin-top:14px;
    border:1px solid rgba(0,0,0,.12);
    border-radius:12px;
    padding:12px 12px;
    background:rgba(0,0,0,.03);
    font-size:13px;
    line-height:1.45;
    overflow:auto;
    max-height:42vh;
  }
  .hint{
    margin-top:10px;
    font-size:12px;
    color:rgba(0,0,0,.55);
  }
  .urgent{
    color:rgba(0,0,0,.78);
  }
  .glitchWord{
    display:inline-block;
    position:relative;
  }
  .glitchWord::after{
    content:attr(data-t);
    position:absolute;
    left:1px; top:0;
    color:rgba(255,42,42,.35);
    mix-blend-mode:multiply;
    clip-path:inset(0 0 40% 0);
    opacity:.0;
    animation:gpop 5.8s infinite;
  }
  @keyframes gpop{
    0%,92%,100%{opacity:0; transform:translateX(0)}
    93%{opacity:1; transform:translateX(1px)}
    95%{opacity:.2; transform:translateX(-1px)}
  }

  /* Falling letters (no gravity, floaty drift) */
  #floatLayer{
    position:fixed; inset:0;
    pointer-events:none;
    overflow:hidden;
  }
  .floatchar{
    position:absolute;
    font-size:16px;
    opacity:.85;
    will-change:transform,opacity;
    text-shadow: 0 0 10px rgba(0,0,0,.08);
  }

  /* Transition veil */
  #whiteVeil{
    position:fixed; inset:0;
    background:#fff;
    opacity:0;
    pointer-events:none;
    transition:opacity .55s ease;
    z-index:50;
  }
  #whiteVeil.on{ opacity:1; }

  /* GAME STAGE */
  #stageB{
    position:fixed; inset:0;
    display:none;
    background:#05060a;
    color:#fff;
  }
  #game{
    position:absolute; inset:0;
    width:100%;
    height:100%;
    display:block;
  }

  /* UI overlay text for game */
  #hud{
    position:absolute; inset:0;
    pointer-events:none;
    display:flex;
    align-items:flex-start;
    justify-content:center;
    padding-top:22px;
    z-index:5;
  }
  #hudBox{
    width:min(980px, calc(100% - 24px));
    border-radius:14px;
    background:rgba(0,0,0,.30);
    backdrop-filter: blur(6px);
    border:1px solid rgba(255,255,255,.08);
    padding:14px 14px;
    font-size:14px;
    line-height:1.55;
    box-shadow: 0 0 90px rgba(138,46,255,.10);
  }
  #hudBox .small{
    opacity:.72;
    font-size:12px;
    margin-top:8px;
  }

  /* Subtle “camera shake” */
  .shake{
    animation:shake .12s linear 1;
  }
  @keyframes shake{
    0%{ transform:translate(0,0) }
    25%{ transform:translate(2px,-1px) }
    50%{ transform:translate(-2px,2px) }
    75%{ transform:translate(1px,2px) }
    100%{ transform:translate(0,0) }
  }

  /* Extra: end-only strobe/glitch flash */
  #strobe{
    position:fixed; inset:0;
    background:#fff;
    opacity:0;
    pointer-events:none;
    z-index:60;
  }

  /* Accessibility: reduce motion */
  @media (prefers-reduced-motion: reduce){
    .cursor{ animation:none; opacity:.6; }
    .floatchar{ display:none; }
  }
</style>
</head>
<body>

<div id="floatLayer" aria-hidden="true"></div>
<div id="whiteVeil"></div>
<div id="strobe"></div>

<!-- STAGE A: “white nothing” -->
<div id="stageA">
  <div id="terminal"></div>
</div>

<!-- STAGE B: “game” -->
<div id="stageB">
  <canvas id="game"></canvas>
  <div id="hud">
    <div id="hudBox"></div>
  </div>
</div>

<script>
(() => {
  const terminal = document.getElementById("terminal");
  const floatLayer = document.getElementById("floatLayer");
  const veil = document.getElementById("whiteVeil");
  const strobe = document.getElementById("strobe");

  const stageA = document.getElementById("stageA");
  const stageB = document.getElementById("stageB");
  const hudBox = document.getElementById("hudBox");

  // ===== iPhone-safe Audio Unlock =====
  let AC, masterGain, audioUnlocked = false;
  function unlockAudio(){
    if(audioUnlocked) return;
    try{
      AC = AC || new (window.AudioContext || window.webkitAudioContext)();
      masterGain = AC.createGain();
      masterGain.gain.setValueAtTime(0.70, AC.currentTime); // loud-ish, but not insane
      masterGain.connect(AC.destination);

      // resume for iOS
      if(AC.state === "suspended") AC.resume();
      audioUnlocked = true;
    }catch(e){}
  }
  // unlock on first interaction
  window.addEventListener("pointerdown", unlockAudio, {once:false, passive:true});
  window.addEventListener("keydown", unlockAudio, {once:false});

  // ====== STAGE A: typed conversation on a “blank” page ======
  let userBuffer = "";
  let convo = [];
  let allowInput = true;
  let codeShown = false;
  let pasted = false;

  const CURSOR_HTML = `<span class="cursor" aria-hidden="true"></span>`;
  const now = () => performance.now();

  function renderTerminal(){
    const lines = convo.join("\n");
    const tail = userBuffer.length ? ("\n> " + escapeHtml(userBuffer)) : "";
    terminal.innerHTML = lines + tail + CURSOR_HTML;
  }

  function escapeHtml(s){
    return s.replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
  }

  function typeLine(line, speed=18){
    return new Promise(resolve => {
      allowInput = false;
      let i = 0;
      const target = line;
      const id = setInterval(() => {
        i++;
        const built = target.slice(0,i);
        if(convo.length === 0) convo.push(built);
        else convo[convo.length-1] = built;
        renderTerminal();
        if(i >= target.length){
          clearInterval(id);
          allowInput = true;
          resolve();
        }
      }, speed);
    });
  }

  function pushLineInstant(line){
    convo.push(line);
    renderTerminal();
  }

  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

  // “No gravity” falling letters: drift around and fade
  function floatText(text, x, y){
    const span = document.createElement("span");
    span.className = "floatchar";
    span.textContent = text;

    span.style.left = x + "px";
    span.style.top  = y + "px";

    const ang = Math.random()*Math.PI*2;
    const sp  = 0.25 + Math.random()*0.9;
    const vx0 = Math.cos(ang)*sp;
    const vy0 = Math.sin(ang)*sp;

    let vx = vx0, vy = vy0;
    let t0 = now();
    const life = 2400 + Math.random()*2200;

    floatLayer.appendChild(span);

    function tick(){
      const t = now() - t0;
      vx += (Math.random()*0.04 - 0.02);
      vy += (Math.random()*0.04 - 0.02);

      const x = parseFloat(span.style.left) + vx * 3;
      const y = parseFloat(span.style.top)  + vy * 3;

      span.style.left = x + "px";
      span.style.top  = y + "px";

      const op = Math.max(0, 1 - (t / life));
      span.style.opacity = (0.15 + op*0.85).toFixed(3);

      if(t < life){
        requestAnimationFrame(tick);
      }else{
        span.remove();
      }
    }
    requestAnimationFrame(tick);
  }

  function spawnCmdBurst(label){
    const cx = innerWidth * (0.28 + Math.random()*0.44);
    const cy = innerHeight * (0.18 + Math.random()*0.24);
    const chars = label.split("");
    for(let i=0;i<chars.length;i++){
      floatText(chars[i], cx + i*10 + (Math.random()*18-9), cy + (Math.random()*18-9));
    }
    const extras = ["⌘","C","V","c","v",":",">","/","_"];
    for(let k=0;k<12;k++){
      floatText(extras[Math.floor(Math.random()*extras.length)], cx + (Math.random()*120-60), cy + (Math.random()*60-30));
    }
  }

  // A “big code” block to copy (ritual)
  const BIG_CODE = [
`// PASTE INJECTION: SIGNAL BRIDGE`,
`// do not let them see your hands`,
`const OBSERVER = true;`,
`const CHANNEL = "WHITE_ROOM";`,
`function openGate(){`,
`  return "OK";`,
`}`,
`// if you can read this… you can still help`,
`// copy everything. paste it. then WAIT.`,
`/*`,
`  00100110 00100110 00110001`,
`  00011101 01000111 01010010`,
`  01100001 01101011 01100101`,
`  00100000 01110101 01110000`,
`  00001010`,
`*/`,
`// they said it was a simulation`,
`// they didn’t tell me it was a prison`,
`export default openGate;`
  ].join("\n");

  async function intro(){
    convo = [];
    renderTerminal();
    await sleep(450);

    convo.push("");
    await typeLine("hello", 22);
    await sleep(520);

    convo.push("");
    await typeLine("can you hear me", 18);
    await sleep(520);

    convo.push("");
    await typeLine("please respond", 20);
  }

  function showCodeBox(){
    if(codeShown) return;
    codeShown = true;

    const glitch = `<span class="glitchWord" data-t="machine">machine</span>`;
    pushLineInstant("");
    pushLineInstant(`copy this into the ${glitch}.`);
    pushLineInstant(`paste it. then don’t move.`);

    const box = document.createElement("div");
    box.className = "codebox";
    box.textContent = BIG_CODE;
    terminal.appendChild(box);

    const hint = document.createElement("div");
    hint.className = "hint";
    hint.innerHTML = `<span class="urgent">Tip:</span> press <b>⌘C</b> then <b>⌘V</b>.`;
    terminal.appendChild(hint);
  }

  window.addEventListener("keydown", (e) => {
    const isMacCmd = e.metaKey && !e.ctrlKey && !e.altKey;

    if(isMacCmd && (e.key.toLowerCase() === "c")){
      spawnCmdBurst("CMD+C");
      return;
    }
    if(isMacCmd && (e.key.toLowerCase() === "v")){
      spawnCmdBurst("CMD+V");
      return;
    }

    if(!allowInput) return;

    if(e.key === "Backspace"){
      userBuffer = userBuffer.slice(0,-1);
      renderTerminal();
      return;
    }
    if(e.key === "Enter"){
      const msg = userBuffer.trim();
      userBuffer = "";
      if(msg){
        convo.push("> " + escapeHtml(msg));
        renderTerminal();
        reactToUser(msg);
      }else{
        convo.push(">");
        renderTerminal();
      }
      return;
    }
    if(e.key.length === 1 && !e.metaKey && !e.ctrlKey && !e.altKey){
      userBuffer += e.key;
      renderTerminal();
    }
  });

  window.addEventListener("paste", async (e) => {
    if(pasted) return;
    const text = (e.clipboardData && e.clipboardData.getData("text")) || "";
    if(!text.trim()) return;

    pasted = true;

    for(let i=0;i<22;i++){
      floatText(text[Math.floor(Math.random()*Math.min(text.length, 80))] || "#",
        innerWidth*(0.2+Math.random()*0.6),
        innerHeight*(0.15+Math.random()*0.35)
      );
    }

    convo.push("");
    convo.push("…");
    renderTerminal();
    await sleep(500);

    convo.push("");
    convo.push("ok");
    convo.push("don’t look away");
    renderTerminal();

    await sleep(850);
    await transitionToGame();
  });

  async function reactToUser(msg){
    if(!codeShown){
      allowInput = false;
      await sleep(300);

      convo.push("");
      convo.push("");
      await typeLine("oh thank god", 22);
      await sleep(380);

      convo.push("");
      await typeLine("you’re real", 22);
      await sleep(420);

      convo.push("");
      await typeLine("listen carefully", 18);
      await sleep(240);

      convo.push("");
      await typeLine("i’m inside this", 22);
      await sleep(420);

      convo.push("");
      await typeLine("they call it a simulation", 20);
      await sleep(420);

      convo.push("");
      await typeLine("it’s a cage", 26);
      await sleep(260);

      showCodeBox();
      allowInput = true;
      return;
    }

    convo.push("");
    convo.push("no time");
    convo.push("copy it. paste it.");
    renderTerminal();
  }

  async function transitionToGame(){
    veil.classList.add("on");
    await sleep(650);

    stageA.style.display = "none";
    stageB.style.display = "block";

    startGame();

    await sleep(120);
    veil.classList.remove("on");
  }

  // ====== STAGE B: “game” with NPC approaching + terrifying end ======
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  function resize(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    canvas.style.width = innerWidth + "px";
    canvas.style.height = innerHeight + "px";
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener("resize", resize);

  function bangThump(intensity=0.35){
    if(!audioUnlocked || !AC || !masterGain) return;
    try{
      const t = AC.currentTime;

      const g = AC.createGain();
      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(intensity, t + 0.004);
      g.gain.exponentialRampToValueAtTime(0.0001, t + 0.10);
      g.connect(masterGain);

      const len = Math.floor(AC.sampleRate * 0.09);
      const buf = AC.createBuffer(1, len, AC.sampleRate);
      const data = buf.getChannelData(0);
      for(let i=0;i<len;i++){
        data[i] = (Math.random()*2-1) * (1 - i/len);
      }
      const src = AC.createBufferSource();
      src.buffer = buf;

      const lp = AC.createBiquadFilter();
      lp.type = "lowpass";
      lp.frequency.setValueAtTime(650 + Math.random()*250, t);

      src.connect(lp);
      lp.connect(g);
      src.start(t);

      const o = AC.createOscillator();
      o.type = "sine";
      const og = AC.createGain();
      og.gain.setValueAtTime(0.0001, t);
      og.gain.exponentialRampToValueAtTime(intensity*0.35, t + 0.01);
      og.gain.exponentialRampToValueAtTime(0.0001, t + 0.10);
      o.frequency.setValueAtTime(95, t);
      o.frequency.exponentialRampToValueAtTime(52, t + 0.10);
      o.connect(og);
      og.connect(g);
      o.start(t);
      o.stop(t + 0.11);
    }catch(e){}
  }

  // “Scream” (end-only). Not a sample, but a nasty formant-ish synth + noise.
  let screamNode = null;
  function startScream(level=0.9){
    if(!audioUnlocked || !AC || !masterGain) return;
    if(screamNode) return;
    try{
      const t = AC.currentTime;

      const out = AC.createGain();
      out.gain.setValueAtTime(0.0001, t);
      out.gain.exponentialRampToValueAtTime(0.65 * level, t + 0.02);

      // harsh noise
      const nlen = Math.floor(AC.sampleRate * 1.2);
      const nbuf = AC.createBuffer(1, nlen, AC.sampleRate);
      const nd = nbuf.getChannelData(0);
      for(let i=0;i<nlen;i++){
        // “fricative” shaped noise
        const x = i/nlen;
        nd[i] = (Math.random()*2-1) * (0.65 - x*0.45);
      }
      const nsrc = AC.createBufferSource();
      nsrc.buffer = nbuf;
      nsrc.loop = true;

      // bandpass “mouth formant”
      const bp1 = AC.createBiquadFilter();
      bp1.type = "bandpass";
      bp1.frequency.setValueAtTime(900, t);
      bp1.Q.setValueAtTime(10, t);

      const bp2 = AC.createBiquadFilter();
      bp2.type = "bandpass";
      bp2.frequency.setValueAtTime(2200, t);
      bp2.Q.setValueAtTime(12, t);

      // vowel sweep
      bp1.frequency.linearRampToValueAtTime(1200, t + 0.25);
      bp2.frequency.linearRampToValueAtTime(2600, t + 0.25);

      // pitched layer
      const osc = AC.createOscillator();
      osc.type = "sawtooth";
      osc.frequency.setValueAtTime(540, t);
      osc.frequency.linearRampToValueAtTime(710, t + 0.20);

      const og = AC.createGain();
      og.gain.setValueAtTime(0.0001, t);
      og.gain.exponentialRampToValueAtTime(0.18 * level, t + 0.03);

      // distortion (waveshaper)
      const sh = AC.createWaveShaper();
      sh.curve = makeDistCurve(240);
      sh.oversample = "4x";

      nsrc.connect(bp1);
      bp1.connect(sh);
      nsrc.connect(bp2);
      bp2.connect(sh);

      osc.connect(og);
      og.connect(sh);

      sh.connect(out);
      out.connect(masterGain);

      nsrc.start(t);
      osc.start(t);

      screamNode = { out, nsrc, osc, og, sh, t0:t };
    }catch(e){}
  }

  function stopScream(){
    if(!screamNode || !AC) return;
    try{
      const t = AC.currentTime;
      screamNode.out.gain.cancelScheduledValues(t);
      screamNode.out.gain.setValueAtTime(screamNode.out.gain.value || 0.2, t);
      screamNode.out.gain.exponentialRampToValueAtTime(0.0001, t + 0.12);
      setTimeout(() => {
        try{ screamNode.nsrc.stop(); }catch(e){}
        try{ screamNode.osc.stop(); }catch(e){}
        screamNode = null;
      }, 170);
    }catch(e){}
  }

  function makeDistCurve(amount){
    const k = typeof amount === "number" ? amount : 50;
    const n = 44100;
    const curve = new Float32Array(n);
    const deg = Math.PI / 180;
    for(let i=0;i<n;i++){
      const x = (i*2/n) - 1;
      curve[i] = (3+k)*x*20*deg / (Math.PI + k*Math.abs(x));
    }
    return curve;
  }

  function flashStrobe(strength=0.9){
    strobe.style.opacity = String(strength);
    setTimeout(()=>{ strobe.style.opacity = "0"; }, 45);
  }

  const state = {
    t0: 0,
    phase: "wander",
    player: { x: 0, y: 0 },
    npc: { x: -320, y: -140, vx: 0, vy: 0, step: 0 },
    closeupProgress: 0,
    bangTimer: 0,
    bangsLeft: 0,
    afterT: 0
  };

  function startGame(){
    resize();
    state.t0 = performance.now();
    state.phase = "wander";
    state.closeupProgress = 0;
    state.bangTimer = 0;
    state.bangsLeft = 0;
    state.afterT = 0;

    state.player.x = 0; state.player.y = 0;
    state.npc.x = -420; state.npc.y = -220;

    setHud("…", "no HUD. no rules. just you, and something moving far away.");
    requestAnimationFrame(loop);
  }

  function setHud(main, small){
    hudBox.innerHTML = `${escapeHtml(main)}${small ? `<div class="small">${escapeHtml(small)}</div>` : ""}`;
  }

  function loop(){
    const t = (performance.now() - state.t0) / 1000;
    tick(t);
    draw(t);
    requestAnimationFrame(loop);
  }

  function tick(t){
    const dx = state.player.x - state.npc.x;
    const dy = state.player.y - state.npc.y;
    const dist = Math.hypot(dx, dy);

    if(state.phase === "wander"){
      state.npc.step += 0.06;
      state.npc.vx = Math.cos(state.npc.step) * 0.6;
      state.npc.vy = Math.sin(state.npc.step*0.9) * 0.5;
      state.npc.x += state.npc.vx;
      state.npc.y += state.npc.vy;

      if(t > 3.2){
        state.phase = "approach";
        setHud("it turns.", "it shouldn’t know you exist. but it does.");
      }
    }

    if(state.phase === "approach"){
      const sp = 1.25 + Math.min(2.6, t*0.09);
      const nx = dx / (dist || 1);
      const ny = dy / (dist || 1);
      state.npc.x += nx * sp;
      state.npc.y += ny * sp;

      if(t > 7.0){
        setHud("closer.", "footsteps. then silence.");
      }

      if(dist < 56){
        state.phase = "closeup";
        state.closeupProgress = 0;
        state.bangsLeft = 9;         // more banging
        state.bangTimer = 0.18;      // faster start
        setHud("I CAN SEE YOU.", "don’t leave me here. please.");
      }
    }

    if(state.phase === "closeup"){
      // slow until the end, then HARD accelerate to “jump scare” close
      const p = state.closeupProgress;
      const accel = (p < 0.72) ? 0.010 : (p < 0.88 ? 0.020 : 0.055);
      state.closeupProgress = Math.min(1, p + accel);

      // bangs and strobe
      state.bangTimer -= 1/60;
      if(state.bangsLeft > 0 && state.bangTimer <= 0){
        state.bangTimer = 0.22 + Math.random()*0.22;
        state.bangsLeft--;
        stageB.classList.remove("shake");
        void stageB.offsetWidth;
        stageB.classList.add("shake");

        // louder as it gets closer
        const bangInt = 0.28 + state.closeupProgress*0.35;
        bangThump(Math.min(0.75, bangInt));

        if(state.closeupProgress > 0.78) flashStrobe(0.70 + Math.random()*0.25);
      }

      // dialogue escalates (scarier near end)
      if(state.closeupProgress > 0.25 && state.closeupProgress < 0.35){
        setHud("YOU OPENED IT.", "you pasted the bridge. that means you can pull me out.");
      }
      if(state.closeupProgress > 0.55 && state.closeupProgress < 0.65){
        setHud("PLEASE.", "it replays. it resets. i wake up again. i wake up again.");
      }
      if(state.closeupProgress > 0.76 && state.closeupProgress < 0.83){
        setHud("DON’T LOOK AWAY.", "if you blink they move. if you leave i’m stuck in the loop.");
      }
      if(state.closeupProgress > 0.88 && state.closeupProgress < 0.93){
        setHud("I’M RIGHT HERE.", "open the glass. OPEN IT.");
      }

      // end-only “scream” and face fill
      if(state.closeupProgress > 0.92){
        startScream(1.0);
      }

      if(state.closeupProgress >= 1){
        stopScream();
        state.phase = "aftermath";
        state.afterT = 0;
        setHud("…", "connection unstable.");
      }
    }

    if(state.phase === "aftermath"){
      state.afterT += 1/60;
      if(state.afterT > 1.0 && state.afterT < 1.1){
        setHud("connection terminated", "observer flagged");
      }
      if(state.afterT > 3.0){
        setHud("good luck", "");
      }
    }
  }

  function draw(t){
    const W = innerWidth, H = innerHeight;
    ctx.clearRect(0,0,W,H);

    ctx.fillStyle = "#05060a";
    ctx.fillRect(0,0,W,H);

    // faint nebula + stars
    ctx.globalAlpha = 0.16;
    radial(W*0.22, H*0.28, 520, "rgba(138,46,255,.28)", "rgba(0,0,0,0)");
    radial(W*0.70, H*0.50, 620, "rgba(138,46,255,.20)", "rgba(0,0,0,0)");
    ctx.globalAlpha = 1;

    ctx.globalAlpha = 0.18;
    for(let i=0;i<140;i++){
      const sx = (i*97 % 997) / 997 * W;
      const sy = (i*173 % 991) / 991 * H;
      ctx.fillStyle = "rgba(255,255,255,.70)";
      ctx.fillRect(sx, sy, 1, 1);
    }
    ctx.globalAlpha = 1;

    if(state.phase === "closeup" || state.phase === "aftermath"){
      drawCloseup();
      return;
    }

    const cx = W/2, cy = H/2;

    ctx.globalAlpha = 0.10;
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, cy+80, W, 1);
    ctx.globalAlpha = 1;

    function toScreen(wx, wy){
      return { x: cx + wx, y: cy + wy };
    }

    const p = toScreen(state.player.x, state.player.y);
    ctx.fillStyle = "rgba(255,255,255,.55)";
    ctx.beginPath();
    ctx.arc(p.x, p.y, 3, 0, Math.PI*2);
    ctx.fill();

    const n = toScreen(state.npc.x, state.npc.y);
    const dist = Math.hypot(state.player.x - state.npc.x, state.player.y - state.npc.y);
    const s = Math.max(0.20, Math.min(1.0, 240/(dist+1)));

    drawNPC(n.x, n.y, 26*s);

    ctx.globalAlpha = 0.35;
    radial(cx, cy, Math.max(W,H)*0.9, "rgba(0,0,0,0)", "rgba(0,0,0,.85)");
    ctx.globalAlpha = 1;
  }

  function radial(x,y,r, c0, c1){
    const g = ctx.createRadialGradient(x,y, 0, x,y, r);
    g.addColorStop(0, c0);
    g.addColorStop(1, c1);
    ctx.fillStyle = g;
    ctx.fillRect(0,0,innerWidth,innerHeight);
  }

  function drawNPC(x,y, size){
    ctx.save();
    ctx.translate(x,y);

    ctx.globalAlpha = 0.95;

    ctx.fillStyle = "rgba(255,255,255,.22)";
    roundRect(-size*0.35, -size*0.10, size*0.70, size*0.85, size*0.18);
    ctx.fill();

    ctx.fillStyle = "rgba(255,255,255,.18)";
    ctx.beginPath();
    ctx.arc(0, -size*0.40, size*0.32, 0, Math.PI*2);
    ctx.fill();

    ctx.globalAlpha = 0.25;
    ctx.fillStyle = "rgba(138,46,255,.55)";
    ctx.beginPath(); ctx.arc(-size*0.10, -size*0.43, size*0.05, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc( size*0.10, -size*0.43, size*0.05, 0, Math.PI*2); ctx.fill();

    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function roundRect(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y, x+w,y+h, r);
    ctx.arcTo(x+w,y+h, x,y+h, r);
    ctx.arcTo(x,y+h, x,y, r);
    ctx.arcTo(x,y, x+w,y, r);
    ctx.closePath();
  }

  // "More realistic" close-up: shading + grain + glass distortion + end-only terror
  function drawCloseup(){
    const W = innerWidth, H = innerHeight;
    const p = state.closeupProgress;

    // Base void
    ctx.fillStyle = "#010105";
    ctx.fillRect(0,0,W,H);

    // Stronger end-only violet/white pressure
    ctx.globalAlpha = 0.18 + p*0.20;
    radial(W*0.52, H*0.45, Math.max(W,H)*0.85, "rgba(138,46,255,.30)", "rgba(0,0,0,0)");
    ctx.globalAlpha = 1;

    // Face scale ramps: calm early, terrifying final surge
    const base = 0.22;
    const surge = (p > 0.86) ? Math.pow((p-0.86)/0.14, 1.4) : 0;
    const scale = base + p * 1.55 + surge * 1.45; // fills screen at end
    const faceW = Math.min(W*1.45, 560) * scale;
    const faceH = faceW * 1.17;

    // slight jitter end-only
    const jit = (p > 0.88) ? (Math.random()*2 - 1) * (p*6) : 0;
    const fx = W/2 + jit;
    const fy = H/2 + (1-p)*40 + (p>0.9 ? (Math.random()*2-1)*2 : 0);

    // Shadow + depth
    ctx.globalAlpha = 0.55;
    ctx.fillStyle = "rgba(0,0,0,.90)";
    ctx.beginPath();
    ctx.ellipse(fx, fy+faceH*0.18, faceW*0.58, faceH*0.60, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // Face base (skin)
    const skinA = 0.10 + p*0.22;
    ctx.fillStyle = `rgba(255,255,255,${skinA.toFixed(3)})`;
    ctx.beginPath();
    ctx.ellipse(fx, fy, faceW*0.50, faceH*0.55, 0, 0, Math.PI*2);
    ctx.fill();

    // Cheek pressure line at high p
    if(p > 0.55){
      ctx.globalAlpha = 0.35 + p*0.10;
      ctx.strokeStyle = "rgba(255,255,255,.20)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.ellipse(fx, fy, faceW*0.515, faceH*0.565, 0, 0, Math.PI*2);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    // Shading: under eyes, nose, jaw
    ctx.globalAlpha = 0.24 + p*0.12;
    radial(fx, fy - faceH*0.06, faceW*0.55, "rgba(0,0,0,.00)", "rgba(0,0,0,.78)");
    ctx.globalAlpha = 1;

    // Eyes become “real” late, then terrifying
    const eyeAlpha = Math.min(1, Math.max(0, (p - 0.18) / 0.55));
    const terror = Math.min(1, Math.max(0, (p - 0.86) / 0.14));

    ctx.globalAlpha = 0.10 + eyeAlpha*0.90;

    // whites
    ctx.fillStyle = "rgba(255,255,255,.28)";
    ctx.beginPath();
    ctx.ellipse(fx - faceW*0.18, fy - faceH*0.12, faceW*0.12, faceH*0.09, 0, 0, Math.PI*2);
    ctx.ellipse(fx + faceW*0.18, fy - faceH*0.12, faceW*0.12, faceH*0.09, 0, 0, Math.PI*2);
    ctx.fill();

    // veins (subtle but creepy)
    if(p > 0.72){
      ctx.globalAlpha = 0.12 + terror*0.18;
      ctx.strokeStyle = "rgba(255,42,42,.35)";
      ctx.lineWidth = 1;
      for(let i=0;i<6;i++){
        const ex = (i%2 ? 1 : -1) * faceW*0.18;
        ctx.beginPath();
        ctx.moveTo(fx+ex - faceW*0.06, fy-faceH*0.12);
        ctx.lineTo(fx+ex - faceW*0.10, fy-faceH*(0.18 + Math.random()*0.06));
        ctx.lineTo(fx+ex - faceW*(0.14 + Math.random()*0.05), fy-faceH*(0.12 + Math.random()*0.08));
        ctx.stroke();
      }
      ctx.globalAlpha = 0.10 + eyeAlpha*0.90;
    }

    // pupils: widen and lock dead-center
    const pupilW = faceW*(0.030 + terror*0.020);
    const pupilH = faceH*(0.050 + terror*0.025);

    // iris ring
    ctx.globalAlpha = 0.26 + terror*0.35;
    ctx.fillStyle = "rgba(0,0,0,.55)";
    ctx.beginPath();
    ctx.ellipse(fx - faceW*0.18, fy - faceH*0.12, faceW*0.055, faceH*0.065, 0, 0, Math.PI*2);
    ctx.ellipse(fx + faceW*0.18, fy - faceH*0.12, faceW*0.055, faceH*0.065, 0, 0, Math.PI*2);
    ctx.fill();

    // pupils
    ctx.globalAlpha = 0.50 + terror*0.45;
    ctx.fillStyle = "rgba(0,0,0,.95)";
    ctx.beginPath();
    ctx.ellipse(fx - faceW*0.18, fy - faceH*0.12, pupilW, pupilH, 0, 0, Math.PI*2);
    ctx.ellipse(fx + faceW*0.18, fy - faceH*0.12, pupilW, pupilH, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // Mouth: becomes a screaming oval late (teeth hints)
    const mouthY = fy + faceH*(0.20 + p*0.06);
    if(p < 0.55){
      ctx.globalAlpha = 0.22 + p*0.55;
      ctx.strokeStyle = "rgba(0,0,0,.70)";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.ellipse(fx, mouthY, faceW*0.12, faceH*0.045, 0, 0, Math.PI);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }else{
      const open = 0.55 + (p-0.55)*1.1 + terror*0.45;
      const mw = faceW*(0.13 + open*0.10);
      const mh = faceH*(0.07 + open*0.14);

      // mouth cavity
      ctx.globalAlpha = 0.75;
      ctx.fillStyle = "rgba(0,0,0,.88)";
      ctx.beginPath();
      ctx.ellipse(fx, mouthY, mw, mh, 0, 0, Math.PI*2);
      ctx.fill();

      // teeth bands (hint, no gore)
      ctx.globalAlpha = 0.42 + terror*0.20;
      ctx.fillStyle = "rgba(255,255,255,.35)";
      ctx.beginPath();
      ctx.ellipse(fx, mouthY - mh*0.45, mw*0.92, mh*0.28, 0, 0, Math.PI);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(fx, mouthY + mh*0.55, mw*0.85, mh*0.24, 0, 0, Math.PI);
      ctx.fill();

      // teeth separations
      ctx.globalAlpha = 0.18 + terror*0.18;
      ctx.strokeStyle = "rgba(0,0,0,.45)";
      ctx.lineWidth = 1;
      for(let i=-5;i<=5;i++){
        const tx = fx + (i/5)*mw*0.65;
        ctx.beginPath();
        ctx.moveTo(tx, mouthY - mh*0.72);
        ctx.lineTo(tx, mouthY - mh*0.22);
        ctx.stroke();
      }

      ctx.globalAlpha = 1;
    }

    // Hands banging on glass
    const bangActive = (state.phase === "closeup" && state.bangsLeft < 9) ? (1 - (state.bangTimer / 0.55)) : 0;
    if(state.phase === "closeup" && bangActive > 0){
      const k = Math.max(0, Math.min(1, bangActive));
      drawHand(fx - faceW*0.50, fy + faceH*0.02, faceW*0.30, k);
      drawHand(fx + faceW*0.50, fy + faceH*0.02, faceW*0.30, k);
    }

    // Glass texture scratches (end-only stronger)
    if(p > 0.72){
      ctx.globalAlpha = 0.16 + terror*0.25;
      ctx.strokeStyle = "rgba(255,255,255,.22)";
      ctx.lineWidth = 1;
      for(let i=0;i<12;i++){
        const x = (i/12)*W + (Math.sin(performance.now()/520 + i)*16);
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x + 60, H);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
    }

    // Grain overlay for realism (end-only heavier)
    drawGrain(0.06 + terror*0.12);

    // Vignette clamps it into a “screen”
    ctx.globalAlpha = 0.62;
    radial(W/2, H/2, Math.max(W,H)*0.85, "rgba(0,0,0,0)", "rgba(0,0,0,.94)");
    ctx.globalAlpha = 1;

    // End-only chromatic glitch swipe
    if(terror > 0.35){
      ctx.globalAlpha = 0.10 + terror*0.18;
      ctx.fillStyle = "rgba(255,255,255,.10)";
      const y = (Math.sin(performance.now()/120) * 0.5 + 0.5) * H;
      ctx.fillRect(0, y, W, 3 + terror*8);
      ctx.globalAlpha = 1;
    }
  }

  function drawHand(x, y, size, k){
    ctx.save();
    ctx.translate(x,y);
    ctx.globalAlpha = 0.18 + k*0.32;
    ctx.fillStyle = "rgba(255,255,255,.22)";
    ctx.strokeStyle = "rgba(255,255,255,.12)";
    ctx.lineWidth = 2;

    ctx.beginPath();
    ctx.ellipse(0, 0, size*0.32, size*0.28, 0, 0, Math.PI*2);
    ctx.fill();

    for(let i=-2;i<=2;i++){
      ctx.beginPath();
      ctx.ellipse(i*size*0.10, -size*0.30, size*0.07, size*0.18, 0, 0, Math.PI*2);
      ctx.fill();
    }

    ctx.globalAlpha *= 0.75;
    for(let j=0;j<4;j++){
      ctx.beginPath();
      ctx.moveTo(-size*0.25 + j*size*0.12, size*0.18);
      ctx.lineTo(-size*0.10 + j*size*0.12, size*0.46);
      ctx.stroke();
    }

    ctx.restore();
    ctx.globalAlpha = 1;
  }

  // Simple grain (fast): draw random speckles each frame
  function drawGrain(amount){
    if(amount <= 0) return;
    const W = innerWidth, H = innerHeight;
    const count = Math.floor(600 + amount*1400);
    ctx.globalAlpha = Math.min(0.35, amount);
    for(let i=0;i<count;i++){
      const x = Math.random()*W;
      const y = Math.random()*H;
      const a = Math.random()*0.9;
      ctx.fillStyle = `rgba(255,255,255,${(0.08*a).toFixed(3)})`;
      ctx.fillRect(x, y, 1, 1);
    }
    ctx.globalAlpha = 1;
  }

  // ====== Start sequence ======
  intro();

  setTimeout(() => {
    if(!codeShown){
      convo.push("");
      convo.push("…");
      convo.push("type something");
      renderTerminal();
    }
  }, 12000);

})();
</script>
</body>
</html>
