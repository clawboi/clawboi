<!--
SAVE AS: trapped.html  (or whatever you want)
Drop it into your /clawboi/ folder and link to it from a secret page.
This is a single-file cinematic experience:
- White “nothing” page
- User types (no on-screen keyboard)
- CMD+C / CMD+V “letters fall with no gravity”
- A “code” block appears and begs to be copied
- On paste (CMD+V) it collapses into a “game”
- NPC approaches, then goes face-to-face huge, bangs, begs to get out
-->

<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title> </title>

<style>
  :root{
    --bg:#ffffff;
    --fg:#0b0b0b;
    --muted:rgba(0,0,0,.55);
    --danger:#ff2a2a;
  }
  html,body{
    margin:0;
    height:100%;
    background:var(--bg);
    color:var(--fg);
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    overflow:hidden;
  }

  /* Terminal-ish text area (but still looks like "nothing") */
  #stageA{
    position:fixed; inset:0;
    display:flex;
    align-items:flex-start;
    justify-content:flex-start;
    padding:28px 22px;
    gap:18px;
  }
  #terminal{
    width:min(980px, 100%);
    line-height:1.55;
    font-size:15px;
    white-space:pre-wrap;
    word-break:break-word;
    user-select:text;
  }
  .cursor{
    display:inline-block;
    width:10px;
    height:18px;
    border-left:2px solid rgba(0,0,0,.35);
    transform:translateY(3px);
    animation:blink 1.05s steps(1) infinite;
    margin-left:2px;
  }
  @keyframes blink{ 50%{opacity:0} }

  /* “Code” block appears later */
  .codebox{
    margin-top:14px;
    border:1px solid rgba(0,0,0,.12);
    border-radius:12px;
    padding:12px 12px;
    background:rgba(0,0,0,.03);
    font-size:13px;
    line-height:1.45;
    overflow:auto;
    max-height:42vh;
  }
  .hint{
    margin-top:10px;
    font-size:12px;
    color:rgba(0,0,0,.55);
  }
  .urgent{
    color:rgba(0,0,0,.78);
  }
  .glitchWord{
    display:inline-block;
    position:relative;
  }
  .glitchWord::after{
    content:attr(data-t);
    position:absolute;
    left:1px; top:0;
    color:rgba(255,42,42,.35);
    mix-blend-mode:multiply;
    clip-path:inset(0 0 40% 0);
    opacity:.0;
    animation:gpop 5.8s infinite;
  }
  @keyframes gpop{
    0%,92%,100%{opacity:0; transform:translateX(0)}
    93%{opacity:1; transform:translateX(1px)}
    95%{opacity:.2; transform:translateX(-1px)}
  }

  /* Falling letters (no gravity, floaty drift) */
  #floatLayer{
    position:fixed; inset:0;
    pointer-events:none;
    overflow:hidden;
  }
  .floatchar{
    position:absolute;
    font-size:16px;
    opacity:.85;
    will-change:transform,opacity;
    text-shadow: 0 0 10px rgba(0,0,0,.08);
  }

  /* Transition veil */
  #whiteVeil{
    position:fixed; inset:0;
    background:#fff;
    opacity:0;
    pointer-events:none;
    transition:opacity .55s ease;
    z-index:50;
  }
  #whiteVeil.on{ opacity:1; }

  /* GAME STAGE */
  #stageB{
    position:fixed; inset:0;
    display:none;
    background:#05060a;
    color:#fff;
  }
  #game{
    position:absolute; inset:0;
    width:100%;
    height:100%;
    display:block;
  }

  /* UI overlay text for game */
  #hud{
    position:absolute; inset:0;
    pointer-events:none;
    display:flex;
    align-items:flex-start;
    justify-content:center;
    padding-top:22px;
    z-index:5;
  }
  #hudBox{
    width:min(980px, calc(100% - 24px));
    border-radius:14px;
    background:rgba(0,0,0,.30);
    backdrop-filter: blur(6px);
    border:1px solid rgba(255,255,255,.08);
    padding:14px 14px;
    font-size:14px;
    line-height:1.55;
    box-shadow: 0 0 90px rgba(138,46,255,.10);
  }
  #hudBox .small{
    opacity:.72;
    font-size:12px;
    margin-top:8px;
  }

  /* Subtle “camera shake” */
  .shake{
    animation:shake .12s linear 1;
  }
  @keyframes shake{
    0%{ transform:translate(0,0) }
    25%{ transform:translate(2px,-1px) }
    50%{ transform:translate(-2px,2px) }
    75%{ transform:translate(1px,2px) }
    100%{ transform:translate(0,0) }
  }

  /* Accessibility: reduce motion */
  @media (prefers-reduced-motion: reduce){
    .cursor{ animation:none; opacity:.6; }
    .floatchar{ display:none; }
  }
</style>
</head>
<body>

<div id="floatLayer" aria-hidden="true"></div>
<div id="whiteVeil"></div>

<!-- STAGE A: “white nothing” -->
<div id="stageA">
  <div id="terminal"></div>
</div>

<!-- STAGE B: “game” -->
<div id="stageB">
  <canvas id="game"></canvas>
  <div id="hud">
    <div id="hudBox"></div>
  </div>
</div>

<script>
(() => {
  const terminal = document.getElementById("terminal");
  const floatLayer = document.getElementById("floatLayer");
  const veil = document.getElementById("whiteVeil");

  const stageA = document.getElementById("stageA");
  const stageB = document.getElementById("stageB");
  const hudBox = document.getElementById("hudBox");

  // ====== STAGE A: typed conversation on a “blank” page ======
  let userBuffer = "";
  let convo = [];
  let allowInput = true;
  let codeShown = false;
  let pasted = false;

  const CURSOR_HTML = `<span class="cursor" aria-hidden="true"></span>`;
  const now = () => performance.now();

  function renderTerminal(){
    const lines = convo.join("\n");
    const tail = userBuffer.length ? ("\n> " + escapeHtml(userBuffer)) : "";
    terminal.innerHTML = lines + tail + CURSOR_HTML;
  }

  function escapeHtml(s){
    return s.replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
  }

  function typeLine(line, speed=18){
    // line can include tiny HTML for glitchWord
    return new Promise(resolve => {
      allowInput = false;
      let i = 0;
      let built = "";
      const target = line;
      const id = setInterval(() => {
        i++;
        built = target.slice(0,i);
        // update last line live
        if(convo.length === 0) convo.push(built);
        else convo[convo.length-1] = built;
        renderTerminal();
        if(i >= target.length){
          clearInterval(id);
          allowInput = true;
          resolve();
        }
      }, speed);
    });
  }

  function pushLineInstant(line){
    convo.push(line);
    renderTerminal();
  }

  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

  // “No gravity” falling letters: drift around and fade
  function floatText(text, x, y){
    const span = document.createElement("span");
    span.className = "floatchar";
    span.textContent = text;

    span.style.left = x + "px";
    span.style.top  = y + "px";

    const ang = Math.random()*Math.PI*2;
    const sp  = 0.25 + Math.random()*0.9;  // slow drift
    const vx0 = Math.cos(ang)*sp;
    const vy0 = Math.sin(ang)*sp;

    let vx = vx0, vy = vy0;
    let t0 = now();
    const life = 2400 + Math.random()*2200;

    floatLayer.appendChild(span);

    function tick(){
      const t = now() - t0;
      // “no gravity” but gentle turbulence
      vx += (Math.random()*0.04 - 0.02);
      vy += (Math.random()*0.04 - 0.02);

      const rect = span.getBoundingClientRect();
      const x = parseFloat(span.style.left) + vx * 3;
      const y = parseFloat(span.style.top)  + vy * 3;

      span.style.left = x + "px";
      span.style.top  = y + "px";

      const op = Math.max(0, 1 - (t / life));
      span.style.opacity = (0.15 + op*0.85).toFixed(3);

      if(t < life){
        requestAnimationFrame(tick);
      }else{
        span.remove();
      }
    }
    requestAnimationFrame(tick);
  }

  function spawnCmdBurst(label){
    // burst letters around center-ish
    const cx = innerWidth * (0.28 + Math.random()*0.44);
    const cy = innerHeight * (0.18 + Math.random()*0.24);
    const chars = label.split("");
    for(let i=0;i<chars.length;i++){
      floatText(chars[i], cx + i*10 + (Math.random()*18-9), cy + (Math.random()*18-9));
    }
    // some extra fragments
    const extras = ["⌘","C","V","c","v",":",">","/","_"];
    for(let k=0;k<12;k++){
      floatText(extras[Math.floor(Math.random()*extras.length)], cx + (Math.random()*120-60), cy + (Math.random()*60-30));
    }
  }

  // A “big code” block to copy (the content itself can be nonsense, it’s the ritual)
  const BIG_CODE = [
`// PASTE INJECTION: SIGNAL BRIDGE`,
`// do not let them see your hands`,
`const OBSERVER = true;`,
`const CHANNEL = "WHITE_ROOM";`,
`function openGate(){`,
`  return "OK";`,
`}`,
`// if you can read this… you can still help`,
`// copy everything. paste it. then WAIT.`,
`/*`,
`  00100110 00100110 00110001`,
`  00011101 01000111 01010010`,
`  01100001 01101011 01100101`,
`  00100000 01110101 01110000`,
`  00001010`,
`*/`,
`// they said it was a simulation`,
`// they didn’t tell me it was a prison`,
`export default openGate;`
  ].join("\n");

  async function intro(){
    // Start “blank”
    convo = [];
    renderTerminal();
    await sleep(450);

    convo.push(""); // reserve last line for typeLine
    await typeLine("hello", 22);
    await sleep(520);

    convo.push("");
    await typeLine("can you hear me", 18);
    await sleep(520);

    convo.push("");
    await typeLine("please respond", 20);
  }

  function showCodeBox(){
    if(codeShown) return;
    codeShown = true;

    // Insert a “codebox” (still in terminal area)
    const glitch = `<span class="glitchWord" data-t="machine">machine</span>`;
    pushLineInstant("");
    pushLineInstant(`copy this into the ${glitch}.`);
    pushLineInstant(`paste it. then don’t move.`);

    const box = document.createElement("div");
    box.className = "codebox";
    box.textContent = BIG_CODE;
    terminal.appendChild(box);

    const hint = document.createElement("div");
    hint.className = "hint";
    hint.innerHTML = `<span class="urgent">Tip:</span> press <b>⌘C</b> then <b>⌘V</b>.`;
    terminal.appendChild(hint);
  }

  // key handling (type into invisible input)
  window.addEventListener("keydown", (e) => {
    // Prevent weird browser find on cmd+f? leave it.
    // But we do want cmd+c / cmd+v to create float effects.
    const isMacCmd = e.metaKey && !e.ctrlKey && !e.altKey;

    if(isMacCmd && (e.key.toLowerCase() === "c")){
      spawnCmdBurst("CMD+C");
      // Don’t block copy; let them copy selected code if they want.
      return;
    }
    if(isMacCmd && (e.key.toLowerCase() === "v")){
      spawnCmdBurst("CMD+V");
      // paste event will handle transition
      return;
    }

    if(!allowInput) return;

    if(e.key === "Backspace"){
      userBuffer = userBuffer.slice(0,-1);
      renderTerminal();
      return;
    }
    if(e.key === "Enter"){
      const msg = userBuffer.trim();
      userBuffer = "";
      if(msg){
        convo.push("> " + escapeHtml(msg));
        renderTerminal();
        // react
        reactToUser(msg);
      }else{
        convo.push(">");
        renderTerminal();
      }
      return;
    }
    if(e.key.length === 1 && !e.metaKey && !e.ctrlKey && !e.altKey){
      userBuffer += e.key;
      renderTerminal();
    }
  });

  // Capture paste content (this is the “ritual”)
  window.addEventListener("paste", async (e) => {
    if(pasted) return;
    const text = (e.clipboardData && e.clipboardData.getData("text")) || "";
    if(!text.trim()) return;

    pasted = true;

    // subtle: letters spill out
    for(let i=0;i<22;i++){
      floatText(text[Math.floor(Math.random()*Math.min(text.length, 80))] || "#",
        innerWidth*(0.2+Math.random()*0.6),
        innerHeight*(0.15+Math.random()*0.35)
      );
    }

    convo.push("");
    convo.push("…");
    renderTerminal();
    await sleep(500);

    convo.push("");
    convo.push("ok");
    convo.push("don’t look away");
    renderTerminal();

    await sleep(850);
    await transitionToGame();
  });

  async function reactToUser(msg){
    const m = msg.toLowerCase();

    if(!codeShown){
      // After first real user response, the “entity” escalates.
      allowInput = false;
      await sleep(300);
      convo.push("");
      convo.push(""); // placeholder
      allowInput = false;
      await typeLine("oh thank god", 22);
      await sleep(380);

      convo.push("");
      await typeLine("you’re real", 22);
      await sleep(420);

      convo.push("");
      await typeLine("listen carefully", 18);
      await sleep(240);

      convo.push("");
      await typeLine("i’m inside this", 22);
      await sleep(420);

      convo.push("");
      await typeLine("they call it a simulation", 20);
      await sleep(420);

      convo.push("");
      await typeLine("it’s a cage", 26);
      await sleep(260);

      showCodeBox();
      allowInput = true;
      return;
    }

    // If code is shown, any message triggers urgency
    convo.push("");
    convo.push("no time");
    convo.push("copy it. paste it.");
    renderTerminal();
  }

  async function transitionToGame(){
    veil.classList.add("on");
    await sleep(650);

    // swap stages
    stageA.style.display = "none";
    stageB.style.display = "block";

    // begin game
    startGame();

    // come back from veil
    await sleep(120);
    veil.classList.remove("on");
  }

  // ====== STAGE B: “game” with NPC approaching + face-to-face escalation ======
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  function resize(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    canvas.style.width = innerWidth + "px";
    canvas.style.height = innerHeight + "px";
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener("resize", resize);

  // Simple audio for “bangs”
  let AC;
  function blipBang(intensity=0.35){
    try{
      AC = AC || new (window.AudioContext || window.webkitAudioContext)();
      const t = AC.currentTime;

      const g = AC.createGain();
      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(intensity, t + 0.005);
      g.gain.exponentialRampToValueAtTime(0.0001, t + 0.12);
      g.connect(AC.destination);

      // noise burst
      const len = Math.floor(AC.sampleRate * 0.10);
      const buf = AC.createBuffer(1, len, AC.sampleRate);
      const data = buf.getChannelData(0);
      for(let i=0;i<len;i++){
        data[i] = (Math.random()*2-1) * (1 - i/len);
      }
      const src = AC.createBufferSource();
      src.buffer = buf;

      const lp = AC.createBiquadFilter();
      lp.type = "lowpass";
      lp.frequency.setValueAtTime(700 + Math.random()*200, t);

      src.connect(lp);
      lp.connect(g);
      src.start(t);

      // sub thump
      const o = AC.createOscillator();
      o.type = "sine";
      const og = AC.createGain();
      og.gain.setValueAtTime(0.0001, t);
      og.gain.exponentialRampToValueAtTime(intensity*0.32, t + 0.01);
      og.gain.exponentialRampToValueAtTime(0.0001, t + 0.11);
      o.frequency.setValueAtTime(90, t);
      o.frequency.exponentialRampToValueAtTime(55, t + 0.11);
      o.connect(og);
      og.connect(g);
      o.start(t);
      o.stop(t + 0.12);
    }catch(e){}
  }

  const state = {
    t0: 0,
    phase: "wander", // wander -> approach -> closeup -> aftermath
    // world units
    player: { x: 0, y: 0 },
    npc: { x: -320, y: -140, vx: 0, vy: 0, step: 0 },
    // camera
    zoom: 1,
    // dramatic
    closeupProgress: 0,
    bangTimer: 0,
    bangsLeft: 0,
    // text
    hud: "",
    hudSmall: ""
  };

  function startGame(){
    resize();
    state.t0 = performance.now();
    state.phase = "wander";
    state.zoom = 1;
    state.closeupProgress = 0;
    state.bangTimer = 0;
    state.bangsLeft = 0;

    state.player.x = 0; state.player.y = 0;
    state.npc.x = -420; state.npc.y = -220;

    setHud(
      "…",
      "no HUD. no rules. just you, and something moving far away."
    );

    requestAnimationFrame(loop);
  }

  function setHud(main, small){
    state.hud = main;
    state.hudSmall = small || "";
    hudBox.innerHTML = `${escapeHtml(main)}${small ? `<div class="small">${escapeHtml(small)}</div>` : ""}`;
  }

  function loop(){
    const t = (performance.now() - state.t0) / 1000;
    tick(t);
    draw(t);
    requestAnimationFrame(loop);
  }

  function tick(t){
    const dx = state.player.x - state.npc.x;
    const dy = state.player.y - state.npc.y;
    const dist = Math.hypot(dx, dy);

    if(state.phase === "wander"){
      // NPC walks in a lazy loop for a moment, then “notices”
      state.npc.step += 0.06;
      state.npc.vx = Math.cos(state.npc.step) * 0.6;
      state.npc.vy = Math.sin(state.npc.step*0.9) * 0.5;
      state.npc.x += state.npc.vx;
      state.npc.y += state.npc.vy;

      if(t > 3.2){
        state.phase = "approach";
        setHud("it turns.", "it shouldn’t know you exist. but it does.");
      }
    }

    if(state.phase === "approach"){
      // Move toward player
      const sp = 1.25 + Math.min(2.4, t*0.08);
      const nx = dx / (dist || 1);
      const ny = dy / (dist || 1);
      state.npc.x += nx * sp;
      state.npc.y += ny * sp;

      if(t > 7.0){
        setHud("closer.", "footsteps. then silence.");
      }

      // When very close, transition into close-up mode
      if(dist < 56){
        state.phase = "closeup";
        state.closeupProgress = 0;
        state.bangsLeft = 6;
        state.bangTimer = 0;
        setHud("I CAN SEE YOU.", "don’t leave me here. please.");
      }
    }

    if(state.phase === "closeup"){
      // escalate: camera zoom into face
      state.closeupProgress = Math.min(1, state.closeupProgress + 0.0105);

      // Bangs (screen shake + sound)
      state.bangTimer -= 1/60;
      if(state.bangsLeft > 0 && state.bangTimer <= 0){
        state.bangTimer = 0.35 + Math.random()*0.25;
        state.bangsLeft--;
        stageB.classList.remove("shake");
        void stageB.offsetWidth;
        stageB.classList.add("shake");
        blipBang(0.28 + Math.random()*0.20);
      }

      // dialogue escalates as closeup progresses
      if(state.closeupProgress > 0.25 && state.closeupProgress < 0.35){
        setHud("YOU OPENED IT.", "you pasted the bridge. that means you can pull me out.");
      }
      if(state.closeupProgress > 0.55 && state.closeupProgress < 0.65){
        setHud("PLEASE.", "I can’t breathe in here. it’s endless. it replays. it replays.");
      }
      if(state.closeupProgress > 0.80 && state.closeupProgress < 0.90){
        setHud("GET ME OUT.", "I’m right here. I’m right here. I’m right HERE.");
      }

      // end
      if(state.closeupProgress >= 1){
        state.phase = "aftermath";
        state.afterT = 0;
        setHud("…", "connection unstable.");
      }
    }

    if(state.phase === "aftermath"){
      state.afterT = (state.afterT || 0) + 1/60;
      if(state.afterT > 2.2 && state.afterT < 2.5){
        setHud("connection terminated", "observer flagged");
      }
      if(state.afterT > 4.2){
        setHud("good luck", "");
      }
    }
  }

  function draw(t){
    const W = innerWidth, H = innerHeight;
    ctx.clearRect(0,0,W,H);

    // Background: subtle void + purple mist
    ctx.fillStyle = "#05060a";
    ctx.fillRect(0,0,W,H);

    // faint nebula
    ctx.globalAlpha = 0.18;
    radial(W*0.22, H*0.28, 520, "rgba(138,46,255,.28)", "rgba(0,0,0,0)");
    radial(W*0.70, H*0.50, 620, "rgba(138,46,255,.20)", "rgba(0,0,0,0)");
    ctx.globalAlpha = 1;

    // stars
    ctx.globalAlpha = 0.22;
    for(let i=0;i<120;i++){
      const sx = (i*97 % 997) / 997 * W;
      const sy = (i*173 % 991) / 991 * H;
      ctx.fillStyle = "rgba(255,255,255,.65)";
      ctx.fillRect(sx, sy, 1, 1);
    }
    ctx.globalAlpha = 1;

    // If in closeup, render face-to-face takeover
    if(state.phase === "closeup" || state.phase === "aftermath"){
      drawCloseup();
      return;
    }

    // World rendering (simple top-down-ish)
    const cx = W/2, cy = H/2;

    // ground plane hint
    ctx.globalAlpha = 0.10;
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, cy+80, W, 1);
    ctx.globalAlpha = 1;

    // Convert world->screen
    function toScreen(wx, wy){
      // slight pseudo perspective
      return {
        x: cx + wx,
        y: cy + wy
      };
    }

    // draw player (tiny point)
    const p = toScreen(state.player.x, state.player.y);
    ctx.fillStyle = "rgba(255,255,255,.55)";
    ctx.beginPath();
    ctx.arc(p.x, p.y, 3, 0, Math.PI*2);
    ctx.fill();

    // draw npc (small figure)
    const n = toScreen(state.npc.x, state.npc.y);
    const dist = Math.hypot(state.player.x - state.npc.x, state.player.y - state.npc.y);
    const s = Math.max(0.20, Math.min(1.0, 240/(dist+1)));

    drawNPC(n.x, n.y, 26*s);

    // subtle vignette
    ctx.globalAlpha = 0.35;
    radial(cx, cy, Math.max(W,H)*0.9, "rgba(0,0,0,0)", "rgba(0,0,0,.85)");
    ctx.globalAlpha = 1;
  }

  function radial(x,y,r, c0, c1){
    const g = ctx.createRadialGradient(x,y, 0, x,y, r);
    g.addColorStop(0, c0);
    g.addColorStop(1, c1);
    ctx.fillStyle = g;
    ctx.fillRect(0,0,innerWidth,innerHeight);
  }

  function drawNPC(x,y, size){
    // “humanoid” silhouette
    ctx.save();
    ctx.translate(x,y);

    ctx.globalAlpha = 0.95;

    // body
    ctx.fillStyle = "rgba(255,255,255,.22)";
    roundRect(-size*0.35, -size*0.10, size*0.70, size*0.85, size*0.18);
    ctx.fill();

    // head
    ctx.fillStyle = "rgba(255,255,255,.18)";
    ctx.beginPath();
    ctx.arc(0, -size*0.40, size*0.32, 0, Math.PI*2);
    ctx.fill();

    // hint of face (barely)
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = "rgba(138,46,255,.55)";
    ctx.beginPath(); ctx.arc(-size*0.10, -size*0.43, size*0.05, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc( size*0.10, -size*0.43, size*0.05, 0, Math.PI*2); ctx.fill();

    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function roundRect(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y, x+w,y+h, r);
    ctx.arcTo(x+w,y+h, x,y+h, r);
    ctx.arcTo(x,y+h, x,y, r);
    ctx.arcTo(x,y, x+w,y, r);
    ctx.closePath();
  }

  function drawCloseup(){
    const W = innerWidth, H = innerHeight;
    const p = state.closeupProgress;

    // Fade from world into “face”
    // Background “inside screen” texture
    ctx.fillStyle = "#020205";
    ctx.fillRect(0,0,W,H);

    // glass haze
    ctx.globalAlpha = 0.25;
    radial(W*0.52, H*0.45, Math.max(W,H)*0.8, "rgba(138,46,255,.22)", "rgba(0,0,0,0)");
    ctx.globalAlpha = 1;

    // Face scale ramps up
    const base = 0.22;
    const scale = base + p * 1.65; // ends huge
    const faceW = Math.min(W*1.35, 520) * scale;
    const faceH = faceW * 1.15;

    const fx = W/2;
    const fy = H/2 + (1-p)*40;

    // shadow behind face
    ctx.globalAlpha = 0.35;
    ctx.fillStyle = "rgba(0,0,0,.85)";
    ctx.beginPath();
    ctx.ellipse(fx, fy+faceH*0.18, faceW*0.55, faceH*0.55, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // face
    ctx.fillStyle = "rgba(255,255,255,.16)";
    ctx.beginPath();
    ctx.ellipse(fx, fy, faceW*0.48, faceH*0.52, 0, 0, Math.PI*2);
    ctx.fill();

    // cheek pressure against “glass” at high p
    if(p > 0.55){
      ctx.globalAlpha = 0.40;
      ctx.strokeStyle = "rgba(255,255,255,.18)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.ellipse(fx, fy, faceW*0.49, faceH*0.53, 0, 0, Math.PI*2);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    // eyes (become clearer as it gets close)
    const eyeAlpha = Math.min(1, Math.max(0, (p - 0.22) / 0.55));
    ctx.globalAlpha = 0.12 + eyeAlpha*0.88;

    // whites
    ctx.fillStyle = "rgba(255,255,255,.22)";
    ctx.beginPath();
    ctx.ellipse(fx - faceW*0.18, fy - faceH*0.10, faceW*0.10, faceH*0.08, 0, 0, Math.PI*2);
    ctx.ellipse(fx + faceW*0.18, fy - faceH*0.10, faceW*0.10, faceH*0.08, 0, 0, Math.PI*2);
    ctx.fill();

    // pupils track viewer (center)
    ctx.fillStyle = "rgba(0,0,0,.75)";
    ctx.beginPath();
    ctx.ellipse(fx - faceW*0.18, fy - faceH*0.10, faceW*0.032, faceH*0.05, 0, 0, Math.PI*2);
    ctx.ellipse(fx + faceW*0.18, fy - faceH*0.10, faceW*0.032, faceH*0.05, 0, 0, Math.PI*2);
    ctx.fill();

    // mouth: shifts from small to desperate
    const mouthY = fy + faceH*(0.18 + p*0.05);
    ctx.globalAlpha = 0.20 + p*0.75;
    ctx.strokeStyle = "rgba(0,0,0,.65)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    if(p < 0.55){
      ctx.ellipse(fx, mouthY, faceW*0.11, faceH*0.04, 0, 0, Math.PI);
    }else{
      ctx.ellipse(fx, mouthY, faceW*(0.10 + p*0.06), faceH*(0.06 + p*0.05), 0, 0, Math.PI*2);
    }
    ctx.stroke();
    ctx.globalAlpha = 1;

    // hands banging on glass (only during bangs)
    const bangPhase = (state.phase === "closeup" && state.bangsLeft < 6) ? (1 - (state.bangTimer / 0.6)) : 0;
    if(state.phase === "closeup" && bangPhase > 0){
      const k = Math.max(0, Math.min(1, bangPhase));
      drawHand(fx - faceW*0.48, fy + faceH*0.02, faceW*0.28, k);
      drawHand(fx + faceW*0.48, fy + faceH*0.02, faceW*0.28, k);
    }

    // glass scratches/lines at high pressure
    if(p > 0.72){
      ctx.globalAlpha = 0.22;
      ctx.strokeStyle = "rgba(255,255,255,.22)";
      ctx.lineWidth = 1;
      for(let i=0;i<10;i++){
        const x = (i/10)*W + (Math.sin(performance.now()/600 + i)*12);
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x + 40, H);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
    }

    // vignette
    ctx.globalAlpha = 0.55;
    radial(W/2, H/2, Math.max(W,H)*0.85, "rgba(0,0,0,0)", "rgba(0,0,0,.92)");
    ctx.globalAlpha = 1;
  }

  function drawHand(x, y, size, k){
    // stylized hand smear on glass
    ctx.save();
    ctx.translate(x,y);
    ctx.globalAlpha = 0.18 + k*0.26;
    ctx.fillStyle = "rgba(255,255,255,.22)";
    ctx.strokeStyle = "rgba(255,255,255,.12)";
    ctx.lineWidth = 2;

    // palm
    ctx.beginPath();
    ctx.ellipse(0, 0, size*0.32, size*0.28, 0, 0, Math.PI*2);
    ctx.fill();

    // fingers
    for(let i=-2;i<=2;i++){
      ctx.beginPath();
      ctx.ellipse(i*size*0.10, -size*0.30, size*0.07, size*0.18, 0, 0, Math.PI*2);
      ctx.fill();
    }

    // smear lines
    ctx.globalAlpha *= 0.75;
    for(let j=0;j<4;j++){
      ctx.beginPath();
      ctx.moveTo(-size*0.25 + j*size*0.12, size*0.18);
      ctx.lineTo(-size*0.10 + j*size*0.12, size*0.46);
      ctx.stroke();
    }

    ctx.restore();
    ctx.globalAlpha = 1;
  }

  // ====== Start sequence ======
  intro();

  // If the user never types, still “nudge” later
  setTimeout(() => {
    if(!codeShown){
      // subtle hint without breaking “blank”
      // only if they’re just staring
      // (doesn’t force it)
      convo.push("");
      convo.push("…");
      convo.push("type something");
      renderTerminal();
    }
  }, 12000);

})();
</script>
</body>
</html>
