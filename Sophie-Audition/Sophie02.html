<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Sophia's Audition 02 — Backyard</title>
<style>
  :root{ --bg:#07070b; --fg:#fff; --ui2:rgba(255,255,255,.14); --vio:#8a2eff;}
  html,body{height:100%; margin:0; background:var(--bg); color:var(--fg); font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}
  .wrap{height:100%; display:grid; place-items:center;}
  canvas{width:min(980px, 100vw); height:auto; image-rendering:pixelated; image-rendering:crisp-edges; touch-action:none;}
  .hud{
    position:fixed; left:12px; right:12px; top:12px; z-index:5;
    display:flex; gap:10px; flex-wrap:wrap; pointer-events:none;
  }
  .pill{
    pointer-events:auto; border:1px solid var(--ui2); background:rgba(0,0,0,.35);
    backdrop-filter: blur(8px);
    border-radius:999px; padding:10px 12px;
    font-size:11px; letter-spacing:.18em; text-transform:uppercase;
    display:flex; gap:10px; align-items:center;
  }
  .toast{
    position:fixed; left:50%; bottom:16px; transform:translateX(-50%);
    border:1px solid var(--ui2); background:rgba(0,0,0,.55);
    border-radius:14px; padding:10px 12px;
    font-size:12px; letter-spacing:.08em; opacity:0; transition:.2s;
    max-width:min(720px, calc(100vw - 24px)); text-align:center;
  }
  .toast.on{opacity:1}
</style>
</head>
<body>
<div class="hud">
  <div class="pill"><b>SOPHIA</b> <span id="status">BACKYARD</span></div>
  <div class="pill">TRIP: <span id="trip">OFF</span></div>
  <div class="pill">MILO: <span id="miloMood">following</span></div>
  <div class="pill">KEYS: <span id="keys">NO</span></div>
  <div class="pill">Door → Bedroom (bottom)</div>
</div>
<div class="toast" id="toast"></div>
<div class="wrap"><canvas id="c" width="320" height="180"></canvas></div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha:false });
ctx.imageSmoothingEnabled = false;

const UI = {
  trip: document.getElementById('trip'),
  keys: document.getElementById('keys'),
  miloMood: document.getElementById('miloMood'),
  toast: document.getElementById('toast'),
};
const STORE_KEY = "SOPHIA_AUDITION_SAVE_V1";
function loadState(){
  const raw = localStorage.getItem(STORE_KEY);
  if(raw){ try{return JSON.parse(raw);}catch(e){} }
  return {hasKeys:false, slept:false, trip:false, puke:false, poemLines:0, guitarPlayed:0, lastRoom:"BACKYARD", sophia:{x:160,y:120}, milo:{x:148,y:132}};
}
function saveState(){ localStorage.setItem(STORE_KEY, JSON.stringify(state)); }
let state = loadState();
state.lastRoom = "BACKYARD";
saveState();

UI.keys.textContent = state.hasKeys ? "YES" : "NO";
UI.trip.textContent = state.trip ? "ON" : "OFF";
UI.miloMood.textContent = state.trip ? "playing" : "following";

function toast(msg, ms=1400){
  UI.toast.textContent = msg;
  UI.toast.classList.add('on');
  clearTimeout(toast._t);
  toast._t = setTimeout(()=>UI.toast.classList.remove('on'), ms);
}

/* Input */
const keysDown = new Set();
addEventListener('keydown',(e)=>{
  const k = e.key.toLowerCase();
  if(["arrowup","arrowdown","arrowleft","arrowright"," ","shift","w","a","s","d","e"].includes(k)) e.preventDefault();
  keysDown.add(k);
});
addEventListener('keyup',(e)=>keysDown.delete(e.key.toLowerCase()));

/* World */
const W=canvas.width,H=canvas.height;
const solids = [
  [0,0,W,10],[0,0,10,H],[0,H-10,W,10],[W-10,0,10,H],
  // fence top
  [10,10,W-20,18],
  // shrubs blocks
  [30,56,60,18],
  [230,62,62,18],
  // pingpong table (solid)
  [88,118,78,22],
  // hammock posts (solid-ish frame)
  [196,92,64,28],
  // mushroom patch block (still passable but used for zone)
];

const zones = [
  {name:"MUSHROOMS", rect:[120,72,76,40], action: eatMushroom},
  {name:"DOOR_BEDROOM", rect:[148,H-20,34,10], action: ()=>go("Sophie01.html")},
  // NEW: hammock
  {name:"HAMMOCK", rect:[196,92,64,28], action: enterHammock},
  // NEW: pingpong vs milo
  {name:"PINGPONG", rect:[88,118,78,22], action: startPingpong},
];

const sophia = {x: state.sophia.x, y: state.sophia.y, w:10,h:12, speed:0.85, run:1.35};
const milo = {x: state.milo.x, y: state.milo.y, w:8,h:8};

function rectsOverlap(ax,ay,aw,ah,bx,by,bw,bh){
  return ax<bx+bw && ax+aw>bx && ay<by+bh && ay+ah>by;
}
function collides(x,y,w,h){
  for(const s of solids){
    if(rectsOverlap(x,y,w,h, s[0],s[1],s[2],s[3])) return true;
  }
  return false;
}
function tryMove(ent,dx,dy){
  const nx=ent.x+dx, ny=ent.y+dy;
  if(!collides(nx,ent.y,ent.w,ent.h)) ent.x=nx;
  if(!collides(ent.x,ny,ent.w,ent.h)) ent.y=ny;
}
function nearestZone(){
  const px=sophia.x+sophia.w/2, py=sophia.y+sophia.h/2;
  let best=null, bd=9999;
  for(const z of zones){
    const [x,y,w,h]=z.rect; const cx=x+w/2, cy=y+h/2;
    const d=(cx-px)*(cx-px)+(cy-py)*(cy-py);
    if(d<bd && d<1300){bd=d; best=z;}
  }
  return best;
}
function interact(){
  const z=nearestZone();
  if(z) z.action();
}

function eatMushroom(){
  state.trip = !state.trip;
  saveState();
  UI.trip.textContent = state.trip ? "ON" : "OFF";
  UI.miloMood.textContent = state.trip ? "playing" : "following";
  toast(state.trip ? "Mushroom eaten. Reality gets… soft." : "Trip fades. Backyard returns.", 1700);
}

/* NEW: hammock travel */
function enterHammock(){
  toast(state.trip ? "She melts into the hammock. The sky opens." : "She sits on the hammock. The night feels huge.", 1700);
  // preserve exact engine/state, just jump to a new html
  go("hammock.html");
}

/* NEW: pingpong mini */
let pingpongActive=false;
let pp={ sx:0, sy:0, mx:0, my:0, bx:0, by:0, vx:0, vy:0, s:0, m:0, over:0, hit:0 };

function startPingpong(){
  if(pingpongActive) return toast("Pingpong already in session.", 1200);
  pingpongActive=true;
  pp={
    sx:sophia.x, sy:sophia.y,
    mx:milo.x, my:milo.y,
    bx:127, by:129, vx:(Math.random()<0.5?-1:1)*1.2, vy:-0.7,
    s:0, m:0, over:0, hit:0
  };
  toast("PINGPONG vs MILO. Press E to return. (Try not to lose to a cat.)", 2200);
}

/* pingpong update */
function updatePingpong(t){
  // field over the pingpong table
  // paddles move with sophia/milo positions mapped to table edges
  const table={x:88,y:118,w:78,h:22};
  const left=table.x+4, right=table.x+table.w-6;
  const top=table.y+4, bottom=table.y+table.h-4;

  // Sophia paddle: follow Sophia's y position but clamp
  let py = sophia.y + 6;
  py = Math.max(top, Math.min(bottom, py));
  // Milo paddle: follow ball slightly delayed + jitter when tripping
  let my = pp.by + (state.trip ? Math.sin(t*0.12)*3 : 0);
  my = Math.max(top, Math.min(bottom, my));

  // Move ball
  pp.bx += pp.vx;
  pp.by += pp.vy;

  // Bounce top/bottom
  if(pp.by<top){pp.by=top; pp.vy*=-1;}
  if(pp.by>bottom){pp.by=bottom; pp.vy*=-1;}

  // Paddle collision
  // Sophia side (left)
  if(pp.bx<=left+1){
    const d = Math.abs(pp.by - py);
    if(d<=5){
      pp.bx=left+1;
      pp.vx = Math.abs(pp.vx) + 0.08;
      pp.vy += (pp.by - py)*0.06;
      pp.hit++;
      if(pp.hit%4===0) toast("Sophia: *tap* (Milo narrows his eyes)", 900);
    }else{
      pp.m++;
      serveBall(1);
      toast("Milo scores. (meow of victory)", 1200);
    }
  }
  // Milo side (right)
  if(pp.bx>=right-1){
    const d = Math.abs(pp.by - my);
    if(d<=5){
      pp.bx=right-1;
      pp.vx = -Math.abs(pp.vx) - 0.06;
      pp.vy += (pp.by - my)*0.06;
      pp.hit++;
      if(pp.hit%4===0) toast("Milo returns it with a paw. disrespectful.", 900);
    }else{
      pp.s++;
      serveBall(-1);
      toast("Sophia scores. Milo pretends he let it happen.", 1200);
    }
  }

  // End condition
  if(pp.s>=5 || pp.m>=5){
    pp.over=1;
    pingpongActive=false;
    toast(pp.s>pp.m ? "WIN: Sophia defeats Milo at pingpong. Milo demands a rematch." : "LOSS: Milo wins. He is now the athlete of the house.", 2400);
  }
}
function serveBall(dir){
  const table={x:88,y:118,w:78,h:22};
  pp.bx=table.x+table.w/2;
  pp.by=table.y+table.h/2;
  pp.vx=dir*(1.2+Math.random()*0.2);
  pp.vy=(Math.random()*1.2-0.6);
}

function go(file){
  state.sophia.x=sophia.x; state.sophia.y=sophia.y;
  state.milo.x=milo.x; state.milo.y=milo.y;
  saveState();
  location.href=file;
}

/* Render */
function drawHintBubble(text,x,y){
  const pad=3;
  ctx.font="8px ui-monospace, monospace";
  const m=ctx.measureText(text);
  const w=Math.ceil(m.width)+pad*2, h=12;
  ctx.fillStyle="rgba(0,0,0,.65)";
  ctx.fillRect(x-w/2,y-h,w,h);
  ctx.strokeStyle="rgba(255,255,255,.12)";
  ctx.strokeRect(x-w/2+0.5,y-h+0.5,w-1,h-1);
  ctx.fillStyle="rgba(255,255,255,.9)";
  ctx.fillText(text,x-w/2+pad,y-4);
}
function drawRectBevel(x,y,w,h,fill){
  ctx.fillStyle=fill; ctx.fillRect(x,y,w,h);
  ctx.fillStyle="rgba(255,255,255,.08)"; ctx.fillRect(x,y,w,1);
  ctx.fillStyle="rgba(0,0,0,.35)"; ctx.fillRect(x,y+h-1,w,1);
  ctx.fillStyle="rgba(255,255,255,.06)"; ctx.fillRect(x,y,1,h);
  ctx.fillStyle="rgba(0,0,0,.35)"; ctx.fillRect(x+w-1,y,1,h);
}
function drawSophia(){
  const x=Math.round(sophia.x), y=Math.round(sophia.y);
  ctx.fillStyle="rgba(0,0,0,.45)"; ctx.fillRect(x-1,y+11,12,2);
  ctx.fillStyle="#f2d27a"; ctx.fillRect(x+1,y+0,8,4); ctx.fillRect(x+0,y+3,10,3);
  ctx.fillStyle="#ffd9c9"; ctx.fillRect(x+2,y+5,6,4);
  ctx.fillStyle="#67b7ff"; ctx.fillRect(x+3,y+6,1,1); ctx.fillRect(x+6,y+6,1,1);
  ctx.fillStyle="rgba(138,46,255,.55)"; ctx.fillRect(x+2,y+9,6,3);
  ctx.fillStyle="rgba(255,255,255,.14)"; ctx.fillRect(x+3,y+10,4,1);
}
function drawMilo(t){
  const x=Math.round(milo.x), y=Math.round(milo.y);
  ctx.fillStyle="rgba(0,0,0,.40)"; ctx.fillRect(x-1,y+7,10,2);
  ctx.fillStyle="#d8d8d8"; ctx.fillRect(x+1,y+2,6,5);
  ctx.fillStyle="#cfcfcf"; ctx.fillRect(x+1,y+1,2,2); ctx.fillRect(x+5,y+1,2,2);
  ctx.fillStyle= state.trip ? "#ff63ff" : "#1affd3";
  ctx.fillRect(x+2,y+4,1,1); ctx.fillRect(x+5,y+4,1,1);
  // tail wiggle when tripping
  ctx.fillStyle="#cfcfcf";
  const wig = state.trip ? Math.round(Math.sin(t*0.2)*1) : 0;
  ctx.fillRect(x+7,y+3+wig,1,3);
}
function drawWorld(t){
  // base
  ctx.fillStyle="#05050a"; ctx.fillRect(0,0,W,H);

  // night sky gradient
  const g=ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,"rgba(138,46,255,.18)");
  g.addColorStop(0.4,"rgba(0,0,0,0)");
  g.addColorStop(1,"rgba(0,0,0,.35)");
  ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

  // grass
  ctx.fillStyle="rgba(0,255,170,.06)";
  ctx.fillRect(10,28,W-20,H-38);

  // fence
  drawRectBevel(10,10,W-20,18,"rgba(255,255,255,.06)");
  for(let x=12;x<W-12;x+=10){
    ctx.fillStyle="rgba(255,255,255,.04)";
    ctx.fillRect(x,12,2,14);
  }

  // shrubs
  drawRectBevel(30,56,60,18,"rgba(255,255,255,.05)");
  drawRectBevel(230,62,62,18,"rgba(255,255,255,.05)");

  // mushroom patch
  drawRectBevel(120,72,76,40,"rgba(255,255,255,.04)");
  for(let i=0;i<9;i++){
    const mx = 128 + (i%3)*22 + (i===8?8:0);
    const my = 82 + Math.floor(i/3)*12;
    ctx.fillStyle="rgba(255,255,255,.10)"; ctx.fillRect(mx,my,6,3);
    ctx.fillStyle= state.trip ? "rgba(255,99,255,.55)" : "rgba(138,46,255,.35)";
    ctx.fillRect(mx+1,my-2,4,2);
  }

  // NEW: pingpong table
  drawRectBevel(88,118,78,22,"rgba(255,255,255,.05)");
  ctx.fillStyle="rgba(0,0,0,.45)"; ctx.fillRect(92,122,70,14);
  ctx.fillStyle="rgba(255,255,255,.10)"; ctx.fillRect(127,122,1,14); // net line illusion
  ctx.fillStyle="rgba(255,255,255,.10)"; ctx.fillRect(92,129,70,1); // center court
  // tiny net
  ctx.fillStyle="rgba(255,255,255,.12)"; ctx.fillRect(126,126,3,5);

  // NEW: hammock area
  drawRectBevel(196,92,64,28,"rgba(255,255,255,.04)");
  // posts
  ctx.fillStyle="rgba(255,255,255,.08)"; ctx.fillRect(198,94,3,24);
  ctx.fillStyle="rgba(255,255,255,.08)"; ctx.fillRect(255,94,3,24);
  // hammock curve
  for(let i=0;i<46;i++){
    const x=203+i;
    const y=105 + Math.round(Math.sin((i/46)*Math.PI)*5);
    ctx.fillStyle="rgba(138,46,255,.10)";
    ctx.fillRect(x,y,1,2);
  }

  // door back to bedroom
  ctx.fillStyle="rgba(255,255,255,.10)";
  ctx.fillRect(148,H-20,34,10);
  ctx.fillStyle="rgba(0,0,0,.55)";
  ctx.fillRect(150,H-18,30,6);

  // pingpong overlay (draw ball + scores) if active
  if(pingpongActive){
    // subtle focus wash
    ctx.fillStyle="rgba(0,0,0,.20)";
    ctx.fillRect(0,0,W,H);

    // redraw table on top (keeps it crisp)
    drawRectBevel(88,118,78,22,"rgba(255,255,255,.06)");
    ctx.fillStyle="rgba(0,0,0,.50)"; ctx.fillRect(92,122,70,14);
    ctx.fillStyle="rgba(255,255,255,.11)"; ctx.fillRect(127,122,1,14);
    ctx.fillStyle="rgba(255,255,255,.10)"; ctx.fillRect(92,129,70,1);
    ctx.fillStyle="rgba(255,255,255,.14)"; ctx.fillRect(126,126,3,5);

    // paddles
    const table={x:88,y:118,w:78,h:22};
    const top=table.y+4, bottom=table.y+table.h-4;
    let py = Math.max(top, Math.min(bottom, sophia.y+6));
    let my = Math.max(top, Math.min(bottom, pp.by + (state.trip ? Math.sin(t*0.12)*3 : 0)));

    ctx.fillStyle="rgba(138,46,255,.55)";
    ctx.fillRect(table.x+4, py-4, 2, 8);

    ctx.fillStyle="rgba(0,255,213,.55)";
    ctx.fillRect(table.x+table.w-6, my-4, 2, 8);

    // ball
    ctx.fillStyle="rgba(255,255,255,.85)";
    ctx.fillRect(Math.round(pp.bx), Math.round(pp.by), 2, 2);

    // score text
    ctx.font="8px ui-monospace, monospace";
    ctx.fillStyle="rgba(255,255,255,.9)";
    ctx.fillText(`SOPHIA ${pp.s}  -  ${pp.m} MILO`, 94, 116);
    ctx.fillStyle="rgba(255,255,255,.55)";
    ctx.fillText(`(E to quit)`, 232, 116);
  }

  // hint
  const z=nearestZone();
  if(z) drawHintBubble(z.name, sophia.x+6, sophia.y-10);

  // trip post effect (simple “shader” look)
  if(state.trip){
    ctx.fillStyle=`rgba(255,99,255,${0.10 + 0.06*Math.sin(t*0.07)})`;
    ctx.fillRect(0,0,W,H);
    // scanlines + wobble tint
    for(let y=0;y<H;y+=3){
      ctx.fillStyle=`rgba(0,255,213,${0.02 + 0.02*Math.sin(t*0.12 + y*0.2)})`;
      ctx.fillRect(0,y,W,1);
    }
  }
}

/* Loop */
let t=0;
function loop(){
  t++;

  // pingpong gets priority and runs as a “mini overlay”
  if(pingpongActive){
    updatePingpong(t);
  }

  const run = keysDown.has("shift");
  const sp = sophia.speed*(run?sophia.run:1);

  let dx=0,dy=0;
  if(keysDown.has("w")||keysDown.has("arrowup")) dy-=sp;
  if(keysDown.has("s")||keysDown.has("arrowdown")) dy+=sp;
  if(keysDown.has("a")||keysDown.has("arrowleft")) dx-=sp;
  if(keysDown.has("d")||keysDown.has("arrowright")) dx+=sp;
  if(dx && dy){dx*=0.72; dy*=0.72;}
  if(dx||dy) tryMove(sophia,dx,dy);

  // Milo follow or “play” orbit if tripping
  if(state.trip){
    const ox = sophia.x + 12 + Math.sin(t*0.06)*10;
    const oy = sophia.y + 6 + Math.cos(t*0.07)*6;
    milo.x += (ox - milo.x)*0.08;
    milo.y += (oy - milo.y)*0.08;
  }else{
    const tx=sophia.x-10, ty=sophia.y+6;
    milo.x += (tx - milo.x)*0.06;
    milo.y += (ty - milo.y)*0.06;
  }

  if(keysDown.has("e")){
    if(!loop._eWasDown){
      // if pingpong active, E quits mini-game first (as requested “exit whenever”)
      if(pingpongActive){
        pingpongActive=false;
        toast("Pingpong paused. Milo licks his paw like he won anyway.", 1600);
      }else{
        interact();
      }
    }
    loop._eWasDown=true;
  } else loop._eWasDown=false;

  if(t%60===0){
    state.sophia.x=sophia.x; state.sophia.y=sophia.y;
    state.milo.x=milo.x; state.milo.y=milo.y;
    saveState();
  }

  drawWorld(t);
  drawMilo(t);
  drawSophia();

  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
