<!-- Sophie01.html  (BEDROOM / HUB) -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SOPHIE / AUDITION — Bedroom (Sophie01)</title>
  <meta name="theme-color" content="#07060a" />
  <style>
    :root{
      --bg:#07060a;
      --ink:#f2f2ff;
      --muted:rgba(242,242,255,.72);
      --hair:rgba(255,255,255,.10);
      --violet:#8A2EFF;
      --ok:#7CFF6B;
      --danger:#ff3b6b;
    }
    html,body{height:100%;margin:0;background:radial-gradient(900px 600px at 55% 40%, #1a1027 0%, #07060a 55%, #05040a 100%);overflow:hidden;font-family:ui-monospace, Menlo, Consolas, monospace;color:var(--ink)}
    canvas{position:fixed;inset:0;display:block}
    .hud{
      position:fixed; left:14px; top:12px; z-index:10;
      display:flex; gap:10px; align-items:flex-start; flex-wrap:wrap;
      user-select:none;
    }
    .pill{
      border:1px solid var(--hair);
      background:rgba(0,0,0,.35);
      backdrop-filter: blur(8px);
      border-radius:999px;
      padding:8px 10px;
      font-size:12px;
      letter-spacing:.12em;
      text-transform:uppercase;
      display:flex; gap:10px; align-items:center;
      box-shadow:0 0 20px rgba(138,46,255,.14);
    }
    .pill b{letter-spacing:.16em}
    .dot{width:8px;height:8px;border-radius:50%;background:var(--violet);box-shadow:0 0 14px rgba(138,46,255,.9)}
    .tip{
      position:fixed; right:14px; top:12px; z-index:10;
      width:min(420px, calc(100vw - 28px));
      border:1px solid var(--hair);
      background:rgba(0,0,0,.35);
      backdrop-filter: blur(8px);
      border-radius:16px;
      padding:10px 12px;
      font-size:12px;
      color:var(--muted);
      box-shadow:0 0 24px rgba(0,0,0,.35);
    }
    .tip strong{color:var(--ink)}
    .centerToast{
      position:fixed; left:50%; top:50%; transform:translate(-50%,-50%);
      z-index:20;
      pointer-events:none;
      opacity:0;
      transition:.25s;
      border:1px solid var(--hair);
      background:rgba(0,0,0,.45);
      backdrop-filter: blur(10px);
      border-radius:18px;
      padding:12px 14px;
      max-width:min(520px, calc(100vw - 36px));
      text-align:center;
      line-height:1.35;
      box-shadow:0 0 36px rgba(138,46,255,.12);
    }
    .centerToast.show{opacity:1}
    .kbd{
      display:inline-block; padding:2px 6px; border-radius:8px;
      border:1px solid var(--hair); background:rgba(255,255,255,.06);
      color:var(--ink); font-size:11px;
    }
    .small{font-size:11px;color:var(--muted)}
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="hud">
    <div class="pill"><span class="dot"></span><b>SOPHIE01</b><span id="roomName">BEDROOM</span></div>
    <div class="pill">Outfit: <span id="outfitName">VIOLET</span></div>
    <div class="pill">Key: <span id="keyState">NO</span></div>
  </div>

  <div class="tip" id="tip">
    <strong>Bedroom</strong> feels like varnished hush and moonlight.
    <div class="small" style="margin-top:6px">
      Move <span class="kbd">WASD</span> / <span class="kbd">↑↓←→</span> · Interact <span class="kbd">E</span> · Run <span class="kbd">Shift</span> · Dance <span class="kbd">Z</span> · Jump <span class="kbd">Space</span> · Splits <span class="kbd">X</span>
      <br/>Doors: Backyard → <span class="kbd">E</span> at door · Living Room → <span class="kbd">E</span> at door
    </div>
  </div>

  <div class="centerToast" id="toast"></div>

<script>
(() => {
  // ========= SAVE =========
  const STORE_KEY = "SOPHIA_AUDITION_SAVE_V1";
  const defaultSave = {
    outfit: "violet",  // violet | blue | red | green | black
    hasFrontDoorKey: false,
    lastRoom: "Sophie01.html",
  };
  const loadSave = () => {
    try{
      const raw = localStorage.getItem(STORE_KEY);
      if(!raw) return {...defaultSave};
      const s = JSON.parse(raw);
      return {...defaultSave, ...s};
    }catch(e){
      return {...defaultSave};
    }
  };
  const save = loadSave();
  const commitSave = () => {
    save.lastRoom = "Sophie01.html";
    localStorage.setItem(STORE_KEY, JSON.stringify(save));
    outfitName.textContent = save.outfit.toUpperCase();
    keyState.textContent = save.hasFrontDoorKey ? "YES" : "NO";
  };

  // ========= CANVAS SETUP =========
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  const DPR = Math.min(2, window.devicePixelRatio || 1);

  function resize(){
    canvas.width = Math.floor(innerWidth * DPR);
    canvas.height = Math.floor(innerHeight * DPR);
    canvas.style.width = innerWidth + "px";
    canvas.style.height = innerHeight + "px";
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  addEventListener("resize", resize, {passive:true});
  resize();

  // ========= UI =========
  const toast = document.getElementById("toast");
  const outfitName = document.getElementById("outfitName");
  const keyState = document.getElementById("keyState");
  const tip = document.getElementById("tip");

  function showToast(html, ms=1400){
    toast.innerHTML = html;
    toast.classList.add("show");
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=>toast.classList.remove("show"), ms);
  }

  // ========= INPUT =========
  const keys = new Set();
  addEventListener("keydown", (e)=>{
    const k = e.key.toLowerCase();
    keys.add(k);
    if(["arrowup","arrowdown","arrowleft","arrowright"," "].includes(e.key)) e.preventDefault();

    if(k === "h"){
      tip.style.display = (tip.style.display === "none") ? "" : "none";
    }
    if(k === "z"){ player.dancing = !player.dancing; }
    if(k === "x"){ player.splitsT = 0.6; }
    if(e.key === " "){ player.jumpT = Math.max(player.jumpT, 0.35); }
    if(k === "e"){ tryInteract(); }
  }, {passive:false});
  addEventListener("keyup", (e)=> keys.delete(e.key.toLowerCase()), {passive:true});

  function down(k){ return keys.has(k); }
  function axis(){
    const left = down("a") || down("arrowleft");
    const right = down("d") || down("arrowright");
    const up = down("w") || down("arrowup");
    const downk = down("s") || down("arrowdown");
    return { x:(right?1:0) - (left?1:0), y:(downk?1:0) - (up?1:0) };
  }

  // ========= WORLD =========
  // Top-down with soft "Zelda-ish" look: wood floor, chunky furniture rectangles with shading.
  const world = {
    w: 1200,
    h: 800,
    // Solid collisions
    solids: [
      // walls boundary (implicit)
      // bed
      {x: 760, y: 160, w: 280, h: 150, label:"Bed", action: () => go("bed.html")},
      // wardrobe
      {x: 160, y: 140, w: 180, h: 160, label:"Wardrobe", action: cycleOutfit},
      // desk (poetry)
      {x: 180, y: 470, w: 240, h: 120, label:"Poetry Desk", action: () => go("poetry.html")},
      // guitar spot
      {x: 560, y: 520, w: 120, h: 120, label:"Guitar", action: () => go("guitar.html")},
    ],
    // Doors (non-solid triggers)
    doors: [
      {x: 1070, y: 360, w: 90, h: 120, label:"To Backyard", hint:"Backyard (Sophie02.html)", action: () => go("Sophie02.html")},
      {x: 580, y: 60, w: 120, h: 80, label:"To Living Room", hint:"Living Room (Sophie03.html)", action: () => go("Sophie03.html")},
    ],
    decor: [
      {type:"window", x: 920, y: 40, w: 240, h: 90},
      {type:"rug", x: 470, y: 300, w: 260, h: 220},
      {type:"plant", x: 1030, y: 640, r: 26},
      {type:"lamp", x: 90, y: 640, r: 22},
    ]
  };

  // ========= PLAYER + MILO =========
  const player = {
    x: 520, y: 420,
    r: 18,
    vx: 0, vy: 0,
    facing: {x:1,y:0},
    dancing: false,
    jumpT: 0,
    splitsT: 0,
  };

  const milo = {
    x: player.x - 40,
    y: player.y + 30,
    r: 14,
    purr: 0,
  };

  function outfitColor(name){
    switch(name){
      case "blue": return "#4aa6ff";
      case "red": return "#ff4a6b";
      case "green": return "#53ff86";
      case "black": return "#1a1a22";
      default: return "#8A2EFF"; // violet
    }
  }

  function cycleOutfit(){
    const order = ["violet","blue","red","green","black"];
    const idx = order.indexOf(save.outfit);
    save.outfit = order[(idx + 1 + order.length) % order.length];
    commitSave();
    showToast(`Outfit changed to <b>${save.outfit.toUpperCase()}</b> ✨`, 1200);
  }

  function go(href){
    commitSave();
    location.href = href;
  }

  // ========= COLLISION =========
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  function collideCircleRect(cx, cy, cr, rx, ry, rw, rh){
    const px = clamp(cx, rx, rx+rw);
    const py = clamp(cy, ry, ry+rh);
    const dx = cx - px;
    const dy = cy - py;
    return (dx*dx + dy*dy) < (cr*cr);
  }

  function resolveSolids(ent){
    // boundary
    ent.x = clamp(ent.x, ent.r, world.w - ent.r);
    ent.y = clamp(ent.y, ent.r, world.h - ent.r);

    for(const s of world.solids){
      if(collideCircleRect(ent.x, ent.y, ent.r, s.x, s.y, s.w, s.h)){
        // push out by minimal axis
        const left = ent.x - s.x;
        const right = (s.x + s.w) - ent.x;
        const top = ent.y - s.y;
        const bottom = (s.y + s.h) - ent.y;

        const minX = Math.min(left, right);
        const minY = Math.min(top, bottom);

        if(minX < minY){
          ent.x += (left < right) ? - (ent.r) : (ent.r);
        }else{
          ent.y += (top < bottom) ? - (ent.r) : (ent.r);
        }
        // re-clamp
        ent.x = clamp(ent.x, ent.r, world.w - ent.r);
        ent.y = clamp(ent.y, ent.r, world.h - ent.r);
      }
    }
  }

  // ========= INTERACTION =========
  function nearestInteract(){
    // check doors + solids labeled
    let best = null;
    function consider(obj, x, y, w, h, label, action, hint){
      const cx = x + w/2, cy = y + h/2;
      const dx = (player.x - cx), dy = (player.y - cy);
      const d = Math.hypot(dx, dy);
      if(d < 90 && (!best || d < best.d)){
        best = {d, label, action, hint, x,y,w,h};
      }
    }
    for(const d of world.doors) consider(d, d.x,d.y,d.w,d.h, d.label, d.action, d.hint);
    for(const s of world.solids) if(s.label && s.action) consider(s, s.x,s.y,s.w,s.h, s.label, s.action);
    return best;
  }

  function tryInteract(){
    const n = nearestInteract();
    if(!n){ showToast(`Nothing to interact with.`, 800); return; }
    // Little flavor
    if(n.hint){
      showToast(`<b>${n.label}</b><br><span class="small">Entering: ${n.hint}</span>`, 650);
      setTimeout(()=> n.action(), 120);
    }else{
      showToast(`<b>${n.label}</b>`, 500);
      setTimeout(()=> n.action(), 120);
    }
  }

  // ========= CAMERA =========
  const cam = {x:0,y:0};
  function updateCam(){
    const targetX = player.x - innerWidth/2;
    const targetY = player.y - innerHeight/2;
    cam.x += (targetX - cam.x) * 0.08;
    cam.y += (targetY - cam.y) * 0.08;
    cam.x = clamp(cam.x, 0, world.w - innerWidth);
    cam.y = clamp(cam.y, 0, world.h - innerHeight);
  }

  // ========= RENDER HELPERS =========
  function rnd(n){ return Math.random()*n; }
  const woodNoise = (() => {
    // lightweight wood grain bands
    const bands = new Array(80).fill(0).map((_,i)=> ({
      y: i*10 + rnd(6),
      a: 0.04 + rnd(0.05)
    }));
    return {bands};
  })();

  function drawWoodFloor(){
    // base
    ctx.fillStyle = "#1a1020";
    ctx.fillRect(0,0, world.w, world.h);

    // planks
    for(let y=0;y<world.h;y+=34){
      const c = (y/34)%2===0 ? 0.12 : 0.08;
      ctx.fillStyle = `rgba(210,170,120,${c})`;
      ctx.fillRect(0, y, world.w, 28);
    }

    // grain bands
    for(const b of woodNoise.bands){
      ctx.fillStyle = `rgba(255,235,200,${b.a})`;
      ctx.fillRect(0, b.y, world.w, 2);
    }

    // vignette
    const g = ctx.createRadialGradient(world.w/2, world.h/2, 120, world.w/2, world.h/2, 860);
    g.addColorStop(0, "rgba(0,0,0,0)");
    g.addColorStop(1, "rgba(0,0,0,0.55)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0, world.w, world.h);
  }

  function drawRug(r){
    const g = ctx.createRadialGradient(r.x+r.w*0.5, r.y+r.h*0.5, 20, r.x+r.w*0.5, r.y+r.h*0.5, Math.max(r.w,r.h)*0.7);
    g.addColorStop(0, "rgba(138,46,255,.25)");
    g.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = g;
    ctx.fillRect(r.x, r.y, r.w, r.h);

    ctx.strokeStyle = "rgba(255,255,255,.10)";
    ctx.lineWidth = 2;
    ctx.strokeRect(r.x+8, r.y+8, r.w-16, r.h-16);
  }

  function drawWindow(w){
    ctx.fillStyle = "rgba(60,90,140,.14)";
    ctx.fillRect(w.x, w.y, w.w, w.h);
    ctx.strokeStyle = "rgba(255,255,255,.16)";
    ctx.lineWidth = 2;
    ctx.strokeRect(w.x, w.y, w.w, w.h);

    // light rays
    const rays = ctx.createLinearGradient(w.x, w.y+w.h, w.x, w.y+w.h+300);
    rays.addColorStop(0, "rgba(190,210,255,.18)");
    rays.addColorStop(1, "rgba(190,210,255,0)");
    ctx.fillStyle = rays;
    ctx.beginPath();
    ctx.moveTo(w.x+20, w.y+w.h);
    ctx.lineTo(w.x+w.w-40, w.y+w.h);
    ctx.lineTo(w.x+w.w+200, w.y+w.h+320);
    ctx.lineTo(w.x-120, w.y+w.h+320);
    ctx.closePath();
    ctx.fill();
  }

  function drawPlant(p){
    ctx.fillStyle = "rgba(40,255,160,.10)";
    ctx.beginPath(); ctx.arc(p.x, p.y, p.r*1.8, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = "rgba(255,255,255,.12)";
    ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
  }

  function drawLamp(p){
    ctx.fillStyle = "rgba(255,220,160,.08)";
    ctx.beginPath(); ctx.arc(p.x, p.y, p.r*2.6, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = "rgba(255,255,255,.10)";
    ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
  }

  function drawFurnitureRect(x,y,w,h, tint="rgba(255,255,255,.06)", edge="rgba(255,255,255,.14)"){
    // shadow
    ctx.fillStyle = "rgba(0,0,0,.35)";
    ctx.fillRect(x+10, y+10, w, h);
    // body
    ctx.fillStyle = tint;
    ctx.fillRect(x, y, w, h);
    // top highlight
    ctx.fillStyle = "rgba(255,255,255,.06)";
    ctx.fillRect(x, y, w, 10);
    // edges
    ctx.strokeStyle = edge;
    ctx.lineWidth = 2;
    ctx.strokeRect(x, y, w, h);
  }

  function drawDoor(d){
    ctx.fillStyle = "rgba(138,46,255,.10)";
    ctx.fillRect(d.x, d.y, d.w, d.h);
    ctx.strokeStyle = "rgba(255,255,255,.18)";
    ctx.lineWidth = 2;
    ctx.strokeRect(d.x, d.y, d.w, d.h);

    // subtle portal glow
    const g = ctx.createRadialGradient(d.x+d.w/2, d.y+d.h/2, 10, d.x+d.w/2, d.y+d.h/2, 120);
    g.addColorStop(0, "rgba(138,46,255,.20)");
    g.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = g;
    ctx.fillRect(d.x-80, d.y-80, d.w+160, d.h+160);
  }

  function drawCharacter(){
    // Sophie: cute top-down "chibi-ish" with dress + hair glow.
    const col = outfitColor(save.outfit);
    const bob = player.dancing ? Math.sin(t*10)*3 : 0;
    const jump = player.jumpT > 0 ? Math.sin((1-player.jumpT)*Math.PI) * 12 : 0;
    const splits = player.splitsT > 0 ? (1 - player.splitsT/0.6) : 0;

    const x = player.x;
    const y = player.y - jump + bob;

    // shadow
    ctx.fillStyle = "rgba(0,0,0,.35)";
    ctx.beginPath(); ctx.ellipse(x, player.y+10, 18, 9, 0, 0, Math.PI*2); ctx.fill();

    // hair aura
    const aura = ctx.createRadialGradient(x, y-22, 6, x, y-22, 40);
    aura.addColorStop(0, "rgba(180,140,255,.22)");
    aura.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = aura;
    ctx.beginPath(); ctx.arc(x, y-18, 40, 0, Math.PI*2); ctx.fill();

    // head
    ctx.fillStyle = "rgba(255,245,235,.95)";
    ctx.beginPath(); ctx.arc(x, y-18, 12, 0, Math.PI*2); ctx.fill();

    // hair
    ctx.fillStyle = "rgba(20,20,30,.85)";
    ctx.beginPath();
    ctx.arc(x, y-22, 14, 0, Math.PI*2);
    ctx.fill();

    // dress/body
    ctx.fillStyle = col;
    ctx.beginPath();
    ctx.moveTo(x, y-6);
    ctx.lineTo(x-14, y+16);
    ctx.lineTo(x+14, y+16);
    ctx.closePath();
    ctx.fill();

    // legs (splits!)
    ctx.strokeStyle = "rgba(255,245,235,.85)";
    ctx.lineWidth = 4;
    ctx.lineCap = "round";
    ctx.beginPath();
    if(splits > 0){
      ctx.moveTo(x, y+16);
      ctx.lineTo(x-18 - 10*splits, y+24);
      ctx.moveTo(x, y+16);
      ctx.lineTo(x+18 + 10*splits, y+24);
    }else{
      ctx.moveTo(x-4, y+16);
      ctx.lineTo(x-6, y+26);
      ctx.moveTo(x+4, y+16);
      ctx.lineTo(x+6, y+26);
    }
    ctx.stroke();

    // tiny sparkle when dancing
    if(player.dancing){
      for(let i=0;i<2;i++){
        const sx = x + Math.sin(t*7 + i*2.2)*22;
        const sy = y - 24 + Math.cos(t*8 + i*3.1)*18;
        ctx.fillStyle = "rgba(255,255,255,.55)";
        ctx.fillRect(sx, sy, 2, 2);
      }
    }
  }

  function drawMilo(){
    // Milo: soft white cat follower, with little tail flick.
    milo.purr += 0.02;
    const tail = Math.sin(milo.purr*4) * 6;

    // shadow
    ctx.fillStyle = "rgba(0,0,0,.28)";
    ctx.beginPath(); ctx.ellipse(milo.x, milo.y+8, 14, 7, 0, 0, Math.PI*2); ctx.fill();

    // body
    ctx.fillStyle = "rgba(255,255,255,.90)";
    ctx.beginPath(); ctx.ellipse(milo.x, milo.y, 12, 9, 0, 0, Math.PI*2); ctx.fill();

    // head
    ctx.beginPath(); ctx.arc(milo.x+10, milo.y-6, 7, 0, Math.PI*2); ctx.fill();

    // ears
    ctx.fillStyle = "rgba(255,255,255,.86)";
    ctx.beginPath();
    ctx.moveTo(milo.x+6, milo.y-11);
    ctx.lineTo(milo.x+10, milo.y-18);
    ctx.lineTo(milo.x+14, milo.y-11);
    ctx.closePath(); ctx.fill();

    // tail
    ctx.strokeStyle = "rgba(255,255,255,.85)";
    ctx.lineWidth = 4;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(milo.x-10, milo.y+2);
    ctx.quadraticCurveTo(milo.x-24, milo.y-6, milo.x-16, milo.y-16 + tail);
    ctx.stroke();

    // eyes (tiny)
    ctx.fillStyle = "rgba(30,30,40,.55)";
    ctx.fillRect(milo.x+12, milo.y-8, 2, 2);
  }

  // ========= UPDATE LOOP =========
  let last = performance.now();
  let t = 0;

  function step(now){
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;
    t += dt;

    // Movement
    const a = axis();
    let sp = (down("shift") ? 220 : 150);
    if(player.dancing) sp *= 0.65;

    // normalize diagonal
    const mag = Math.hypot(a.x,a.y) || 1;
    const ax = a.x / mag;
    const ay = a.y / mag;

    player.vx += (ax*sp - player.vx) * 0.18;
    player.vy += (ay*sp - player.vy) * 0.18;

    player.x += player.vx * dt;
    player.y += player.vy * dt;

    if(Math.abs(ax)+Math.abs(ay) > 0.01){
      player.facing.x = ax;
      player.facing.y = ay;
    }

    resolveSolids(player);

    // Milo follow (spring)
    const followDist = 46;
    const tx = player.x - player.facing.x*followDist - 18;
    const ty = player.y - player.facing.y*followDist + 14;
    milo.x += (tx - milo.x) * 0.08;
    milo.y += (ty - milo.y) * 0.08;
    resolveSolids(milo);

    // timers
    player.jumpT = Math.max(0, player.jumpT - dt);
    player.splitsT = Math.max(0, player.splitsT - dt);

    updateCam();
    render();

    requestAnimationFrame(step);
  }

  // ========= RENDER =========
  function render(){
    ctx.clearRect(0,0,innerWidth,innerHeight);

    // world-space draw
    ctx.save();
    ctx.translate(-cam.x, -cam.y);

    drawWoodFloor();

    // decor first
    for(const d of world.decor){
      if(d.type==="window") drawWindow(d);
      if(d.type==="rug") drawRug(d);
      if(d.type==="plant") drawPlant(d);
      if(d.type==="lamp") drawLamp(d);
    }

    // furniture
    for(const s of world.solids){
      let tint = "rgba(255,255,255,.06)";
      if(s.label==="Bed") tint = "rgba(160,190,255,.08)";
      if(s.label==="Wardrobe") tint = "rgba(255,255,255,.07)";
      if(s.label==="Poetry Desk") tint = "rgba(255,230,180,.06)";
      if(s.label==="Guitar") tint = "rgba(255,255,255,.05)";
      drawFurnitureRect(s.x,s.y,s.w,s.h, tint);
      // tiny label glyph
      ctx.fillStyle = "rgba(255,255,255,.22)";
      ctx.font = "11px ui-monospace, Menlo, monospace";
      ctx.fillText(s.label, s.x+10, s.y+18);
    }

    // doors
    for(const d of world.doors){
      drawDoor(d);
      ctx.fillStyle = "rgba(255,255,255,.24)";
      ctx.font = "11px ui-monospace, Menlo, monospace";
      ctx.fillText("DOOR", d.x+10, d.y+18);
    }

    // characters
    drawMilo();
    drawCharacter();

    // interaction prompt
    const n = nearestInteract();
    if(n){
      // ring
      ctx.strokeStyle = "rgba(138,46,255,.45)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.ellipse(player.x, player.y+8, 28, 14, 0, 0, Math.PI*2);
      ctx.stroke();

      // floating prompt
      ctx.fillStyle = "rgba(0,0,0,.45)";
      ctx.strokeStyle = "rgba(255,255,255,.14)";
      ctx.lineWidth = 1;
      const text = `E · ${n.label}`;
      ctx.font = "12px ui-monospace, Menlo, monospace";
      const m = ctx.measureText(text);
      const px = player.x - m.width/2 - 10;
      const py = player.y - 44;
      ctx.beginPath();
      roundRect(px, py, m.width+20, 22, 10);
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = "rgba(255,255,255,.88)";
      ctx.fillText(text, player.x - m.width/2, py+15);
    }

    ctx.restore();
  }

  function roundRect(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y, x+w,y+h, rr);
    ctx.arcTo(x+w,y+h, x,y+h, rr);
    ctx.arcTo(x,y+h, x,y, rr);
    ctx.arcTo(x,y, x+w,y, rr);
    ctx.closePath();
  }

  // ========= INIT =========
  commitSave();
  showToast(`Find calm. Then find the key.`, 1500);
  requestAnimationFrame(step);
})();
</script>
</body>
</html>
