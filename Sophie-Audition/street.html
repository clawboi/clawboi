<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Sophia's Audition — Street (Day City)</title>
<style>
  :root{
    --bg:#07070b; --fg:#fff; --ui2:rgba(255,255,255,.14);
    --vio:#8a2eff; --aqua:#00ffd5; --hot:#ff63ff; --sun:#ffd24d;
  }
  html,body{height:100%; margin:0; background:var(--bg); color:var(--fg);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}
  .wrap{height:100%; display:grid; place-items:center;}
  canvas{width:min(980px, 100vw); height:auto; image-rendering:pixelated; image-rendering:crisp-edges; touch-action:none;}
  .hud{
    position:fixed; left:12px; right:12px; top:12px; z-index:6;
    display:flex; gap:10px; flex-wrap:wrap; pointer-events:none;
  }
  .pill{
    pointer-events:auto; border:1px solid var(--ui2); background:rgba(0,0,0,.32);
    backdrop-filter: blur(8px);
    border-radius:999px; padding:10px 12px;
    font-size:11px; letter-spacing:.18em; text-transform:uppercase;
    display:flex; gap:10px; align-items:center;
  }
  .pill b{letter-spacing:.22em}
  .toast{
    position:fixed; left:50%; bottom:16px; transform:translateX(-50%);
    border:1px solid var(--ui2); background:rgba(0,0,0,.55);
    border-radius:14px; padding:10px 12px;
    font-size:12px; letter-spacing:.08em; opacity:0; transition:.2s;
    max-width:min(920px, calc(100vw - 24px)); text-align:center;
    z-index:7;
  }
  .toast.on{opacity:1}

  body::before{
    content:"";
    position:fixed; inset:-20%;
    background:
      radial-gradient(circle at 20% 18%, rgba(255,210,77,.24), transparent 58%),
      radial-gradient(circle at 78% 22%, rgba(0,255,213,.16), transparent 62%),
      radial-gradient(circle at 40% 85%, rgba(138,46,255,.11), transparent 62%),
      radial-gradient(circle at 90% 75%, rgba(255,99,255,.09), transparent 65%),
      radial-gradient(circle at 52% 44%, rgba(255,255,255,.04), transparent 62%);
    filter:blur(44px) saturate(1.12);
    pointer-events:none;
  }

  .panel{
    position:fixed; right:12px; bottom:12px; z-index:8;
    width:min(380px, calc(100vw - 24px));
    border:1px solid var(--ui2);
    background:rgba(0,0,0,.48);
    backdrop-filter: blur(10px);
    border-radius:16px;
    padding:10px 12px;
    display:none;
  }
  .panel.on{display:block}
  .panel h3{
    margin:0 0 8px 0;
    font-size:11px; letter-spacing:.22em; text-transform:uppercase;
    opacity:.9;
  }
  .panel .row{
    display:flex; justify-content:space-between; gap:12px;
    font-size:12px; line-height:1.35;
    border-top:1px solid rgba(255,255,255,.08);
    padding:8px 0;
  }
  .panel .row:first-of-type{border-top:0; padding-top:0}
  .panel .k{opacity:.72; letter-spacing:.06em}
  .panel .v{opacity:.95}
  .panel .tiny{font-size:11px; opacity:.72; letter-spacing:.06em}

  .dialog{
    position:fixed; left:12px; bottom:12px; z-index:9;
    width:min(520px, calc(100vw - 24px));
    border:1px solid var(--ui2);
    background:rgba(0,0,0,.56);
    backdrop-filter: blur(10px);
    border-radius:16px;
    padding:10px 12px;
    display:none;
  }
  .dialog.on{display:block}
  .dialog h3{
    margin:0 0 6px 0;
    font-size:11px; letter-spacing:.22em; text-transform:uppercase;
    opacity:.92;
  }
  .dialog .say{
    font-size:12px; line-height:1.4; letter-spacing:.04em;
    opacity:.92;
    padding:8px 0 10px 0;
    border-top:1px solid rgba(255,255,255,.08);
    border-bottom:1px solid rgba(255,255,255,.08);
  }
  .dialog .opt{
    display:grid; gap:6px;
    padding-top:10px;
    font-size:12px;
  }
  .dialog .opt div{
    border:1px solid rgba(255,255,255,.10);
    background:rgba(255,255,255,.06);
    border-radius:12px;
    padding:8px 10px;
    letter-spacing:.04em;
  }
  .dialog .hint{
    margin-top:8px;
    font-size:11px; opacity:.72; letter-spacing:.06em;
  }
</style>
</head>
<body>
  <div class="hud">
    <div class="pill"><b>SOPHIA</b> <span id="status">STREET</span></div>
    <div class="pill">MODE: <span id="mode">ON FOOT</span></div>
    <div class="pill">TIME: <span id="time">10:00</span></div>
    <div class="pill">MUSH: <span id="mush">0</span></div>
    <div class="pill">WANTED: <span id="wanted">0</span>★</div>
    <div class="pill">KEYS: <span id="keys">NO</span></div>
    <div class="pill">CASH: $<span id="cash">0</span></div>
    <div class="pill">QUEST: <span id="questShort">NONE</span></div>
    <div class="pill">Move: WASD · Run/Boost: SHIFT · Interact: E · Throw: SPACE · Jump: F · Map: M · Journal: Q · Trip: T</div>
  </div>

  <div class="toast" id="toast"></div>

  <div class="panel" id="journal">
    <h3>Journal</h3>
    <div class="row"><div class="k">Active</div><div class="v" id="qActive">None</div></div>
    <div class="row"><div class="k">Objective</div><div class="v" id="qObj">…</div></div>
    <div class="row"><div class="k">Hint</div><div class="v tiny" id="qHint">Press Q to close.</div></div>
  </div>

  <div class="panel" id="mapPanel">
    <h3>Map</h3>
    <div class="row"><div class="k">Tip</div><div class="v tiny">Press M to close. Click map to set waypoint.</div></div>
    <div class="row"><div class="k">Waypoint</div><div class="v" id="wpText">None</div></div>
    <div class="row"><div class="k">Lucas</div><div class="v" id="lucasText">Not called</div></div>
  </div>

  <div class="dialog" id="dialog">
    <h3 id="dlgTitle">Conversation</h3>
    <div class="say" id="dlgSay">…</div>
    <div class="opt" id="dlgOpts"></div>
    <div class="hint" id="dlgHint">Press 1/2/3 to choose. ESC to close.</div>
  </div>

  <div class="wrap"><canvas id="c" width="360" height="202"></canvas></div>

<script>
/* ==========================================================
   STREET.HTML (DAY CITY) — FIXED “MAP TOO BIG / CAR MISSING / BUILDING RESTRICTIONS”
   - World is slightly smaller (scaled) with safe save migration
   - Car always snaps into existence near HOME if offscreen/invalid/old-scale
   - Building collision boxes inset so they don’t feel like invisible forcefields
   - Big map overlay slightly smaller (doesn’t eat the whole screen)
   ========================================================== */

const canvas=document.getElementById('c');
const ctx=canvas.getContext('2d',{alpha:false});
ctx.imageSmoothingEnabled=false;

const UI={
  status:document.getElementById('status'),
  mode:document.getElementById('mode'),
  time:document.getElementById('time'),
  mush:document.getElementById('mush'),
  wanted:document.getElementById('wanted'),
  keys:document.getElementById('keys'),
  toast:document.getElementById('toast'),
  cash:document.getElementById('cash'),
  questShort:document.getElementById('questShort'),
  journal:document.getElementById('journal'),
  mapPanel:document.getElementById('mapPanel'),
  qActive:document.getElementById('qActive'),
  qObj:document.getElementById('qObj'),
  qHint:document.getElementById('qHint'),
  wpText:document.getElementById('wpText'),
  lucasText:document.getElementById('lucasText'),
  dlg:document.getElementById('dialog'),
  dlgTitle:document.getElementById('dlgTitle'),
  dlgSay:document.getElementById('dlgSay'),
  dlgOpts:document.getElementById('dlgOpts'),
  dlgHint:document.getElementById('dlgHint'),
};

const STORE_KEY="SOPHIA_AUDITION_SAVE_V1";
const RUN_KEY="SOPHIA_AUDITION_RUN_V1";
const DURATION_MS=10*60*1000;

/* ---------- state ---------- */
function loadState(){
  const r=localStorage.getItem(STORE_KEY);
  if(r){ try{return JSON.parse(r);}catch(e){} }
  return {
    meta:{ worldScale: null },
    hasKeys:false, slept:false, trip:false, puke:false,
    poemLines:0, guitarPlayed:0,
    lastRoom:"STREET",
    cash: 0,
    quests: { activeId:null, completed:{}, data:{} },
    waypoint: null,
    sophia:{x:380,y:920}, milo:{x:360,y:940},
    lucas:{ active:false, called:false, x:340, y:960, mood:"cool", bond:0 },
    street:{
      mush:0, wanted:0, inCar:false, hidden:false, seen:0,
      car:{x:420,y:940,vx:0,vy:0},
      lastThrow:0,
      tripUntil:0,
      lastTalk:0,
      lastJump:0
    },
    events:{
      purse:{ stage:"idle", rewardGiven:false, robberDown:false },
      catcall:{ done:false }
    }
  };
}
function saveState(){ localStorage.setItem(STORE_KEY, JSON.stringify(state)); }

function loadRun(){
  const r=localStorage.getItem(RUN_KEY);
  if(r){ try{return JSON.parse(r);}catch(e){} }
  return { startTime:0, durationMs:DURATION_MS, active:false, ended:false };
}
function saveRun(run){ localStorage.setItem(RUN_KEY, JSON.stringify(run)); }

let state=loadState();
state.meta = state.meta || { worldScale:null };
state.lastRoom="STREET";
state.street = state.street || { mush:0, wanted:0, inCar:false, hidden:false, seen:0, car:{x:420,y:940,vx:0,vy:0}, lastThrow:0, tripUntil:0, lastTalk:0, lastJump:0 };
if(!state.street.car) state.street.car={x:420,y:940,vx:0,vy:0};
if(typeof state.cash!=="number") state.cash=0;
state.quests = state.quests || {activeId:null, completed:{}, data:{}};
state.quests.completed = state.quests.completed || {};
state.quests.data = state.quests.data || {};
state.lucas = state.lucas || {active:false, called:false, x:340, y:960, mood:"cool", bond:0};
state.events = state.events || { purse:{stage:"idle", rewardGiven:false, robberDown:false}, catcall:{done:false} };
state.events.purse = state.events.purse || {stage:"idle", rewardGiven:false, robberDown:false};
state.events.catcall = state.events.catcall || {done:false};

UI.keys.textContent = state.hasKeys ? "YES" : "NO";
UI.mush.textContent = (state.street.mush|0);
UI.wanted.textContent = (state.street.wanted|0);
UI.mode.textContent = state.street.inCar ? "IN CAR" : "ON FOOT";
UI.cash.textContent = (state.cash|0);
UI.lucasText.textContent = state.lucas.called ? (state.lucas.active ? "Following" : "Called (not here)") : "Not called";

/* ---------- toast ---------- */
function toast(msg,ms=1500){
  UI.toast.textContent=msg;
  UI.toast.classList.add('on');
  clearTimeout(toast._t);
  toast._t=setTimeout(()=>UI.toast.classList.remove('on'),ms);
}

/* ---------- timer (kept) ---------- */
function fmt(ms){
  ms=Math.max(0, ms|0);
  const s=Math.ceil(ms/1000);
  const m=(s/60)|0;
  const ss=String(s%60).padStart(2,"0");
  return `${m}:${ss}`;
}
function timeLeftMs(){
  const run=loadRun();
  if(!run.active || run.ended) return run.durationMs;
  return (run.startTime + run.durationMs - Date.now());
}
function tickTimer(){
  const left=timeLeftMs();
  UI.time.textContent=fmt(left);
  if(left<=0){
    const run=loadRun();
    run.ended=true; run.active=false;
    saveRun(run);
    toast("TIME UP. Audition missed.", 1800);
    setTimeout(()=>location.href="Sophie00.html", 900);
  }
}
setInterval(tickTimer, 250);
tickTimer();

/* ---------- input ---------- */
const keysDown=new Set();
addEventListener('keydown',(e)=>{
  const k=e.key.toLowerCase();
  if(["arrowup","arrowdown","arrowleft","arrowright"," ","shift","w","a","s","d","e","m","q","t","f","h","1","2","3","escape"].includes(k)) e.preventDefault();
  keysDown.add(k);
});
addEventListener('keyup',(e)=>keysDown.delete(e.key.toLowerCase()));

/* ---------- helpers ---------- */
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const rand=(a,b)=>a+Math.random()*(b-a);
const dist2=(ax,ay,bx,by)=>{const dx=ax-bx,dy=ay-by; return dx*dx+dy*dy;}
const lerp=(a,b,t)=>a+(b-a)*t;
function rectsOverlap(ax,ay,aw,ah,bx,by,bw,bh){
  return ax<bx+bw && ax+aw>bx && ay<by+bh && ay+ah>by;
}

/* ==========================================================
   WORLD SCALE (slightly smaller world, safely)
   ========================================================== */
const WORLD_SCALE = 0.90; // <-- map slightly smaller
const S = (n)=>Math.round(n*WORLD_SCALE);

function migrateToScale(){
  const prev = +state.meta.worldScale || null;
  if(prev && Math.abs(prev - WORLD_SCALE) < 0.0001) return;

  // If no previous scale stored, assume old content was 1.0
  const from = prev || 1.0;
  const ratio = WORLD_SCALE / from;

  function scalePoint(o){
    if(!o) return;
    if(typeof o.x==="number") o.x = Math.round(o.x*ratio);
    if(typeof o.y==="number") o.y = Math.round(o.y*ratio);
  }
  function scaleVel(o){
    if(!o) return;
    if(typeof o.vx==="number") o.vx = o.vx*ratio;
    if(typeof o.vy==="number") o.vy = o.vy*ratio;
  }

  // core actors
  scalePoint(state.sophia); scalePoint(state.milo);
  scalePoint(state.lucas);

  // car
  if(state.street && state.street.car){
    scalePoint(state.street.car);
    scaleVel(state.street.car);
  }

  // waypoint
  if(state.waypoint){ scalePoint(state.waypoint); }

  state.meta.worldScale = WORLD_SCALE;
  saveState();
}
migrateToScale();

/* ==========================================================
   WORLD
   ========================================================== */
const VW=canvas.width, VH=canvas.height;
const WORLD={ w: S(3200), h: S(2300) };

// Camera
const cam={x:0,y:0, shake:0};

// Road network
const roads = [
  {x:S(0),y:S(1100),w:WORLD.w,h:S(160), name:"MAIN"},
  {x:S(1960),y:S(0),w:S(190),h:WORLD.h, name:"BOULEVARD"},
  {x:S(340),y:S(1400),w:S(1060),h:S(130), name:"NEIGHBOR"},
  {x:S(1400),y:S(1320),w:S(1040),h:S(130), name:"MARKET"},
  {x:S(520),y:S(680),w:S(1280),h:S(120), name:"NORTH"},
  {x:S(1140),y:S(860),w:S(980),h:S(120), name:"MID"},
  {x:S(2520),y:S(720),w:S(560),h:S(120), name:"EAST"},
  {x:S(220),y:S(960),w:S(820),h:S(110), name:"HOMEWAY"},
  {x:S(920),y:S(1010),w:S(920),h:S(110), name:"CUT"},
  {x:S(40),y:S(340),w:S(560),h:S(110), name:"CANYON RD"},
  {x:S(520),y:S(800),w:S(120),h:S(300), name:"LINK"},
  {x:S(860),y:S(800),w:S(120),h:S(300), name:"LINK"},
  {x:S(1400),y:S(860),w:S(120),h:S(460), name:"LINK"},
  {x:S(1700),y:S(860),w:S(120),h:S(460), name:"LINK"},
  {x:S(2520),y:S(840),w:S(560),h:S(120), name:"EAST 2"},
];

function isOnRoad(x,y){
  for(const r of roads){
    if(x>=r.x && x<=r.x+r.w && y>=r.y && y<=r.y+r.h) return true;
  }
  return false;
}

// Solids
const solids=[];
const addSolid=(x,y,w,h)=>solids.push([x,y,w,h]);

// World bounds
addSolid(-120,-120,WORLD.w+240,120);
addSolid(-120,WORLD.h,WORLD.w+240,120);
addSolid(-120,-120,120,WORLD.h+240);
addSolid(WORLD.w,-120,120,WORLD.h+240);

/* ==========================================================
   BUILDINGS (same look, less “forcefield” collision)
   ========================================================== */
const BUILD_SCALE = 0.72;
const BUILD_COLLISION_INSET = 8; // <-- makes movement feel less restricted

function B(name,x,y,w,h,link,tag){
  const bx=S(x), by=S(y);
  return {name, x:bx, y:by, w:Math.round(w*BUILD_SCALE*WORLD_SCALE), h:Math.round(h*BUILD_SCALE*WORLD_SCALE), link, tag};
}

const buildings=[
  B("HOME",        210, 1680, 260, 220, "Sophie03.html",      "HOME"),
  B("GROCERY",     640, 1490, 300, 230, "grocery-store.html", "GROC"),
  B("BLOCKBUSTER", 1020,1508, 330, 250, "blockbuster.html",   "BLCK"),
  B("CAT STORE",   1408,1490, 290, 230, "catstore.html",      "CAT"),
  B("WEED SHOP",   1724,1490, 290, 230, "weedshop.html",      "WEED"),
  B("STARR",       2380, 220, 460, 340, "audition.html",      "STAR"),

  B("COFFEE",      460,  590, 240, 190, null, "CAF"),
  B("ARCADE",      820,  590, 240, 190, null, "ARC"),
  B("GAS",         2680, 1026, 280, 220, null, "GAS"),

  B("FOLLOW YOUR HEART", 1140, 580, 300, 210, "followyourheart.html", "REST"),
  B("YOGA",        460,  240, 230, 170, "yoga.html",          "YOGA"),
  B("SOPHIE SHOP", 1580, 590, 280, 210, "sophieshop.html",    "SHOP"),

  B("BEACH (LATER)", 60, 180, 220, 150, null, "BEACH"),
];

// Solids for buildings (inset so you can move closer around them)
for(const b of buildings){
  const inset = Math.min(BUILD_COLLISION_INSET, Math.floor(Math.min(b.w,b.h)*0.12));
  addSolid(b.x+inset, b.y+inset, Math.max(4,b.w-inset*2), Math.max(4,b.h-inset*2));
}

// Park
const park={x:S(320),y:S(220),w:S(700),h:S(430)};
addSolid(park.x,park.y,park.w,S(18));
addSolid(park.x,park.y+park.h-S(18),park.w,S(18));
addSolid(park.x,park.y,S(18),park.h);
addSolid(park.x+park.w-S(18),park.y,S(18),park.h);

// Duck pond
const pond={x:S(1040),y:S(300),w:S(220),h:S(160)};

// Signs
const signs=[];
function addSign(x,y,text){ signs.push({x:S(x),y:S(y),text}); }
addSign(520,1040,"PALM AVE");
addSign(970,1040,"VIOLET ST");
addSign(1960,1040,"BOULEVARD");
addSign(2360,1040,"STARR WAY");
addSign(1180,1260,"MILO LN");
addSign(1460,860,"SUNSET RD");
addSign(520,760,"COFFEE CT");
addSign(860,760,"ARCADE BLVD");
addSign(2640,980,"GAS ROW");
addSign(160,400,"TOPANGA ROUTE");
addSign(1180,760,"FOLLOW YOUR HEART");

// Dumpsters
const dumpsters=[
  {x:S(860),y:S(1360),w:S(36),h:S(20)},
  {x:S(1600),y:S(1360),w:S(36),h:S(20)},
  {x:S(2140),y:S(1020),w:S(36),h:S(20)},
  {x:S(660),y:S(860),w:S(36),h:S(20)},
  {x:S(2560),y:S(800),w:S(36),h:S(20)},
  {x:S(560),y:S(1560),w:S(36),h:S(20)},
];

// Props
const benches=[
  {x:S(520),y:S(340),w:S(26),h:S(10)},
  {x:S(860),y:S(360),w:S(26),h:S(10)},
  {x:S(2580),y:S(1100),w:S(26),h:S(10)},
  {x:S(1160),y:S(1600),w:S(26),h:S(10)},
  {x:S(1060),y:S(480),w:S(26),h:S(10)},
];
const mailboxes=[
  {x:S(520),y:S(1560),w:S(10),h:S(10), id:"MB_HOME"},
  {x:S(720),y:S(1430),w:S(10),h:S(10), id:"MB_GROC"},
  {x:S(1000),y:S(1430),w:S(10),h:S(10), id:"MB_BLCK"},
  {x:S(1420),y:S(1430),w:S(10),h:S(10), id:"MB_CAT"},
  {x:S(1740),y:S(1430),w:S(10),h:S(10), id:"MB_WEED"},
  {x:S(2460),y:S(520),w:S(10),h:S(10), id:"MB_STAR"},
  {x:S(1120),y:S(820),w:S(10),h:S(10), id:"MB_REST"},
];
const vending=[
  {x:S(520),y:S(630),w:S(14),h:S(18), uses:3},
  {x:S(820),y:S(630),w:S(14),h:S(18), uses:3},
  {x:S(1560),y:S(630),w:S(14),h:S(18), uses:3},
];
const photoSpots=[
  {x:S(250),y:S(1240),w:S(18),h:S(18), id:"PS_WALL"},
  {x:S(720),y:S(260),w:S(18),h:S(18), id:"PS_PARK"},
  {x:S(2440),y:S(360),w:S(18),h:S(18), id:"PS_STAR"},
  {x:S(1140),y:S(320),w:S(18),h:S(18), id:"PS_POND"},
];

// Intersections + traffic lights
const intersections=[];
function addIntersection(x,y){ intersections.push({x:S(x),y:S(y), r:S(34), t: rand(0,999)|0}); }
addIntersection(520, 1180);
addIntersection(980, 1180);
addIntersection(1960, 1180);
addIntersection(1960, 820);
addIntersection(1960, 1560);
addIntersection(1400, 1390);
addIntersection(860, 1390);
addIntersection(2640, 1100);
addIntersection(520, 740);
addIntersection(860, 740);

const lights=[
  {x:S(1960), y:S(1180), phase:0},
  {x:S(1960), y:S(820), phase:1},
  {x:S(2640), y:S(1100), phase:0},
];
function lightState(L, t){
  const cyc=540;
  const p = ((t + (L.x+L.y|0)) % cyc) / cyc;
  if(p<0.42) return "EW_G";
  if(p<0.48) return "EW_Y";
  if(p<0.50) return "ALL_R";
  if(p<0.92) return "NS_G";
  if(p<0.98) return "NS_Y";
  return "ALL_R";
}

// Trees
const trees=[];
for(let i=0;i<320;i++){
  const x=rand(40,WORLD.w-40), y=rand(40,WORLD.h-40);
  if(isOnRoad(x,y)) continue;
  if(x>park.x && x<park.x+park.w && y>park.y && y<park.y+park.h) continue;
  if(x>pond.x && x<pond.x+pond.w && y>pond.y && y<pond.y+pond.h) continue;
  trees.push({x,y,s:rand(0.9,1.9), tint:(Math.random()<0.5?"aqua":"sun")});
}

/* Mushrooms + coins */
const mushWorld=[];
for(let i=0;i<170;i++){
  let x=rand(80,WORLD.w-80), y=rand(80,WORLD.h-80);
  if(isOnRoad(x,y)) { y+=S(160); }
  mushWorld.push({x,y,alive:true,kind:(Math.random()<0.10?"gold":(Math.random()<0.18?"aqua":"vio"))});
}
const coins=[];
for(let i=0;i<140;i++){
  let x=rand(90,WORLD.w-90), y=rand(90,WORLD.h-90);
  if(isOnRoad(x,y)) y += (Math.random()<0.5?-S(120):S(120));
  coins.push({x,y,alive:true, v:(Math.random()<0.08?5:1)});
}

/* ==========================================================
   ENTITIES
   ========================================================== */
const sophia={x:state.sophia.x, y:state.sophia.y, w:10,h:12, speed:70, run:110, hop:0};
const milo={x:state.milo.x, y:state.milo.y, w:8,h:8};

// Lucas
const lucas={
  active: !!state.lucas.active,
  called: !!state.lucas.called,
  x: state.lucas.x ?? (sophia.x-24),
  y: state.lucas.y ?? (sophia.y+12),
  w: 10, h: 12,
  vx:0, vy:0,
  roamSeed: (Math.random()*9999)|0,
  bond: state.lucas.bond|0,
  mood: state.lucas.mood || "cool",
};

// Drivable car
const car={
  x: state.street.car.x, y: state.street.car.y,
  w: 18, h: 10,
  vx: state.street.car.vx||0, vy: state.street.car.vy||0,
  fuel: 100
};

// HOME driveway snap
function getHome(){
  return buildings.find(b=>b.tag==="HOME") || buildings[0];
}
function drivewaySpot(){
  const h=getHome();
  const dx = Math.round(h.x + h.w/2 - car.w/2);
  const dy = Math.round(h.y + h.h + S(22));
  return {
    x: clamp(dx, 0, WORLD.w-car.w),
    y: clamp(dy, 0, WORLD.h-car.h)
  };
}
function snapCarToDriveway(reason=""){
  if(state.street.inCar) return;
  const d=drivewaySpot();
  car.x=d.x; car.y=d.y; car.vx=0; car.vy=0;
  state.street.car.x=car.x; state.street.car.y=car.y; state.street.car.vx=0; state.street.car.vy=0;
  saveState();
  if(reason) toast(reason, 1200);
}

// Force car to exist + be findable (fix “I don’t show up with a car”)
function validateCarOnLoad(){
  const bad = (car.x==null || car.y==null || !isFinite(car.x) || !isFinite(car.y));
  const out = (car.x<0 || car.y<0 || car.x>WORLD.w || car.y>WORLD.h);
  const tooFar = dist2(car.x,car.y,sophia.x,sophia.y) > (WORLD.w*WORLD.w + WORLD.h*WORLD.h)*0.90;
  if(bad || out || tooFar){
    snapCarToDriveway("Car found its way back home.");
  }else{
    // if it spawns inside a solid because of old saves, relocate
    if(collides(car.x,car.y,car.w,car.h)) snapCarToDriveway("Car re-parked.");
  }
}
validateCarOnLoad();

/* ---------- collisions ---------- */
function collides(x,y,w,h){
  for(const s of solids){
    if(rectsOverlap(x,y,w,h, s[0],s[1],s[2],s[3])) return true;
  }
  return false;
}
function tryMove(ent,dx,dy){
  const nx=ent.x+dx, ny=ent.y+dy;
  if(!collides(nx,ent.y,ent.w,ent.h)) ent.x=nx;
  if(!collides(ent.x,ny,ent.w,ent.h)) ent.y=ny;
  ent.x=clamp(ent.x,0,WORLD.w-ent.w);
  ent.y=clamp(ent.y,0,WORLD.h-ent.h);
}
function tryMoveCar(dx,dy){
  const nx=car.x+dx, ny=car.y+dy;
  if(!collides(nx,car.y,car.w,car.h)) car.x=nx; else { car.vx*=-0.35; cam.shake=8; }
  if(!collides(car.x,ny,car.w,car.h)) car.y=ny; else { car.vy*=-0.35; cam.shake=8; }
  car.x=clamp(car.x,0,WORLD.w-car.w);
  car.y=clamp(car.y,0,WORLD.h-car.h);
}

/* ---------- Zones/Interactions helpers ---------- */
function buildingDoorRect(b){ return [b.x + b.w/2 - 18, b.y + b.h - 10, 36, 10]; }
const near=(px,py, x,y,r)=>dist2(px,py,x,y)<r*r;

function go(file){
  state.sophia.x=sophia.x; state.sophia.y=sophia.y;
  state.milo.x=milo.x; state.milo.y=milo.y;
  state.street.car={x:car.x,y:car.y,vx:car.vx,vy:car.vy};

  state.lucas.called = lucas.called;
  state.lucas.active = lucas.active;
  state.lucas.x = lucas.x; state.lucas.y = lucas.y;
  state.lucas.bond = lucas.bond;
  state.lucas.mood = lucas.mood;

  saveState();
  location.href=file;
}

/* Payphone */
const payphone={x:S(520),y:S(1120),w:16,h:18};
function payphoneRect(){ return [payphone.x,payphone.y,payphone.w,payphone.h]; }

/* Determine nearest zone */
function nearestZone(){
  const px = state.street.inCar ? car.x+car.w/2 : sophia.x+sophia.w/2;
  const py = state.street.inCar ? car.y+car.h/2 : sophia.y+sophia.h/2;

  let best=null, bd=1e12;

  // TALK PEDS FIRST
  if(!state.street.inCar && !state.street.hidden){
    for(const p of peds){
      const d=dist2(px,py,p.x+5,p.y+6);
      if(d<bd && d<S(2200)){
        best={name:(p.type==="robber"?"CONFRONT ROBBER":"TALK"), rect:[p.x,p.y,p.w,p.h], action:()=>talkPed(p)};
        bd=d;
      }
    }
  }

  // Lucas
  if(!state.street.inCar && lucas.active && !state.street.hidden){
    const d=dist2(px,py,lucas.x+5,lucas.y+6);
    if(d<bd && d<S(2200)){
      best={name:"LUCAS", rect:[lucas.x,lucas.y,lucas.w,lucas.h], action:()=>talkLucas()};
      bd=d;
    }
  }

  // buildings
  for(const b of buildings){
    const rect=buildingDoorRect(b);
    const cx=rect[0]+rect[2]/2, cy=rect[1]+rect[3]/2;
    const d=dist2(px,py,cx,cy);
    if(d<bd && d<S(2200)){
      if(b.link){
        best={name:(b.name==="STARR"?"STARR BUILDING":"ENTER "+b.name), rect, action:()=>go(b.link)};
      }else{
        best={name: (b.tag==="CAF"?"COFFEE COUNTER":(b.tag==="ARC"?"ARCADE DOOR":(b.tag==="GAS"?"GAS PUMP":"(LOCKED)"))), rect,
          action:()=>interactBuilding(b)};
      }
      bd=d;
    }
  }

  // payphone
  if(!state.street.inCar && !state.street.hidden){
    const pr=payphoneRect();
    const cx=pr[0]+pr[2]/2, cy=pr[1]+pr[3]/2;
    const d=dist2(px,py,cx,cy);
    if(d<bd && d<S(1800)){
      best={name:"PAYPHONE", rect:pr, action:()=>go("payphone.html")};
      bd=d;
    }
  }

  // car
  const carRect=[car.x-8,car.y-8,car.w+16,car.h+16];
  {
    const cx=carRect[0]+carRect[2]/2, cy=carRect[1]+carRect[3]/2;
    const d=dist2(px,py,cx,cy);
    if(d<bd && d<S(2600)){
      best={name: state.street.inCar ? "EXIT CAR" : "ENTER CAR", rect:carRect, action:toggleCar};
      bd=d;
    }
  }

  // dumpsters
  if(!state.street.inCar){
    for(const dmp of dumpsters){
      const cx=dmp.x+dmp.w/2, cy=dmp.y+dmp.h/2;
      const d=dist2(px,py,cx,cy);
      if(d<bd && d<S(1800)){
        best={name:"DUMPSTER (HIDE)", rect:[dmp.x,dmp.y,dmp.w,dmp.h], action:startHide};
        bd=d;
      }
    }
  }

  // benches
  if(!state.street.inCar){
    for(const bn of benches){
      const d=dist2(px,py,bn.x+bn.w/2,bn.y+bn.h/2);
      if(d<bd && d<S(1500)){
        best={name:"BENCH (SIT)", rect:[bn.x,bn.y,bn.w,bn.h], action:sitBench};
        bd=d;
      }
    }
  }

  // mailboxes
  if(!state.street.inCar){
    for(const mb of mailboxes){
      const d=dist2(px,py,mb.x+5,mb.y+5);
      if(d<bd && d<S(1400)){
        best={name:"MAILBOX", rect:[mb.x,mb.y,mb.w,mb.h], action:()=>mailboxInteract(mb)};
        bd=d;
      }
    }
  }

  // vending
  if(!state.street.inCar){
    for(const v of vending){
      const d=dist2(px,py,v.x+7,v.y+9);
      if(d<bd && d<S(1500)){
        best={name:"VENDING", rect:[v.x,v.y,v.w,v.h], action:()=>vendingInteract(v)};
        bd=d;
      }
    }
  }

  // photo spots
  if(!state.street.inCar){
    for(const ps of photoSpots){
      const d=dist2(px,py,ps.x+9,ps.y+9);
      if(d<bd && d<S(1600)){
        best={name:"PHOTO SPOT", rect:[ps.x,ps.y,ps.w,ps.h], action:()=>photoInteract(ps)};
        bd=d;
      }
    }
  }

  return best;
}

function interact(){
  if(dialog.on) return;
  const z=nearestZone();
  if(z) z.action();
}

/* ==========================================================
   QUESTS / DIALOG / GAMEPLAY / DRAW
   ========================================================== */
/* NOTE: Everything below is identical logic to your version.
   Only small numeric thresholds were wrapped with S() where needed,
   and Big Map overlay size was reduced.
   (To keep this message readable, I kept the rest unchanged.) */

const QUESTS={
  "DELIVER_FLYERS":{
    name:"Deliver Flyers",
    short:"FLYERS",
    objective:"Deliver flyers to 3 mailboxes (GROC, BLCK, CAT).",
    hint:"Look for MAILBOX near shops. Press E on them.",
    init:()=>({delivered:{MB_GROC:false,MB_BLCK:false,MB_CAT:false}, count:0}),
    onMailbox:(q, mbId)=>{
      if(q.delivered[mbId]===false){
        q.delivered[mbId]=true;
        q.count++;
        return true;
      }
      return false;
    },
    isDone:(q)=>q.count>=3,
    reward:()=>({cash:15, mush:2, msg:"Flyers delivered. Cash + Mush."})
  },
  "POSTER_SELFIE":{
    name:"Poster Selfie",
    short:"PHOTO",
    objective:"Hit 2 photo spots for promo shots (WALL + STAR).",
    hint:"Press E on PHOTO SPOT. It's a mini-fame ritual.",
    init:()=>({PS_WALL:false, PS_STAR:false}),
    isDone:(q)=>q.PS_WALL && q.PS_STAR,
    reward:()=>({cash:10, mush:1, msg:"Promo shots done. Hype unlocked."})
  },
  "Purse_Snatch":{
    name:"Purse Snatch",
    short:"PURSE",
    objective:"Chase the robber and get the purse back. Return it to the old lady.",
    hint:"Robber runs when you get close. Corner them, then press E.",
    init:()=>({gotPurse:false, returned:false}),
    isDone:(q)=>q.returned,
    reward:()=>({cash:25, mush:1, msg:"Purse returned. The city remembers kindness."})
  }
};

function activeQuest(){
  const id=state.quests.activeId;
  if(!id) return null;
  const def=QUESTS[id];
  if(!def) return null;
  if(!state.quests.data[id]) state.quests.data[id]=def.init();
  return {id, def, data:state.quests.data[id]};
}
function setActiveQuest(id){
  if(!QUESTS[id]) return;
  state.quests.activeId=id;
  if(!state.quests.data[id]) state.quests.data[id]=QUESTS[id].init();
  UI.questShort.textContent = QUESTS[id].short;
  toast("Quest accepted: "+QUESTS[id].name, 1400);
  syncJournal();
  maybeAutoWaypoint(true);
  saveState();
}
function completeQuest(id){
  const def=QUESTS[id];
  if(!def) return;
  const reward=def.reward();
  state.cash += reward.cash|0;
  state.street.mush += reward.mush|0;
  UI.cash.textContent=state.cash|0;
  UI.mush.textContent=state.street.mush|0;

  state.quests.completed[id]=true;
  state.quests.activeId=null;
  UI.questShort.textContent="NONE";

  toast(reward.msg + ` (+$${reward.cash}, +${reward.mush} mush)`, 1800);
  syncJournal();
  saveState();
}
function syncJournal(){
  const q=activeQuest();
  if(!q){
    UI.qActive.textContent="None";
    UI.qObj.textContent="Explore, talk, or hit the payphone.";
    UI.qHint.textContent="Press Q to close.";
    return;
  }
  UI.qActive.textContent=q.def.name;
  UI.qObj.textContent=q.def.objective;
  UI.qHint.textContent=q.def.hint;
}

/* Dialog */
const dialog={ on:false, say:"", opts:[], onPick:null };
function openDialog(title, say, opts, onPick){
  dialog.on=true; dialog.say=say; dialog.opts=opts; dialog.onPick=onPick;
  UI.dlgTitle.textContent=title;
  UI.dlgSay.textContent=say;
  UI.dlgOpts.innerHTML="";
  opts.forEach((o,i)=>{
    const d=document.createElement("div");
    d.textContent = `${i+1}) ${o}`;
    UI.dlgOpts.appendChild(d);
  });
  UI.dlg.classList.add("on");
}
function closeDialog(){
  dialog.on=false; dialog.say=""; dialog.opts=[]; dialog.onPick=null;
  UI.dlg.classList.remove("on");
}
addEventListener("keydown",(e)=>{
  if(!dialog.on) return;
  const k=e.key.toLowerCase();
  if(k==="escape"){ closeDialog(); return; }
  if(k==="1"||k==="2"||k==="3"){
    const idx = (k==="1"?0:(k==="2"?1:2));
    if(dialog.onPick) dialog.onPick(idx);
    closeDialog();
  }
});

/* Gameplay */
function toggleCar(){
  if(state.street.hidden) return toast("Not while hiding.", 1200);
  if(dialog.on) return;

  if(!state.street.inCar){
    const d=dist2(sophia.x,sophia.y,car.x,car.y);
    if(d>S(2600)) return toast("Get closer to the car.", 1100);
    state.street.inCar=true;
    UI.mode.textContent="IN CAR";
    toast("She hops in. Mirrors? checked. Destiny? pending.", 1600);
    sophia.x=car.x+4; sophia.y=car.y+2;
    milo.x=car.x+car.w-10; milo.y=car.y+2;
    if(lucas.active){ lucas.x=car.x-18; lucas.y=car.y+6; }
  }else{
    const sp=Math.hypot(car.vx,car.vy);
    if(sp>150) return toast("Too fast to jump out.", 1200);
    state.street.inCar=false;
    UI.mode.textContent="ON FOOT";
    toast("Back on foot.", 1200);
    sophia.x=clamp(car.x-14,0,WORLD.w-sophia.w);
    sophia.y=clamp(car.y+2,0,WORLD.h-sophia.h);
  }
  saveState();
}

let hideHold=0;
function startHide(){
  if(state.street.wanted<=0) return toast("She checks the dumpster. (It is… judgemental.)", 1400);
  toast("Hold E to hide…", 1100);
  hideHold=1;
}
function enterHidden(){
  state.street.hidden=true;
  state.street.seen=0;
  toast("Hiding. City audio goes muffled.", 1500);
  saveState();
}
function exitHidden(){
  state.street.hidden=false;
  toast("Out of hiding.", 1200);
  saveState();
}
let sitUntil=0;
function sitBench(){
  if(state.street.wanted>0) return toast("No sitting while wanted.", 1200);
  if(sitUntil>performance.now()) return;
  sitUntil = performance.now()+1800;
  toast("She sits. Breath resets. Camera steadies.", 1400);
  cam.shake=0;
}
const buffs={ coffeeUntil:0 };

function interactBuilding(b){
  if(b.tag==="CAF"){
    if(state.cash<3) return toast("Coffee costs $3. Find coins or finish a quest.", 1500);
    state.cash-=3; UI.cash.textContent=state.cash|0;
    buffs.coffeeUntil = performance.now()+20000;
    toast("Coffee acquired. Speed buff (20s).", 1500);
    saveState();
    return;
  }
  if(b.tag==="ARC"){
    if(state.cash<2) return toast("Arcade token is $2. Retro laws.", 1400);
    state.cash-=2; UI.cash.textContent=state.cash|0;
    if(Math.random()<0.55){
      state.cash += 5; UI.cash.textContent=state.cash|0;
      toast("Arcade win. +$5. Your thumbs are legendary.", 1600);
    }else{
      toast("Arcade loss. The machine laughs politely.", 1400);
    }
    saveState();
    return;
  }
  if(b.tag==="GAS"){
    if(state.cash<4) return toast("Gas station air pump costs $4.", 1500);
    state.cash-=4; UI.cash.textContent=state.cash|0;
    car.fuel = 100;
    toast("Car tuned. Fuel topped. It purrs in pixels.", 1500);
    saveState();
    return;
  }
  if(b.tag==="BEACH"){
    toast("Beach is later. The ocean is currently in pre-production.", 1500);
    return;
  }
  toast("Locked.", 1000);
}

/* Mailbox / vending / photo */
function mailboxInteract(mb){
  if(dialog.on) return;
  const q=activeQuest();
  if(q && q.id==="DELIVER_FLYERS"){
    const did = q.def.onMailbox(q.data, mb.id);
    if(did){
      toast("Flyer delivered.", 1100);
      cam.shake=4;
      if(q.def.isDone(q.data)) completeQuest(q.id);
      saveState();
      return;
    }
    return toast("Already delivered here.", 1100);
  }
  toast("Mailbox. It has secrets. Not yours though.", 1200);
}
function vendingInteract(v){
  if(dialog.on) return;
  if(v.uses<=0) return toast("Vending is empty. It looks tired.", 1200);
  if(state.cash<2) return toast("Snack costs $2.", 1100);
  state.cash-=2; UI.cash.textContent=state.cash|0;
  v.uses--;
  if(Math.random()<0.65){
    state.street.mush += 1; UI.mush.textContent=state.street.mush|0;
    toast("Snack… plus a bonus mushroom?? (+1 mush)", 1500);
  }else{
    toast("Snack acquired. Emotional stability +0.2.", 1400);
  }
  saveState();
}
function photoInteract(ps){
  if(dialog.on) return;
  if(state.street.wanted>0) return toast("No photos while wanted.", 1200);
  const q=activeQuest();
  if(q && q.id==="POSTER_SELFIE"){
    q.data[ps.id]=true;
    toast("Photo captured. (Your future fans approve.)", 1500);
    if(q.def.isDone(q.data)) completeQuest(q.id);
    saveState();
    return;
  }
  state.cash += 1; UI.cash.textContent=state.cash|0;
  toast("Cute shot. +$1 from ‘algorithm.’", 1400);
  saveState();
}

/* Pickups */
function collectPickups(){
  const px = state.street.inCar ? car.x+car.w/2 : sophia.x+sophia.w/2;
  const py = state.street.inCar ? car.y+car.h/2 : sophia.y+sophia.h/2;

  for(const m of mushWorld){
    if(!m.alive) continue;
    if(dist2(px,py,m.x,m.y) < 16*16){
      m.alive=false;
      const add = (m.kind==="gold"?2:1);
      state.street.mush += add;
      UI.mush.textContent=state.street.mush|0;
      toast(m.kind==="gold" ? "GOLD MUSHROOM (+2)" : "Mushroom collected (+1)", 1200);
      saveState();
    }
  }
  for(const c of coins){
    if(!c.alive) continue;
    if(dist2(px,py,c.x,c.y) < 14*14){
      c.alive=false;
      state.cash += c.v|0;
      UI.cash.textContent=state.cash|0;
      toast(c.v>1 ? `Found $${c.v}!` : "Found $1.", 1000);
      saveState();
    }
  }
}

/* Throw mush */
const shots=[];
function canThrow(now){
  if(dialog.on) return false;
  if(now - state.street.lastThrow < 220) return false;
  if(state.street.mush<=0) return false;
  return true;
}
function throwMushroom(now){
  if(state.street.inCar) return toast("Not while driving.", 900);
  if(state.street.hidden) return toast("Not while hiding.", 900);
  if(!canThrow(now)) return;

  state.street.lastThrow=now;
  state.street.mush--;
  UI.mush.textContent=state.street.mush|0;

  let ax=0, ay=0;
  if(keysDown.has("w")||keysDown.has("arrowup")) ay-=1;
  if(keysDown.has("s")||keysDown.has("arrowdown")) ay+=1;
  if(keysDown.has("a")||keysDown.has("arrowleft")) ax-=1;
  if(keysDown.has("d")||keysDown.has("arrowright")) ax+=1;
  if(ax===0 && ay===0){ ax=1; }
  const mag=Math.hypot(ax,ay)||1;
  ax/=mag; ay/=mag;

  shots.push({x:sophia.x+5,y:sophia.y+6,vx:ax*220,vy:ay*220,life:0.55, kind:"mush"});
  saveState();
}

/* Jump (F) */
function jumpHop(now){
  if(dialog.on) return;
  if(state.street.inCar) return toast("Jumping in a car feels… illegal.", 1000);
  if(state.street.hidden) return;
  if(now - (state.street.lastJump||0) < 700) return;
  state.street.lastJump=now;
  sophia.hop = 1.0;
  cam.shake = Math.max(cam.shake, 4);
  let ax=0, ay=0;
  if(keysDown.has("w")||keysDown.has("arrowup")) ay-=1;
  if(keysDown.has("s")||keysDown.has("arrowdown")) ay+=1;
  if(keysDown.has("a")||keysDown.has("arrowleft")) ax-=1;
  if(keysDown.has("d")||keysDown.has("arrowright")) ax+=1;
  if(ax||ay){
    const mag=Math.hypot(ax,ay)||1;
    ax/=mag; ay/=mag;
    tryMove(sophia, ax*14, ay*14);
  }
  saveState();
}

/* Trip */
function tripToggle(){
  if(dialog.on) return;
  if(state.street.inCar) return toast("Trip mode requires feet on ground.", 1200);
  if(state.street.hidden) return toast("Not while hiding.", 1000);
  if(state.street.mush<=0) return toast("No mushrooms to trigger trip mode.", 1200);
  state.street.mush--;
  UI.mush.textContent=state.street.mush|0;
  state.street.tripUntil = performance.now()+12000;
  toast("TRIP MODE (12s). Reality gets wavy.", 1500);
  saveState();
}

/* Wanted */
const cops=[];
function setWanted(w){
  state.street.wanted=clamp(w|0,0,5);
  UI.wanted.textContent=state.street.wanted|0;
  saveState();
}
function bumpWanted(amt=1){
  const before=state.street.wanted|0;
  setWanted(before+amt);
  if(before===0) toast("People panic. Somewhere: sirens wake up.", 1500);
  spawnCops();
}
function markSeen(){ state.street.seen=0; }
function coolWanted(dt){
  if(state.street.wanted<=0) return;
  const step = state.street.hidden ? 2.5 : 1.0;
  state.street.seen += step*(dt*60);
  if(state.street.seen > 480){
    state.street.seen=0;
    setWanted(state.street.wanted-1);
    toast("Heat drops. The city forgets a little.", 1300);
    if(state.street.wanted<=1) cops.splice(0, Math.max(0,cops.length-2));
  }
}
function spawnCops(){
  const target = 1 + (state.street.wanted|0)*2;
  while(cops.length<target){
    const edge=(Math.random()*4)|0;
    let x=0,y=0;
    if(edge===0){x=rand(0,WORLD.w); y=10;}
    if(edge===1){x=rand(0,WORLD.w); y=WORLD.h-20;}
    if(edge===2){x=10; y=rand(0,WORLD.h);}
    if(edge===3){x=WORLD.w-20; y=rand(0,WORLD.h);}
    cops.push({x,y,w:10,h:12, lose:0, stunned:0, blink:(Math.random()*999)|0});
  }
}
function blockedByBuilding(ax,ay,bx,by){
  const steps=7;
  for(let i=1;i<steps;i++){
    const t=i/steps;
    const x=ax+(bx-ax)*t;
    const y=ay+(by-ay)*t;
    for(const b of buildings){
      if(x>=b.x && x<=b.x+b.w && y>=b.y && y<=b.y+b.h) return true;
    }
  }
  return false;
}
function updateCops(t,dt){
  if(state.street.wanted<=0){ cops.length=0; return; }
  const tx = state.street.inCar ? car.x+car.w/2 : sophia.x+sophia.w/2;
  const ty = state.street.inCar ? car.y+car.h/2 : sophia.y+sophia.h/2;

  for(const c of cops){
    if(c.stunned>0){ c.stunned-=dt*60; if(c.stunned<0)c.stunned=0; continue; }
    const dx=tx-(c.x+5), dy=ty-(c.y+6);
    const d=Math.hypot(dx,dy)||1;

    const inRange = (!state.street.hidden && d<S(280)) || (state.street.hidden && d<S(70));
    const blocked = blockedByBuilding(c.x+5,c.y+6, tx,ty);
    const seen = inRange && !blocked;

    if(seen){ c.lose=0; markSeen(); }
    else c.lose += dt*60;

    let sp=90 + 18*(state.street.wanted|0);
    let vx=0,vy=0;
    if(state.street.hidden && c.lose>100){
      vx=Math.sin((t+c.blink)*0.03)*26;
      vy=Math.cos((t+c.blink)*0.04)*26;
    }else{
      vx=(dx/d)*sp;
      vy=(dy/d)*sp;
    }

    const nx=c.x+vx*dt, ny=c.y+vy*dt;
    if(!collides(nx,c.y,c.w,c.h)) c.x=nx;
    if(!collides(c.x,ny,c.w,c.h)) c.y=ny;

    if(!state.street.hidden){
      if(state.street.inCar){
        if(rectsOverlap(c.x,c.y,c.w,c.h, car.x,car.y,car.w,car.h)){
          toast("Cop bumps your bumper.", 1100);
          car.vx*=-0.5; car.vy*=-0.5;
          cam.shake=10;
          if(Math.random()<0.16) bumpWanted(1);
        }
      }else{
        if(rectsOverlap(c.x,c.y,c.w,c.h, sophia.x,sophia.y,sophia.w,sophia.h)){
          toast("Caught. They lecture you about public mushroom safety.", 1400);
          if(state.street.mush>0){ state.street.mush--; UI.mush.textContent=state.street.mush|0; }
          sophia.x=clamp(sophia.x - dx*0.02,0,WORLD.w-sophia.w);
          sophia.y=clamp(sophia.y - dy*0.02,0,WORLD.h-sophia.h);
          markSeen();
          cam.shake=7;
        }
      }
    }
  }
}

/* Traffic cars */
const traffic=[];
for(let i=0;i<20;i++){
  const r=roads[(Math.random()*roads.length)|0];
  const x=rand(r.x+20, r.x+r.w-40);
  const y=rand(r.y+20, r.y+r.h-20);
  const dir = (Math.random()<0.5) ? "east" : "west";
  traffic.push({
    x,y,w:18,h:10,
    vx: dir==="east" ? rand(30,70) : rand(-70,-30),
    vy: 0,
    color: (Math.random()<0.33?"vio":(Math.random()<0.5?"aqua":"sun")),
    beep: 0,
    wait: 0,
  });
}
function nearestLightForCar(x,y){
  let best=null, bd=1e12;
  for(const L of lights){
    const d=dist2(x,y,L.x,L.y);
    if(d<bd && d<S(160)*S(160)){ best=L; bd=d; }
  }
  return best;
}
function updateTraffic(t,dt){
  for(const v of traffic){
    let nx=v.x+v.vx*dt, ny=v.y+v.vy*dt;

    const L=nearestLightForCar(v.x+v.w/2, v.y+v.h/2);
    if(L){
      const st=lightState(L,t);
      const movingEW = Math.abs(v.vx)>Math.abs(v.vy);
      const allow = movingEW ? (st==="EW_G" || st==="EW_Y") : (st==="NS_G" || st==="NS_Y");
      const close = dist2(v.x,v.y,L.x,L.y) < S(70)*S(70);
      if(close && !allow) v.wait = Math.min(1.0, v.wait + dt*2.2);
      else v.wait = Math.max(0, v.wait - dt*1.8);
    }else{
      v.wait = Math.max(0, v.wait - dt*1.2);
    }

    const waitMul = 1.0 - v.wait;

    if(!isOnRoad(nx+v.w/2, ny+v.h/2)){
      v.vx *= -1;
      nx=v.x+v.vx*dt;
    }

    if(collides(nx, v.y, v.w, v.h)){ v.vx*=-1; nx=v.x+v.vx*dt; }
    if(collides(v.x, ny, v.w, v.h)){ v.vy*=-1; ny=v.y+v.vy*dt; }

    v.x = clamp(lerp(v.x,nx,waitMul),0,WORLD.w-v.w);
    v.y = clamp(lerp(v.y,ny,waitMul),0,WORLD.h-v.h);

    if(state.street.inCar && dist2(v.x,v.y,car.x,car.y)<S(60)*S(60) && Math.random()<0.01){
      v.beep=40;
      toast("BEEP! (traffic car is offended)", 900);
    }
    if(v.beep>0) v.beep--;
  }
}

/* Duck */
const duck={x: pond.x+S(80), y: pond.y+S(92), vx:0.28, vy:0.12, t:0};

/* Pedestrians + Roles */
const peds=[];
const PED_LINES=[
  "Good luck at STARR. Your outfit says ‘main character.’",
  "Topanga road is pretty. Also slightly cursed. In a cute way.",
  "Audition nerves? Breathe like you’re hiding from a thought.",
  "Arcade hums like a tiny universe.",
  "Coffee shop is a speed buff. Don’t ask, just sip.",
  "Follow Your Heart has soup that feels like a hug with rules.",
  "Duck pond is a real place. City lore confirmed.",
  "If you see a robber… do your hero thing.",
];
function makePed(x,y,opts={}){
  const hair = opts.hair ?? (Math.random()<0.33?"blonde":(Math.random()<0.5?"brown":"black"));
  const shirt = opts.shirt ?? (Math.random()<0.33?"vio":(Math.random()<0.5?"aqua":"sun"));
  const hasDog = opts.hasDog ?? (Math.random()<0.18);
  const role = opts.role ?? (Math.random()<0.08?"QUEST":(Math.random()<0.12?"VENDOR":"NORM"));
  const type = opts.type ?? "ped";
  return {
    x,y,w:10,h:12,
    vx:rand(-0.25,0.25), vy:rand(-0.25,0.25),
    hair, shirt, hasDog,
    dog: hasDog ? {x:x-12,y:y+6, vx:0,vy:0} : null,
    wave:0,
    stunned:0,
    role,
    type,
    line: opts.line ?? PED_LINES[(Math.random()*PED_LINES.length)|0],
    id: opts.id ?? ("PED_"+((Math.random()*1e9)|0)),
    angry:0,
    performer: opts.performer ?? null,
    fight: { hp: opts.hp ?? 0, active:false, who:null, cooldown:0 },
  };
}
for(let i=0;i<62;i++){
  let x=rand(S(140),WORLD.w-S(140)), y=rand(S(180),WORLD.h-S(180));
  if(isOnRoad(x,y)) y += (Math.random()<0.5?-S(90):S(90));
  peds.push(makePed(x,y));
}
peds.push(makePed(S(700),S(980),{role:"NORM",type:"performer",performer:"guitar",line:"(guitar) Want a song? Press E, tip $1."}));
peds.push(makePed(S(980),S(980),{role:"NORM",type:"performer",performer:"dancer",line:"(dance) Pick a vibe: 1) hype 2) smooth 3) weird."}));
peds.push(makePed(S(1220),S(980),{role:"NORM",type:"performer",performer:"clown",line:"(clown) I can juggle feelings. Want chaos?"}));
peds.push(makePed(S(520),S(360),{role:"NORM",type:"performer",performer:"statue",line:"(statue) ... (they blink)"}));

const catcallers=[
  makePed(S(2140),S(1180),{type:"catcaller",role:"NORM",line:"Construction Worker: “Hey Sophia! You look like a movie scene.”", shirt:"sun"}),
  makePed(S(2170),S(1180),{type:"catcaller",role:"NORM",line:"Other Worker: “For real, you’re glowing.”", shirt:"sun"}),
];
catcallers[0].id="CATCALL_A";
catcallers[1].id="CATCALL_B";
peds.push(...catcallers);

const oldLady = makePed(S(860),S(860),{type:"oldlady",role:"NORM",line:"Old Lady: “My purse… I just bought oranges…”", hair:"white", shirt:"aqua"});
oldLady.id="OLD_LADY";
peds.push(oldLady);

const robber = makePed(S(900),S(860),{type:"robber",role:"NORM",line:"Robber: “Nope.”", hair:"black", shirt:"vio", hp:6});
robber.id="ROBBER";
robber.fight.hp=6;
peds.push(robber);

/* Quest bootstrap & ped update */
function updatePeds(t,dt){
  if(state.events.purse.stage==="idle"){
    state.events.purse.stage="snatched";
    setActiveQuest("Purse_Snatch");
    toast("A robber snatches an old lady’s purse!", 1700);
    saveState();
  }
  const q=activeQuest();

  for(const p of peds){
    if(p.fight.cooldown>0) p.fight.cooldown -= dt*60;
    if(p.stunned>0){ p.stunned-=dt*60; if(p.stunned<0)p.stunned=0; continue; }

    if(p.type==="robber" && q && q.id==="Purse_Snatch" && !q.data.gotPurse){
      const dx=(sophia.x - p.x), dy=(sophia.y - p.y);
      const d=Math.hypot(dx,dy)||1;
      if(d<S(140)){
        p.vx = clamp((-dx/d)*0.95, -1.2, 1.2);
        p.vy = clamp((-dy/d)*0.95, -1.2, 1.2);
      }else{
        if(Math.random()<0.02){ p.vx += rand(-0.10,0.10); p.vy += rand(-0.10,0.10); }
        p.vx=clamp(p.vx,-0.40,0.40);
        p.vy=clamp(p.vy,-0.40,0.40);
      }
    }else{
      if(Math.random()<0.02){
        p.vx += rand(-0.10,0.10);
        p.vy += rand(-0.10,0.10);
      }
      p.vx=clamp(p.vx,-0.40,0.40);
      p.vy=clamp(p.vy,-0.40,0.40);
    }

    if(p.performer==="statue"){ p.vx*=0.2; p.vy*=0.2; }

    let nx=p.x+p.vx*(dt*60), ny=p.y+p.vy*(dt*60);

    if(isOnRoad(nx,ny)){
      ny += (Math.random()<0.5 ? -1 : 1)*1.6;
      nx += (Math.random()<0.5 ? -1 : 1)*0.8;
    }

    if(!collides(nx,p.y,p.w,p.h)) p.x=nx; else p.vx*=-0.8;
    if(!collides(p.x,ny,p.w,p.h)) p.y=ny; else p.vy*=-0.8;

    p.x=clamp(p.x,0,WORLD.w-p.w);
    p.y=clamp(p.y,0,WORLD.h-p.h);

    if(state.street.wanted===0 && !state.street.inCar && dist2(p.x,p.y,sophia.x,sophia.y)<S(95)*S(95)){
      p.wave = Math.min(60, p.wave+2);
    }else{
      p.wave = Math.max(0, p.wave-1);
    }

    if(p.hasDog && p.dog){
      const dx=(p.x-12)-p.dog.x;
      const dy=(p.y+6)-p.dog.y;
      p.dog.x += dx*0.06*(dt*60);
      p.dog.y += dy*0.06*(dt*60);
    }
  }

  duck.t += dt;
  duck.x += duck.vx*(dt*60);
  duck.y += duck.vy*(dt*60);
  if(duck.x<pond.x+S(20)||duck.x>pond.x+pond.w-S(20)) duck.vx*=-1;
  if(duck.y<pond.y+S(20)||duck.y>pond.y+pond.h-S(20)) duck.vy*=-1;
}

/* Talk / fight (same) */
function talkLucas(){
  if(dialog.on) return;
  openDialog(
    "Lucas",
    "Lucas: “We got this. Want me to stick close, or roam and scout?”",
    ["Stick closer", "Roam freer", "Head home (dismiss)"],
    (pick)=>{
      if(pick===0){ lucas.mood="close"; toast("Lucas stays closer.", 1200); }
      if(pick===1){ lucas.mood="roam"; toast("Lucas roams freer.", 1200); }
      if(pick===2){ lucas.active=false; toast("Lucas heads off. (You can call again at the payphone.)", 1600); }
      state.lucas.active=lucas.active;
      state.lucas.mood=lucas.mood;
      saveState();
      UI.lucasText.textContent = lucas.called ? (lucas.active?"Following":"Called (not here)") : "Not called";
    }
  );
}

function startArcadeFight(p){
  p.fight.active=true;
  p.fight.hp = p.fight.hp || 5;
  p.angry=240;
  toast("They get mad. Quick scuffle!", 1200);
}
function resolveFightHit(p){
  if(p.fight.cooldown>0) return;
  p.fight.cooldown=18;
  p.fight.hp -= 1;
  cam.shake=6;
  if(p.fight.hp<=0){
    p.fight.active=false;
    p.angry=0;
    p.stunned=1.3;
    toast("Fight over. They back off.", 1200);
    if(Math.random()<0.12) bumpWanted(1);
  }else{
    toast("Hit! (spam E near them)", 700);
  }
}

function catcallDialog(){
  if(dialog.on) return;
  openDialog(
    "Street Moment",
    "Two construction workers are catcalling. Sophia’s bubble pops up…",
    ["Yell at them", "Thank them (keep it moving)", "Ignore and walk"],
    (pick)=>{
      state.events.catcall.done=true;
      if(pick===0){
        toast("Sophia: “Relax.” They get salty.", 1400);
        if(Math.random()<0.5){
          startArcadeFight(catcallers[0]);
          startArcadeFight(catcallers[1]);
        }
      }else if(pick===1){
        toast("Sophia: “Thanks.” They cheer, then go back to work.", 1400);
        state.cash += 1; UI.cash.textContent=state.cash|0;
      }else{
        toast("Sophia keeps walking. Silence wins.", 1300);
      }
      saveState();
    }
  );
}

function talkPed(p){
  const now=performance.now();
  if(now - state.street.lastTalk < 260) return;
  state.street.lastTalk=now;

  if(p.type==="catcaller" && !state.events.catcall.done){
    return catcallDialog();
  }

  const q=activeQuest();
  if(p.type==="oldlady"){
    if(q && q.id==="Purse_Snatch"){
      if(q.data.gotPurse && !q.data.returned){
        q.data.returned=true;
        toast("You returned the purse. Old Lady: “Thank you, sweetheart…”", 1700);
        completeQuest(q.id);
        state.events.purse.rewardGiven=true;
        saveState();
        return;
      }
      if(!q.data.gotPurse){
        toast("Old Lady: “Please… he ran toward the boulevard…”", 1500);
        return;
      }
    }
    return toast(p.line, 1500);
  }

  if(p.type==="robber"){
    if(q && q.id==="Purse_Snatch" && !q.data.gotPurse){
      openDialog(
        "Robber",
        "Robber: “Don’t be a hero.”",
        ["Give it back", "Try to grab it", "Let him go"],
        (pick)=>{
          if(pick===0){
            if(Math.random()<0.55){
              q.data.gotPurse=true;
              toast("He drops the purse and bolts.", 1500);
              p.stunned=1.4;
              maybeAutoWaypoint(true);
              saveState();
            }else{
              toast("He laughs and shoves past. Chase him!", 1400);
              startArcadeFight(p);
            }
          }else if(pick===1){
            startArcadeFight(p);
          }else{
            toast("He runs. The city side-eyes you.", 1500);
            if(Math.random()<0.25) bumpWanted(1);
          }
        }
      );
      return;
    }
    return toast("Robber: “…”", 900);
  }

  if(p.type==="performer"){
    if(p.performer==="guitar"){
      if(state.cash<=0) return toast("Guitar Player: “Tip $1 and I’ll play.”", 1400);
      openDialog("Guitar Player","Pick a song vibe.",["Melancholy","Hype","Dreamy"],(pick)=>{
        state.cash -= 1; UI.cash.textContent=state.cash|0;
        const lines=["A soft riff drips into the street.","A fast riff sparks the crosswalk.","A dreamy riff makes the air shimmer."];
        toast(lines[pick], 1600);
        if(lucas.active){ lucas.bond += 1; }
        saveState();
      });
      return;
    }
    if(p.performer==="dancer"){
      openDialog("Street Dancer","The dancer asks you to pick the routine.",["Hype","Smooth","Weird"],(pick)=>{
        const lines=["They go OFF. Crowd claps.","It’s smooth like sliding on sunlight.","It gets experimental. Art happens."];
        toast(lines[pick], 1500);
        state.cash += (pick===0?2:1); UI.cash.textContent=state.cash|0;
        saveState();
      });
      return;
    }
    if(p.performer==="clown"){
      openDialog("Clown","Clown: “Choose your chaos.”",["Balloon animal","Bad joke","Tiny magic trick"],(pick)=>{
        const lines=["A balloon dog appears. It looks judgmental.","A joke lands like a pillow. Soft impact.","A coin vanishes… then returns behind your ear."];
        toast(lines[pick], 1500);
        if(pick===2){ state.cash += 1; UI.cash.textContent=state.cash|0; }
        if(pick===1 && Math.random()<0.25){ startArcadeFight(p); }
        saveState();
      });
      return;
    }
    if(p.performer==="statue"){
      toast("The statue doesn’t move… then blinks.", 1500);
      return;
    }
  }

  if(Math.random()<0.18){
    openDialog(
      "Stranger",
      "NPC: “You talking to me?”",
      ["Compliment them", "Be rude", "Ask for directions"],
      (pick)=>{
        if(pick===0){
          toast("They smile. “Thanks.”", 1400);
          state.cash += 1; UI.cash.textContent=state.cash|0;
        }else if(pick===1){
          toast("They get mad.", 1200);
          startArcadeFight(p);
        }else{
          toast("They point: “STARR is north-east.”", 1400);
          setWaypoint(S(2550), S(320), "STARR AREA");
        }
        saveState();
      }
    );
    return;
  }

  toast(p.line, 1500);
}

/* shots */
function anyCopSeesPoint(x,y){
  if(state.street.wanted<=0 || cops.length===0) return false;
  for(const c of cops){
    const d=dist2(c.x,c.y,x,y);
    if(d<S(280)*S(280) && !blockedByBuilding(c.x+5,c.y+6,x,y)) return true;
  }
  return false;
}
function updateShots(dt){
  for(let i=shots.length-1;i>=0;i--){
    const s=shots[i];
    s.x += s.vx*dt;
    s.y += s.vy*dt;
    s.life -= dt;

    if(collides(s.x,s.y,2,2)){ shots.splice(i,1); continue; }

    for(const p of peds){
      if(p.stunned>0) continue;
      if(rectsOverlap(s.x,s.y,2,2, p.x,p.y,p.w,p.h)){
        p.stunned=2.0;
        shots.splice(i,1);
        if(anyCopSeesPoint(p.x+5,p.y+6)) bumpWanted(1);
        else if(Math.random()<0.22) bumpWanted(1);
        toast("SPLAT. Ped stunned.", 1200);
        break;
      }
    }
    if(i>=shots.length) continue;

    for(const c of cops){
      if(c.stunned>0) continue;
      if(rectsOverlap(s.x,s.y,2,2, c.x,c.y,c.w,c.h)){
        c.stunned=2.2;
        shots.splice(i,1);
        bumpWanted(1);
        toast("You hit a cop with a mushroom.", 1300);
        break;
      }
    }
    if(i>=shots.length) continue;

    if(s.life<=0) shots.splice(i,1);
  }
}

/* car hits */
function checkCarHits(){
  if(!state.street.inCar) return;
  for(const p of peds){
    if(p.stunned>0) continue;
    if(rectsOverlap(car.x,car.y,car.w,car.h, p.x,p.y,p.w,p.h)){
      p.stunned=2.6;
      bumpWanted(2);
      toast("You hit someone. Sirens wake up.", 1600);
      car.vx*=-0.35; car.vy*=-0.35;
      cam.shake=14;
      markSeen();
    }
  }
}

/* Lucas follow */
function updateLucas(t,dt){
  if(!lucas.called) return;
  if(!lucas.active) return;
  if(state.street.inCar){
    const tx=car.x-18, ty=car.y+6;
    lucas.x += (tx-lucas.x)*0.10*(dt*60);
    lucas.y += (ty-lucas.y)*0.10*(dt*60);
    return;
  }
  if(state.street.hidden){
    const tx=sophia.x-14, ty=sophia.y+10;
    lucas.x += (tx-lucas.x)*0.06*(dt*60);
    lucas.y += (ty-lucas.y)*0.06*(dt*60);
    return;
  }

  const mood = lucas.mood || "roam";
  const radius = (mood==="close") ? 36 : 92;

  const ang = (t*0.03) + (lucas.roamSeed*0.001);
  const ox = Math.cos(ang)*radius;
  const oy = Math.sin(ang*0.9)*radius*0.7;

  const ax = sophia.x + ox;
  const ay = sophia.y + oy;

  const dx=ax - lucas.x;
  const dy=ay - lucas.y;
  const d=Math.hypot(dx,dy)||1;

  const sp = d>S(120) ? 110 : (d>S(60)?85:55);
  lucas.vx += (dx/d)*sp*dt;
  lucas.vy += (dy/d)*sp*dt;

  lucas.vx *= Math.pow(0.86, dt*60);
  lucas.vy *= Math.pow(0.86, dt*60);

  const maxSp=140;
  const s=Math.hypot(lucas.vx,lucas.vy);
  if(s>maxSp){ lucas.vx=(lucas.vx/s)*maxSp; lucas.vy=(lucas.vy/s)*maxSp; }

  const nx=lucas.x+lucas.vx*dt, ny=lucas.y+lucas.vy*dt;
  if(!collides(nx,lucas.y,lucas.w,lucas.h)) lucas.x=nx; else lucas.vx*=-0.3;
  if(!collides(lucas.x,ny,lucas.w,lucas.h)) lucas.y=ny; else lucas.vy*=-0.3;

  lucas.x=clamp(lucas.x,0,WORLD.w-lucas.w);
  lucas.y=clamp(lucas.y,0,WORLD.h-lucas.h);

  if(dist2(lucas.x,lucas.y,sophia.x,sophia.y)<S(70)*S(70) && (t%120|0)===0){
    lucas.bond = Math.min(999, lucas.bond+1);
  }
}

/* Movement + camera */
function updatePlayer(t,dt){
  if(dialog.on) return;

  if(state.street.hidden){
    if(!keysDown.has("e")) exitHidden();
    return;
  }

  const coffeeOn = performance.now() < buffs.coffeeUntil;
  const speedMul = coffeeOn ? 1.12 : 1.0;

  // keep car near home if it drifts to nonsense
  const h=getHome();
  const nearHome = dist2(sophia.x,sophia.y, h.x+h.w/2, h.y+h.h) < S(260)*S(260);
  if(!state.street.inCar && nearHome && dist2(car.x,car.y, h.x+h.w/2, h.y+h.h) > S(650)*S(650)){
    snapCarToDriveway("");
  }

  if(state.street.inCar){
    const boostHeld = keysDown.has("shift");
    const boost = boostHeld ? 1.34 : 1.0;

    let ax=0, ay=0;
    if(keysDown.has("w")||keysDown.has("arrowup")) ay-=1;
    if(keysDown.has("s")||keysDown.has("arrowdown")) ay+=1;
    if(keysDown.has("a")||keysDown.has("arrowleft")) ax-=1;
    if(keysDown.has("d")||keysDown.has("arrowright")) ax+=1;
    if(ax && ay){ ax*=0.72; ay*=0.72; }

    const accel=320*boost;
    car.vx += ax*accel*dt;
    car.vy += ay*accel*dt;

    const drag = boostHeld ? 0.935 : 0.915;
    car.vx *= Math.pow(drag, dt*60);
    car.vy *= Math.pow(drag, dt*60);

    const maxSp=280*boost;
    const sp=Math.hypot(car.vx,car.vy);
    if(sp>maxSp){
      car.vx=(car.vx/sp)*maxSp;
      car.vy=(car.vy/sp)*maxSp;
    }

    if(sp>40) car.fuel = Math.max(0, car.fuel - dt*(boostHeld?4.2:3.5));
    if(car.fuel<=0){
      car.vx *= 0.90;
      car.vy *= 0.90;
      if((t%30|0)===0) toast("Out of fuel. Find GAS.", 900);
    }

    tryMoveCar(car.vx*dt,car.vy*dt);

    sophia.x=car.x+4; sophia.y=car.y+2;
    milo.x=car.x+car.w-10; milo.y=car.y+2;

  }else{
    const run=keysDown.has("shift");
    const sp=(run?sophia.run:sophia.speed)*speedMul;

    let dx=0,dy=0;
    if(keysDown.has("w")||keysDown.has("arrowup")) dy-=sp*dt;
    if(keysDown.has("s")||keysDown.has("arrowdown")) dy+=sp*dt;
    if(keysDown.has("a")||keysDown.has("arrowleft")) dx-=sp*dt;
    if(keysDown.has("d")||keysDown.has("arrowright")) dx+=sp*dt;
    if(dx && dy){ dx*=0.72; dy*=0.72; }
    if(dx||dy) tryMove(sophia,dx,dy);

    const tx=sophia.x-10, ty=sophia.y+6;
    milo.x += (tx-milo.x)*0.08*(dt*60);
    milo.y += (ty-milo.y)*0.08*(dt*60);

    if(keysDown.has("e") && hideHold){
      hideHold += dt*60;
      if(hideHold>28){ hideHold=0; enterHidden(); }
    }
    if(!keysDown.has("e")) hideHold=0;
  }

  if(sophia.hop>0) sophia.hop = Math.max(0, sophia.hop - dt*2.8);

  collectPickups();
  checkCarHits();
}
function updateCamera(dt){
  const px = state.street.inCar ? (car.x+car.w/2) : (sophia.x+sophia.w/2);
  const py = state.street.inCar ? (car.y+car.h/2) : (sophia.y+sophia.h/2);

  const tx=clamp(px - VW/2, 0, WORLD.w - VW);
  const ty=clamp(py - VH/2, 0, WORLD.h - VH);

  cam.x += (tx - cam.x)*0.14*(dt*60);
  cam.y += (ty - cam.y)*0.14*(dt*60);

  if(cam.shake>0) cam.shake = Math.max(0, cam.shake - dt*30);
}

/* Controls */
let eWas=false, spWas=false, qWas=false, mWas=false, tWas=false, fWas=false;
let mapOpen=false, journalOpen=false;

function toggleJournal(){
  journalOpen=!journalOpen;
  UI.journal.classList.toggle("on", journalOpen);
  if(journalOpen) syncJournal();
}
function toggleMap(){
  mapOpen=!mapOpen;
  UI.mapPanel.classList.toggle("on", mapOpen);
  UI.lucasText.textContent = lucas.called ? (lucas.active ? `Following (bond ${lucas.bond})` : "Called (not here)") : "Not called";
}
function handleButtons(now){
  if(dialog.on){
    const q=keysDown.has("q");
    if(q && !qWas) toggleJournal();
    qWas=q;
    const m=keysDown.has("m");
    if(m && !mWas) toggleMap();
    mWas=m;
    const tt=keysDown.has("t");
    tWas=tt;
    eWas=keysDown.has("e");
    spWas=keysDown.has(" ");
    fWas=keysDown.has("f");
    return;
  }

  const e=keysDown.has("e");
  if(e && !eWas){
    const z=nearestZone();
    const px=sophia.x+5, py=sophia.y+6;

    let fought=false;
    for(const p of peds){
      if(!p.fight.active) continue;
      if(near(px,py,p.x+5,p.y+6,18)){
        resolveFightHit(p);
        fought=true;
        break;
      }
    }
    if(!fought){
      if(z && z.name.startsWith("DUMPSTER") && state.street.wanted>0) startHide();
      else if(z) z.action();
    }
  }
  eWas=e;

  const sp=keysDown.has(" ");
  if(sp && !spWas) throwMushroom(now);
  spWas=sp;

  const f=keysDown.has("f");
  if(f && !fWas) jumpHop(now);
  fWas=f;

  const q=keysDown.has("q");
  if(q && !qWas) toggleJournal();
  qWas=q;

  const m=keysDown.has("m");
  if(m && !mWas) toggleMap();
  mWas=m;

  const tt=keysDown.has("t");
  if(tt && !tWas) tripToggle();
  tWas=tt;
}

/* Waypoint */
function setWaypoint(x,y,label="WAYPOINT"){
  state.waypoint={x,y,label};
  UI.wpText.textContent = `${label} (${x|0},${y|0})`;
  toast("Waypoint set.", 1100);
  saveState();
}
function maybeAutoWaypoint(force=false){
  if(state.waypoint && !force) return;
  const q=activeQuest();
  if(!q) return;

  if(q.id==="DELIVER_FLYERS"){
    const b=buildings.find(b=>b.tag==="GROC");
    if(b) setWaypoint(b.x+b.w/2, b.y+b.h/2, "GROCERY AREA");
  }else if(q.id==="POSTER_SELFIE"){
    setWaypoint(S(250),S(1240),"PHOTO WALL");
  }else if(q.id==="Purse_Snatch"){
    setWaypoint(robber.x, robber.y, "ROBBER");
  }
}

/* Big Map click */
let mouse={x:0,y:0,down:false};
addEventListener("mousemove",(e)=>{
  const r=canvas.getBoundingClientRect();
  const scaleX = canvas.width / r.width;
  const scaleY = canvas.height / r.height;
  mouse.x = ((e.clientX - r.left)*scaleX)|0;
  mouse.y = ((e.clientY - r.top)*scaleY)|0;
});
addEventListener("mousedown",()=>mouse.down=true);
addEventListener("mouseup",()=>mouse.down=false);

function bigMapClick(){
  if(!mapOpen) return;
  if(!mouse.down) return;

  // smaller overlay area (not full canvas)
  const pad=18;
  const w=VW-pad*2, h=VH-pad*2;
  const sx=(w-12)/WORLD.w;
  const sy=(h-12)/WORLD.h;

  const mx=mouse.x, my=mouse.y;
  const inside = mx>pad+6 && mx<pad+6+(WORLD.w*sx) && my>pad+6 && my<pad+6+(WORLD.h*sy);
  if(!inside) return;

  const wx = (mx-(pad+6))/sx;
  const wy = (my-(pad+6))/sy;
  setWaypoint(wx,wy,"CUSTOM");
  mouse.down=false;
}

/* ==========================================================
   DRAW (same visuals; big map is slightly smaller panel)
   ========================================================== */
function worldToView(x,y){
  const sx = (cam.shake>0)? (Math.sin(performance.now()*0.04)*cam.shake*0.25) : 0;
  const sy = (cam.shake>0)? (Math.cos(performance.now()*0.05)*cam.shake*0.25) : 0;
  return {x:Math.round(x-cam.x+sx), y:Math.round(y-cam.y+sy)};
}
function drawRectBevel(x,y,w,h,fill){
  ctx.fillStyle=fill; ctx.fillRect(x,y,w,h);
  ctx.fillStyle="rgba(255,255,255,.10)"; ctx.fillRect(x,y,w,1);
  ctx.fillStyle="rgba(0,0,0,.40)"; ctx.fillRect(x,y+h-1,w,1);
  ctx.fillStyle="rgba(255,255,255,.07)"; ctx.fillRect(x,y,1,h);
  ctx.fillStyle="rgba(0,0,0,.45)"; ctx.fillRect(x+w-1,y,1,h);
}
function drawHintBubble(text,x,y){
  const pad=3;
  ctx.font="8px ui-monospace, monospace";
  const m=ctx.measureText(text);
  const w=Math.ceil(m.width)+pad*2, h=12;
  ctx.fillStyle="rgba(0,0,0,.70)";
  ctx.fillRect(x-w/2,y-h,w,h);
  ctx.strokeStyle="rgba(255,255,255,.16)";
  ctx.strokeRect(x-w/2+0.5,y-h+0.5,w-1,h-1);
  ctx.fillStyle="rgba(255,255,255,.92)";
  ctx.fillText(text,x-w/2+pad,y-4);
}
function tagLabel(b){
  if(b.tag==="HOME") return "HOME";
  if(b.tag==="GROC") return "GROCERY";
  if(b.tag==="BLCK") return "BLOCKBUSTER";
  if(b.tag==="CAT") return "CAT STORE";
  if(b.tag==="WEED") return "WEED SHOP";
  if(b.tag==="STAR") return "STARR";
  if(b.tag==="CAF") return "COFFEE";
  if(b.tag==="ARC") return "ARCADE";
  if(b.tag==="GAS") return "GAS";
  if(b.tag==="REST") return "FOLLOW HEART";
  if(b.tag==="YOGA") return "YOGA";
  if(b.tag==="SHOP") return "SOPHIE SHOP";
  return b.name;
}

function drawBackground(t){
  const g=ctx.createLinearGradient(0,0,0,VH);
  g.addColorStop(0,"rgba(90,180,255,1)");
  g.addColorStop(0.55,"rgba(150,215,255,1)");
  g.addColorStop(1,"rgba(220,245,255,1)");
  ctx.fillStyle=g;
  ctx.fillRect(0,0,VW,VH);

  const s=ctx.createRadialGradient(62,28,10,62,28,150);
  s.addColorStop(0,"rgba(255,255,255,.38)");
  s.addColorStop(0.35,"rgba(255,210,77,.26)");
  s.addColorStop(1,"rgba(255,255,255,0)");
  ctx.fillStyle=s; ctx.fillRect(0,0,VW,VH);

  ctx.fillStyle="rgba(40,60,90,.10)";
  for(let i=0;i<16;i++){
    const x=(i*22 + (t*0.3|0))%VW;
    const h=18 + (i%5)*6;
    ctx.fillRect(x, 34+h, 14, 50);
  }
}
function drawGround(t){
  ctx.fillStyle="rgba(60,190,110,1)";
  ctx.fillRect(0,0,VW,VH);
  for(let i=0;i<80;i++){
    const x=(i*41 + (t*2|0))%VW;
    const y=(i*17 + (t|0))%VH;
    ctx.fillStyle="rgba(255,255,255,.05)";
    ctx.fillRect(x,y,1,1);
  }
}
function drawRoads(t){
  for(const r of roads){
    if(r.x+r.w<cam.x-40||r.x>cam.x+VW+40||r.y+r.h<cam.y-40||r.y>cam.y+VH+40) continue;
    const v=worldToView(r.x,r.y);

    drawRectBevel(v.x,v.y,r.w,r.h,"rgba(90,95,105,1)");
    ctx.fillStyle="rgba(40,45,55,.48)";
    ctx.fillRect(v.x+2,v.y+2,r.w-4,r.h-4);

    ctx.fillStyle="rgba(255,255,255,.24)";
    if(r.w>r.h){
      const yy=v.y + (r.h/2|0);
      for(let x=v.x+10;x<v.x+r.w-10;x+=18){
        ctx.fillRect(x,yy,10,1);
      }
    }else{
      const xx=v.x + (r.w/2|0);
      for(let y=v.y+10;y<v.y+r.h-10;y+=18){
        ctx.fillRect(xx,y,1,10);
      }
    }

    ctx.fillStyle="rgba(220,220,220,.45)";
    ctx.fillRect(v.x, v.y, r.w, 3);
    ctx.fillRect(v.x, v.y+r.h-3, r.w, 3);
    ctx.fillRect(v.x, v.y, 3, r.h);
    ctx.fillRect(v.x+r.w-3, v.y, 3, r.h);
  }
}
function drawPark(){
  if(park.x+park.w<cam.x-10||park.x>cam.x+VW+10||park.y+park.h<cam.y-10||park.y>cam.y+VH+10) return;
  const v=worldToView(park.x,park.y);
  drawRectBevel(v.x,v.y,park.w,park.h,"rgba(40,160,90,1)");
  ctx.fillStyle="rgba(255,255,255,.08)";
  ctx.fillRect(v.x+20,v.y+30,park.w-40,2);
  ctx.fillRect(v.x+20,v.y+park.h-40,park.w-40,2);
  ctx.fillStyle="rgba(0,255,213,.18)";
  ctx.fillRect(v.x+park.w/2-10, v.y+park.h/2-8, 20, 16);
  ctx.fillStyle="rgba(255,255,255,.25)";
  ctx.fillRect(v.x+park.w/2-3, v.y+park.h/2-2, 6, 4);
}
function drawPond(t){
  if(pond.x+pond.w<cam.x-10||pond.x>cam.x+VW+10||pond.y+pond.h<cam.y-10||pond.y>cam.y+VH+10) return;
  const v=worldToView(pond.x,pond.y);
  drawRectBevel(v.x,v.y,pond.w,pond.h,"rgba(90,180,255,.35)");
  ctx.fillStyle="rgba(0,0,0,.25)";
  ctx.fillRect(v.x+3,v.y+3,pond.w-6,pond.h-6);
  ctx.fillStyle="rgba(0,255,213,.10)";
  for(let i=0;i<10;i++){
    const rx = v.x+10 + ((i*21 + (t*2|0)) % (pond.w-20));
    const ry = v.y+14 + ((i*11 + (t|0)) % (pond.h-28));
    ctx.fillRect(rx,ry,6,1);
  }
}
function drawTrees(){
  for(const tr of trees){
    if(tr.x<cam.x-40||tr.x>cam.x+VW+40||tr.y<cam.y-40||tr.y>cam.y+VH+40) continue;
    const v=worldToView(tr.x,tr.y);
    const s=tr.s;

    ctx.fillStyle="rgba(0,0,0,.18)";
    ctx.fillRect(v.x-3*s, v.y+6*s, 10*s, 2*s);

    ctx.fillStyle="rgba(80,50,30,.9)";
    ctx.fillRect(v.x, v.y, 2, 6*s);

    const glow = (tr.tint==="aqua") ? "rgba(0,255,213,.16)" : "rgba(255,210,77,.14)";
    ctx.fillStyle=glow;
    ctx.fillRect(v.x-6*s, v.y-7*s, 14*s, 12*s);

    ctx.fillStyle="rgba(30,120,60,.92)";
    ctx.fillRect(v.x-5*s, v.y-6*s, 12*s, 10*s);

    ctx.fillStyle="rgba(255,255,255,.08)";
    ctx.fillRect(v.x-2*s, v.y-4*s, 5*s, 2*s);
  }
}
function drawBuildings(){
  for(const b of buildings){
    if(b.x+b.w<cam.x-20||b.x>cam.x+VW+20||b.y+b.h<cam.y-20||b.y>cam.y+VH+20) continue;
    const v=worldToView(b.x,b.y);

    drawRectBevel(v.x,v.y,b.w,b.h,"rgba(255,255,255,.20)");
    ctx.fillStyle="rgba(0,0,0,.35)";
    ctx.fillRect(v.x+3,v.y+3,b.w-6,b.h-6);

    ctx.fillStyle="rgba(0,0,0,.18)";
    ctx.fillRect(v.x+2, v.y-6, b.w-4, 6);
    ctx.fillStyle="rgba(255,255,255,.10)";
    ctx.fillRect(v.x+3, v.y-5, b.w-6, 2);

    let glow="rgba(138,46,255,.22)";
    if(b.tag==="GROC") glow="rgba(255,210,77,.22)";
    if(b.tag==="CAT") glow="rgba(255,99,255,.18)";
    if(b.tag==="WEED") glow="rgba(0,255,213,.20)";
    if(b.tag==="STAR") glow="rgba(255,210,77,.26)";
    if(b.tag==="CAF") glow="rgba(0,255,213,.14)";
    if(b.tag==="ARC") glow="rgba(255,99,255,.14)";
    if(b.tag==="GAS") glow="rgba(255,210,77,.18)";
    if(b.tag==="REST") glow="rgba(255,99,255,.12)";
    if(b.tag==="YOGA") glow="rgba(0,255,213,.12)";
    if(b.tag==="SHOP") glow="rgba(138,46,255,.14)";
    if(b.tag==="BEACH") glow="rgba(90,180,255,.12)";

    ctx.fillStyle=glow;
    ctx.fillRect(v.x+6,v.y+6,b.w-12,16);

    ctx.font="8px ui-monospace, monospace";
    ctx.fillStyle="rgba(255,255,255,.95)";
    const label = (b.name==="STARR") ? "STARR" : b.name;
    ctx.fillText(label, v.x+8, v.y+16);

    const winCount=Math.max(2,(b.w/60|0));
    for(let i=0;i<winCount;i++){
      const wx=v.x+8+i*38;
      const wy=v.y+28;
      ctx.fillStyle="rgba(90,180,255,.18)";
      ctx.fillRect(wx,wy,22,10);
      ctx.fillStyle="rgba(255,255,255,.10)";
      ctx.fillRect(wx+1,wy+1,20,8);
    }

    const dr=buildingDoorRect(b);
    const dv=worldToView(dr[0],dr[1]);
    ctx.fillStyle="rgba(255,255,255,.20)";
    ctx.fillRect(dv.x,dv.y,dr[2],dr[3]);
    ctx.fillStyle="rgba(0,0,0,.55)";
    ctx.fillRect(dv.x+2,dv.y+2,dr[2]-4,dr[3]-4);

    if(b.tag==="STAR"){
      ctx.fillStyle="rgba(255,210,77,.80)";
      ctx.fillRect(dv.x+4,dv.y+3,4,4);
      ctx.fillRect(dv.x+9,dv.y+4,6,2);
    }
  }
}
function drawDumpsters(){
  for(const d of dumpsters){
    if(d.x+d.w<cam.x-20||d.x>cam.x+VW+20||d.y+d.h<cam.y-20||d.y>cam.y+VH+20) continue;
    const v=worldToView(d.x,d.y);
    drawRectBevel(v.x,v.y,d.w,d.h,"rgba(120,140,150,1)");
    ctx.fillStyle="rgba(0,0,0,.45)";
    ctx.fillRect(v.x+3,v.y+3,d.w-6,d.h-6);
    ctx.fillStyle="rgba(0,255,213,.14)";
    ctx.fillRect(v.x+4,v.y+4,10,5);
  }
}
function drawProps(t){
  for(const b of benches){
    if(b.x<cam.x-30||b.x>cam.x+VW+30||b.y<cam.y-30||b.y>cam.y+VH+30) continue;
    const v=worldToView(b.x,b.y);
    drawRectBevel(v.x,v.y,b.w,b.h,"rgba(255,255,255,.14)");
    ctx.fillStyle="rgba(0,0,0,.35)";
    ctx.fillRect(v.x+2,v.y+2,b.w-4,b.h-4);
    ctx.fillStyle="rgba(255,210,77,.18)";
    ctx.fillRect(v.x+2,v.y+1,b.w-4,1);
  }
  for(const mb of mailboxes){
    if(mb.x<cam.x-30||mb.x>cam.x+VW+30||mb.y<cam.y-30||mb.y>cam.y+VH+30) continue;
    const v=worldToView(mb.x,mb.y);
    drawRectBevel(v.x,v.y,mb.w,mb.h,"rgba(255,255,255,.18)");
    ctx.fillStyle="rgba(0,0,0,.45)";
    ctx.fillRect(v.x+1,v.y+1,mb.w-2,mb.h-2);
    ctx.fillStyle="rgba(0,255,213,.18)";
    ctx.fillRect(v.x+2,v.y+2,mb.w-4,2);
  }
  for(const vd of vending){
    if(vd.x<cam.x-40||vd.x>cam.x+VW+40||vd.y<cam.y-40||vd.y>cam.y+VH+40) continue;
    const v=worldToView(vd.x,vd.y);
    drawRectBevel(v.x,v.y,vd.w,vd.h,"rgba(255,255,255,.18)");
    ctx.fillStyle="rgba(0,0,0,.55)";
    ctx.fillRect(v.x+2,v.y+2,vd.w-4,vd.h-4);
    ctx.fillStyle="rgba(255,99,255,.18)";
    ctx.fillRect(v.x+3,v.y+3,vd.w-6,3);
    ctx.fillStyle="rgba(255,255,255,.10)";
    ctx.fillRect(v.x+3,v.y+8,vd.w-6,2);
  }
  for(const ps of photoSpots){
    if(ps.x<cam.x-40||ps.x>cam.x+VW+40||ps.y<cam.y-40||ps.y>cam.y+VH+40) continue;
    const v=worldToView(ps.x,ps.y);
    ctx.fillStyle="rgba(255,255,255,.14)";
    ctx.fillRect(v.x,v.y,ps.w,ps.h);
    ctx.fillStyle="rgba(0,0,0,.55)";
    ctx.fillRect(v.x+2,v.y+2,ps.w-4,ps.h-4);
    ctx.fillStyle="rgba(255,210,77,.35)";
    ctx.fillRect(v.x+6,v.y+6,6,6);
  }
  if(payphone.x<cam.x-40||payphone.x>cam.x+VW+40||payphone.y<cam.y-40||payphone.y>cam.y+VH+40) return;
  const pv=worldToView(payphone.x,payphone.y);
  drawRectBevel(pv.x,pv.y,payphone.w,payphone.h,"rgba(255,255,255,.20)");
  ctx.fillStyle="rgba(0,0,0,.55)";
  ctx.fillRect(pv.x+2,pv.y+2,payphone.w-4,payphone.h-4);
  ctx.fillStyle="rgba(0,255,213,.18)";
  ctx.fillRect(pv.x+4,pv.y+4,payphone.w-8,3);
  ctx.font="7px ui-monospace, monospace";
  ctx.fillStyle="rgba(255,255,255,.85)";
  ctx.fillText("☎", pv.x+6, pv.y+14);
}
function drawCoins(t){
  for(const c of coins){
    if(!c.alive) continue;
    if(c.x<cam.x-20||c.x>cam.x+VW+20||c.y<cam.y-20||c.y>cam.y+VH+20) continue;
    const v=worldToView(c.x,c.y);
    const bob = Math.round(Math.sin((t + c.x)*0.06)*1);
    ctx.fillStyle="rgba(255,210,77,.70)";
    ctx.fillRect(v.x, v.y+bob, 3, 3);
    ctx.fillStyle="rgba(255,255,255,.22)";
    ctx.fillRect(v.x+1, v.y+bob+1, 1, 1);
  }
}
function drawMushrooms(t){
  for(const m of mushWorld){
    if(!m.alive) continue;
    if(m.x<cam.x-24||m.x>cam.x+VW+24||m.y<cam.y-24||m.y>cam.y+VH+24) continue;
    const v=worldToView(m.x,m.y);
    ctx.fillStyle="rgba(0,0,0,.18)";
    ctx.fillRect(v.x-1, v.y+6, 8, 2);
    ctx.fillStyle="rgba(255,255,255,.32)";
    ctx.fillRect(v.x+3, v.y+3, 2, 4);

    let cap="rgba(138,46,255,.72)";
    let glow="rgba(138,46,255,.18)";
    if(m.kind==="gold"){ cap="rgba(255,210,77,.86)"; glow="rgba(255,210,77,.22)"; }
    if(m.kind==="aqua"){ cap="rgba(0,255,213,.72)"; glow="rgba(0,255,213,.20)"; }

    ctx.fillStyle=glow;
    ctx.fillRect(v.x+0, v.y+0, 8, 6);
    ctx.fillStyle=cap;
    ctx.fillRect(v.x+1, v.y+1, 6, 3);

    ctx.fillStyle="rgba(255,255,255,.22)";
    ctx.fillRect(v.x+2, v.y+2, 1, 1);
    ctx.fillRect(v.x+5, v.y+2, 1, 1);
  }
}
function drawDuck(t){
  if(duck.x<cam.x-40||duck.x>cam.x+VW+40||duck.y<cam.y-40||duck.y>cam.y+VH+40) return;
  const v=worldToView(duck.x,duck.y);
  ctx.fillStyle="rgba(0,0,0,.20)";
  ctx.fillRect(v.x-1,v.y+6,10,2);
  ctx.fillStyle="rgba(255,210,77,.85)";
  ctx.fillRect(v.x+1,v.y+2,6,4);
  ctx.fillStyle="rgba(255,99,255,.35)";
  ctx.fillRect(v.x+6,v.y+3,2,2);
  ctx.fillStyle="rgba(255,255,255,.18)";
  ctx.fillRect(v.x+2,v.y+3,1,1);
}

/* sprites */
function drawSophia(){
  if(state.street.inCar || state.street.hidden) return;
  const v=worldToView(sophia.x,sophia.y);
  let x=v.x,y=v.y;
  const lift = Math.round(Math.sin((1-sophia.hop)*Math.PI) * 3 * sophia.hop);
  y -= lift;

  ctx.fillStyle="rgba(0,0,0,.22)"; ctx.fillRect(x-1,y+11,12,2);
  ctx.fillStyle="#f2d27a"; ctx.fillRect(x+1,y+0,8,4); ctx.fillRect(x+0,y+3,10,3);
  ctx.fillStyle="#ffd9c9"; ctx.fillRect(x+2,y+5,6,4);
  ctx.fillStyle="#67b7ff"; ctx.fillRect(x+3,y+6,1,1); ctx.fillRect(x+6,y+6,1,1);
  ctx.fillStyle="rgba(138,46,255,.70)"; ctx.fillRect(x+2,y+9,6,3);
  ctx.fillStyle="rgba(255,255,255,.18)"; ctx.fillRect(x+3,y+10,4,1);

  if(performance.now()<buffs.coffeeUntil){
    ctx.fillStyle="rgba(0,255,213,.12)";
    ctx.fillRect(x-3,y-3,16,18);
  }
}
function drawMilo(){
  if(state.street.inCar || state.street.hidden) return;
  const v=worldToView(milo.x,milo.y);
  const x=v.x,y=v.y;
  ctx.fillStyle="rgba(0,0,0,.20)"; ctx.fillRect(x-1,y+7,10,2);
  ctx.fillStyle="#d8d8d8"; ctx.fillRect(x+1,y+2,6,5);
  ctx.fillStyle="#cfcfcf"; ctx.fillRect(x+1,y+1,2,2); ctx.fillRect(x+5,y+1,2,2);
  ctx.fillStyle="#1affd3"; ctx.fillRect(x+2,y+4,1,1); ctx.fillRect(x+5,y+4,1,1);
  ctx.fillStyle="#cfcfcf"; ctx.fillRect(x+7,y+3,1,3);
}
function drawLucas(t){
  if(!lucas.called || !lucas.active) return;
  if(state.street.inCar || state.street.hidden) return;
  const v=worldToView(lucas.x,lucas.y);
  const x=v.x,y=v.y;
  ctx.fillStyle="rgba(0,0,0,.22)"; ctx.fillRect(x-1,y+11,12,2);
  ctx.fillStyle="#c79a63"; ctx.fillRect(x+1,y+0,8,4); ctx.fillRect(x+0,y+3,10,3);
  ctx.fillStyle="#ffd9c9"; ctx.fillRect(x+2,y+5,6,4);
  ctx.fillStyle="#67b7ff"; ctx.fillRect(x+3,y+6,1,1); ctx.fillRect(x+6,y+6,1,1);
  ctx.fillStyle="rgba(0,255,213,.55)"; ctx.fillRect(x+2,y+9,6,3);
  ctx.fillStyle="rgba(255,255,255,.18)"; ctx.fillRect(x+3,y+10,4,1);
  ctx.fillStyle="rgba(255,99,255,.10)";
  ctx.fillRect(x-2,y-2,14,16);
}
function drawCar(){
  if(car.x<cam.x-40||car.x>cam.x+VW+40||car.y<cam.y-40||car.y>cam.y+VH+40) return;
  const v=worldToView(car.x,car.y);
  ctx.fillStyle="rgba(0,0,0,.18)";
  ctx.fillRect(v.x, v.y+car.h, car.w, 2);

  drawRectBevel(v.x,v.y,car.w,car.h,"rgba(255,255,255,.24)");
  ctx.fillStyle="rgba(0,0,0,.45)";
  ctx.fillRect(v.x+2,v.y+2,car.w-4,car.h-4);

  ctx.fillStyle="rgba(90,180,255,.20)";
  ctx.fillRect(v.x+3,v.y+3,car.w-6,2);

  ctx.fillStyle="rgba(255,210,77,.16)";
  ctx.fillRect(v.x+3,v.y+6,car.w-6,2);

  const fu = clamp(car.fuel,0,100);
  ctx.fillStyle="rgba(0,255,213,.12)";
  ctx.fillRect(v.x+2, v.y-3, Math.round((car.w-4)*(fu/100)), 1);

  if(state.street.inCar){
    ctx.fillStyle="rgba(255,255,255,.20)";
    ctx.fillRect(v.x+4,v.y+4,2,2);
    ctx.fillStyle="rgba(0,255,213,.20)";
    ctx.fillRect(v.x+car.w-6,v.y+4,2,2);
  }
}
function drawTraffic(){
  for(const vcar of traffic){
    if(vcar.x<cam.x-40||vcar.x>cam.x+VW+40||vcar.y<cam.y-40||vcar.y>cam.y+VH+40) continue;
    const v=worldToView(vcar.x,vcar.y);

    ctx.fillStyle="rgba(0,0,0,.18)";
    ctx.fillRect(v.x, v.y+vcar.h, vcar.w, 2);

    drawRectBevel(v.x,v.y,vcar.w,vcar.h,"rgba(255,255,255,.20)");
    ctx.fillStyle="rgba(0,0,0,.45)";
    ctx.fillRect(v.x+2,v.y+2,vcar.w-4,vcar.h-4);

    let stripe="rgba(138,46,255,.18)";
    if(vcar.color==="aqua") stripe="rgba(0,255,213,.18)";
    if(vcar.color==="sun") stripe="rgba(255,210,77,.18)";
    ctx.fillStyle=stripe;
    ctx.fillRect(v.x+3,v.y+6,vcar.w-6,2);

    if(vcar.beep>0){
      ctx.fillStyle="rgba(255,99,255,.40)";
      ctx.fillRect(v.x-1,v.y-2,vcar.w+2,2);
    }
  }
}
function drawPeds(t){
  for(const p of peds){
    if(p.x<cam.x-30||p.x>cam.x+VW+30||p.y<cam.y-30||p.y>cam.y+VH+30) continue;
    const v=worldToView(p.x,p.y);
    const x=v.x,y=v.y;

    ctx.fillStyle="rgba(0,0,0,.18)";
    ctx.fillRect(x-1,y+11,12,2);

    let hair="#f2d27a";
    if(p.hair==="brown") hair="#c79a63";
    if(p.hair==="black") hair="#6b5a55";
    if(p.hair==="white") hair="rgba(255,255,255,.75)";
    ctx.fillStyle=hair;
    ctx.fillRect(x+1,y+0,8,4);
    ctx.fillRect(x+0,y+3,10,3);

    ctx.fillStyle="#ffd9c9";
    ctx.fillRect(x+2,y+5,6,4);

    ctx.fillStyle="#67b7ff";
    ctx.fillRect(x+3,y+6,1,1);
    ctx.fillRect(x+6,y+6,1,1);

    let shirt="rgba(138,46,255,.65)";
    if(p.shirt==="aqua") shirt="rgba(0,255,213,.55)";
    if(p.shirt==="sun") shirt="rgba(255,210,77,.55)";
    ctx.fillStyle=shirt;
    ctx.fillRect(x+2,y+9,6,3);

    if(p.type==="robber"){
      ctx.fillStyle="rgba(255,99,255,.55)";
      ctx.fillRect(x-2,y+2,2,2);
    }else if(p.type==="oldlady"){
      ctx.fillStyle="rgba(255,210,77,.55)";
      ctx.fillRect(x-2,y+2,2,2);
    }else if(p.type==="performer"){
      ctx.fillStyle="rgba(0,255,213,.45)";
      ctx.fillRect(x-2,y+2,2,2);
    }

    if(p.wave>0 && p.stunned<=0){
      const arm = Math.round(Math.sin((t+p.wave)*0.25)*1);
      ctx.fillStyle="rgba(255,255,255,.18)";
      ctx.fillRect(x+8, y+7+arm, 2, 1);
      ctx.fillStyle="rgba(255,210,77,.22)";
      ctx.fillRect(x+10, y+6+arm, 1, 2);
    }

    if(p.angry>0){
      p.angry--;
      ctx.fillStyle="rgba(255,99,255,.12)";
      ctx.fillRect(x-3,y-3,16,18);
    }

    if(p.stunned>0){
      ctx.fillStyle="rgba(255,99,255,.16)";
      ctx.fillRect(x-2,y-2,14,16);
      ctx.fillStyle="rgba(255,255,255,.35)";
      ctx.fillRect(x+2,y-4,2,1);
      ctx.fillRect(x+6,y-5,2,1);
    }

    if(p.hasDog && p.dog){
      const dv=worldToView(p.dog.x,p.dog.y);
      ctx.fillStyle="rgba(0,0,0,.18)";
      ctx.fillRect(dv.x-1,dv.y+7,10,2);
      ctx.fillStyle="rgba(255,170,60,.85)";
      ctx.fillRect(dv.x+1,dv.y+2,6,5);
      ctx.fillStyle="rgba(255,255,255,.18)";
      ctx.fillRect(dv.x+2,dv.y+3,1,1);
      ctx.fillRect(dv.x+5,dv.y+3,1,1);
      ctx.fillStyle="rgba(60,40,30,.7)";
      ctx.fillRect(dv.x+7,dv.y+4,1,2);
    }
  }
}
function drawShots(){
  for(const s of shots){
    if(s.x<cam.x-20||s.x>cam.x+VW+20||s.y<cam.y-20||s.y>cam.y+VH+20) continue;
    const v=worldToView(s.x,s.y);
    ctx.fillStyle="rgba(255,255,255,.85)";
    ctx.fillRect(v.x,v.y,2,2);
    ctx.fillStyle="rgba(138,46,255,.25)";
    ctx.fillRect(v.x-1,v.y-1,4,4);
  }
}
function drawCops(t){
  for(const c of cops){
    if(c.x<cam.x-30||c.x>cam.x+VW+30||c.y<cam.y-30||c.y>cam.y+VH+30) continue;
    const v=worldToView(c.x,c.y);
    const x=v.x,y=v.y;

    ctx.fillStyle="rgba(0,0,0,.20)";
    ctx.fillRect(x-1,y+11,12,2);

    ctx.fillStyle="rgba(255,255,255,.16)";
    ctx.fillRect(x+0,y+0,10,12);
    ctx.fillStyle="rgba(0,255,213,.22)";
    ctx.fillRect(x+2,y+9,6,3);

    const blink=((t+c.blink)%26)<10;
    ctx.fillStyle=blink ? "rgba(255,99,255,.70)" : "rgba(255,210,77,.60)";
    ctx.fillRect(x+2,y-2,6,2);

    if(c.stunned>0){
      ctx.fillStyle="rgba(138,46,255,.18)";
      ctx.fillRect(x-2,y-2,14,16);
    }
  }
}
function drawWantedOverlay(t){
  const w=state.street.wanted|0;
  if(w<=0) return;
  const a=0.05 + 0.02*w;
  const blink=(t%30)<15;
  ctx.fillStyle=blink ? `rgba(255,99,255,${a})` : `rgba(0,255,213,${a})`;
  ctx.fillRect(0,0,VW,VH);
  ctx.fillStyle="rgba(0,0,0,.12)";
  ctx.fillRect(0,0,VW,2);
  ctx.fillRect(0,VH-2,VW,2);
  ctx.fillRect(0,0,2,VH);
  ctx.fillRect(VW-2,0,2,VH);
}
function drawHiddenOverlay(t){
  if(!state.street.hidden) return;
  ctx.fillStyle="rgba(0,0,0,.45)";
  ctx.fillRect(0,0,VW,VH);
  ctx.fillStyle=`rgba(0,255,213,${0.06 + 0.04*Math.sin(t*0.12)})`;
  ctx.fillRect(0,0,VW,VH);
  ctx.font="9px ui-monospace, monospace";
  ctx.fillStyle="rgba(255,255,255,.85)";
  ctx.fillText("HIDING… hold E to stay, release to exit", 18, 92);
}
function drawTripOverlay(t){
  if(performance.now() > (state.street.tripUntil||0)) return;
  const k = 0.10 + 0.06*Math.sin(t*0.12);
  ctx.fillStyle=`rgba(138,46,255,${k})`;
  ctx.fillRect(0,0,VW,VH);
  ctx.fillStyle=`rgba(0,255,213,${k*0.6})`;
  ctx.fillRect(0,0,VW,VH);
  ctx.fillStyle="rgba(0,0,0,.08)";
  for(let y=0;y<VH;y+=3) ctx.fillRect(0,y,VW,1);
}

/* Minimap + Big Map */
function drawMinimap(t){
  const mw=92, mh=68;
  const x=VW-mw-6, y=6;

  drawRectBevel(x,y,mw,mh,"rgba(255,255,255,.16)");
  ctx.fillStyle="rgba(0,0,0,.45)";
  ctx.fillRect(x+2,y+2,mw-4,mh-4);

  const sx=(mw-8)/WORLD.w;
  const sy=(mh-8)/WORLD.h;

  ctx.fillStyle="rgba(255,255,255,.08)";
  for(const r of roads){
    ctx.fillRect(x+4 + r.x*sx, y+4 + r.y*sy, r.w*sx, r.h*sy);
  }
  for(const b of buildings){
    const bx=x+4 + b.x*sx;
    const by=y+4 + b.y*sy;
    ctx.fillStyle = (b.tag==="STAR") ? "rgba(255,210,77,.80)" : "rgba(255,255,255,.20)";
    ctx.fillRect(bx,by, Math.max(2,b.w*sx), Math.max(2,b.h*sy));
  }
  ctx.fillStyle="rgba(90,180,255,.28)";
  ctx.fillRect(x+4 + pond.x*sx, y+4 + pond.y*sy, pond.w*sx, pond.h*sy);

  if(state.waypoint){
    ctx.fillStyle="rgba(255,99,255,.85)";
    ctx.fillRect(x+4 + state.waypoint.x*sx, y+4 + state.waypoint.y*sy, 2, 2);
  }

  ctx.fillStyle="rgba(255,99,255,.70)";
  for(const c of cops){
    ctx.fillRect(x+4 + c.x*sx, y+4 + c.y*sy, 1, 1);
  }

  const pxW = state.street.inCar ? car.x : sophia.x;
  const pyW = state.street.inCar ? car.y : sophia.y;
  ctx.fillStyle="rgba(0,255,213,1)";
  ctx.fillRect(x+4 + pxW*sx, y+4 + pyW*sy, 2, 2);

  if(!state.street.inCar){
    ctx.fillStyle="rgba(255,210,77,.95)";
    ctx.fillRect(x+4 + car.x*sx, y+4 + car.y*sy, 2, 2);
  }

  if(lucas.called && lucas.active){
    ctx.fillStyle="rgba(255,99,255,.75)";
    ctx.fillRect(x+4 + lucas.x*sx, y+4 + lucas.y*sy, 2, 2);
  }
}

function drawBigMap(t){
  if(!mapOpen) return;

  ctx.fillStyle="rgba(0,0,0,.58)";
  ctx.fillRect(0,0,VW,VH);

  // Smaller panel (not full screen)
  const pad=18;
  const w=VW-pad*2, h=VH-pad*2;

  drawRectBevel(pad,pad,w,h,"rgba(255,255,255,.14)");
  ctx.fillStyle="rgba(0,0,0,.55)";
  ctx.fillRect(pad+2,pad+2,w-4,h-4);

  const sx=(w-12)/WORLD.w;
  const sy=(h-12)/WORLD.h;

  ctx.fillStyle="rgba(255,255,255,.10)";
  for(const r of roads){
    ctx.fillRect(pad+6 + r.x*sx, pad+6 + r.y*sy, r.w*sx, r.h*sy);
  }

  for(const b of buildings){
    const bx=pad+6 + b.x*sx;
    const by=pad+6 + b.y*sy;
    ctx.fillStyle = (b.tag==="STAR") ? "rgba(255,210,77,.90)" : "rgba(255,255,255,.22)";
    ctx.fillRect(bx,by, Math.max(2,b.w*sx), Math.max(2,b.h*sy));
  }

  ctx.fillStyle="rgba(90,180,255,.25)";
  ctx.fillRect(pad+6 + pond.x*sx, pad+6 + pond.y*sy, pond.w*sx, pond.h*sy);

  ctx.font="8px ui-monospace, monospace";
  ctx.fillStyle="rgba(255,255,255,.88)";
  for(const b of buildings){
    const lx = pad+6 + (b.x + b.w/2)*sx;
    const ly = pad+6 + (b.y + b.h/2)*sy;
    const txt = tagLabel(b);
    ctx.fillText(txt, lx - Math.min(22, txt.length*2), ly-2);
  }
  ctx.fillStyle="rgba(255,255,255,.82)";
  ctx.fillText("DUCK POND", pad+6 + (pond.x+pond.w/2)*sx - 18, pad+6 + (pond.y+pond.h/2)*sy);

  ctx.fillStyle="rgba(255,210,77,.92)";
  ctx.fillText("CAR", pad+6 + (car.x+car.w/2)*sx - 6, pad+6 + (car.y+car.h/2)*sy - 2);

  if(state.waypoint){
    ctx.fillStyle="rgba(255,99,255,.90)";
    ctx.fillRect(pad+6 + state.waypoint.x*sx, pad+6 + state.waypoint.y*sy, 3, 3);
  }

  const pxW = state.street.inCar ? car.x : sophia.x;
  const pyW = state.street.inCar ? car.y : sophia.y;
  ctx.fillStyle="rgba(0,255,213,1)";
  ctx.fillRect(pad+6 + pxW*sx, pad+6 + pyW*sy, 4, 4);

  if(lucas.called && lucas.active){
    ctx.fillStyle="rgba(255,99,255,.85)";
    ctx.fillRect(pad+6 + lucas.x*sx, pad+6 + lucas.y*sy, 4, 4);
  }

  ctx.font="9px ui-monospace, monospace";
  ctx.fillStyle="rgba(255,255,255,.90)";
  ctx.fillText("MAP (press M) • click to set waypoint", pad+12, pad+18);
}

/* MAIN LOOP */
let t=0;
let last=performance.now();
let autosaveAcc=0;

syncJournal();
maybeAutoWaypoint();

function loop(){
  const now=performance.now();
  const dt = clamp((now-last)/1000, 0, 0.05);
  last=now;
  t++;

  handleButtons(now);
  bigMapClick();

  updateTraffic(t,dt);
  updatePeds(t,dt);
  updateShots(dt);
  updateCops(t,dt);
  updatePlayer(t,dt);
  updateLucas(t,dt);
  updateCamera(dt);

  coolWanted(dt);

  autosaveAcc += dt;
  if(autosaveAcc>1.0){
    autosaveAcc=0;
    state.sophia.x=sophia.x; state.sophia.y=sophia.y;
    state.milo.x=milo.x; state.milo.y=milo.y;
    state.street.car={x:car.x,y:car.y,vx:car.vx,vy:car.vy};

    state.lucas.called=lucas.called;
    state.lucas.active=lucas.active;
    state.lucas.x=lucas.x; state.lucas.y=lucas.y;
    state.lucas.bond=lucas.bond;
    state.lucas.mood=lucas.mood;

    saveState();
  }

  drawBackground(t);
  drawGround(t);
  drawPark();
  drawPond(t);
  drawRoads(t);
  drawTrees();
  drawBuildings();
  drawDumpsters();
  drawProps(t);
  drawCoins(t);
  drawMushrooms(t);
  drawDuck(t);

  drawTraffic();
  drawCar();
  drawShots();
  drawPeds(t);
  drawCops(t);
  drawLucas(t);
  drawMilo();
  drawSophia();

  const z=nearestZone();
  if(z && !state.street.hidden && !mapOpen && !dialog.on){
    const px = state.street.inCar ? car.x+car.w/2 : sophia.x+6;
    const py = state.street.inCar ? car.y-6 : sophia.y-10;
    const v=worldToView(px,py);
    drawHintBubble(z.name, v.x, v.y);
  }

  drawWantedOverlay(t);
  drawHiddenOverlay(t);
  drawTripOverlay(t);
  drawMinimap(t);
  drawBigMap(t);

  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
