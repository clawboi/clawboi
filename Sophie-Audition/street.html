<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Sophia's Audition — Street (Open City)</title>
<style>
  :root{
    --bg:#07070b; --fg:#fff; --ui2:rgba(255,255,255,.14);
    --vio:#8a2eff; --aqua:#00ffd5; --hot:#ff63ff; --sun:#ffd24d;
  }
  html,body{height:100%; margin:0; background:var(--bg); color:var(--fg); font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}
  .wrap{height:100%; display:grid; place-items:center;}
  canvas{width:min(980px, 100vw); height:auto; image-rendering:pixelated; image-rendering:crisp-edges; touch-action:none;}
  .hud{
    position:fixed; left:12px; right:12px; top:12px; z-index:5;
    display:flex; gap:10px; flex-wrap:wrap; pointer-events:none;
  }
  .pill{
    pointer-events:auto; border:1px solid var(--ui2); background:rgba(0,0,0,.35);
    backdrop-filter: blur(8px);
    border-radius:999px; padding:10px 12px;
    font-size:11px; letter-spacing:.18em; text-transform:uppercase;
    display:flex; gap:10px; align-items:center;
  }
  .hint{
    pointer-events:auto;
    flex:1 1 320px;
    border:1px solid var(--ui2); background:rgba(0,0,0,.35);
    backdrop-filter: blur(8px);
    border-radius:18px; padding:10px 12px;
    font-size:11px; letter-spacing:.10em; line-height:1.35;
  }
  .hint .k{display:inline-block; padding:2px 7px; border-radius:8px; border:1px solid var(--ui2); background:rgba(255,255,255,.06); font-weight:700}
  .toast{
    position:fixed; left:50%; bottom:16px; transform:translateX(-50%);
    border:1px solid var(--ui2); background:rgba(0,0,0,.55);
    border-radius:14px; padding:10px 12px;
    font-size:12px; letter-spacing:.08em; opacity:0; transition:.2s;
    max-width:min(820px, calc(100vw - 24px)); text-align:center;
    z-index:6;
  }
  .toast.on{opacity:1}

  /* soft neon atmosphere (same family as the house pages, brighter) */
  body::before{
    content:"";
    position:fixed;
    inset:-20%;
    background:
      radial-gradient(circle at 18% 12%, rgba(255,210,77,.16), transparent 58%),
      radial-gradient(circle at 78% 22%, rgba(0,255,213,.14), transparent 62%),
      radial-gradient(circle at 48% 92%, rgba(138,46,255,.18), transparent 62%),
      radial-gradient(circle at 88% 78%, rgba(255,99,255,.10), transparent 65%);
    filter:blur(44px) saturate(1.15);
    animation: drift 14s ease-in-out infinite;
    pointer-events:none;
  }
  @keyframes drift{
    0%,100%{transform:translate3d(0,0,0)}
    50%{transform:translate3d(1.2%, -1.2%,0)}
  }
</style>
</head>
<body>
  <div class="hud">
    <div class="pill"><b>SOPHIA</b> <span id="status">STREET</span></div>
    <div class="pill">MODE: <span id="mode">ON FOOT</span></div>
    <div class="pill">MUSHROOMS: <span id="mush">0</span></div>
    <div class="pill">WANTED: <span id="wanted">0</span></div>
    <div class="pill">KEYS: <span id="keys">NO</span></div>
    <div class="hint">
      Move: <span class="k">WASD</span> · Run/Boost: <span class="k">SHIFT</span> · Interact: <span class="k">E</span> · Throw Mushroom: <span class="k">SPACE</span><br>
      Enter/Exit Car: stand near it + <span class="k">E</span> · Hide: near dumpster + hold <span class="k">E</span><br>
      Goal: reach <b>STARR BUILDING</b> → <b>audition.html</b> (north-east district)
    </div>
  </div>

  <div class="toast" id="toast"></div>
  <div class="wrap"><canvas id="c" width="320" height="180"></canvas></div>

<script>
/* ==========================================================
   SOPHIA STREET — open city (single-file)
   - On-foot + car driving
   - NPCs + mushrooms + "wanted" + cops chase
   - Dumpsters for hiding + cooldown
   - Building portals (links) for later pages
   - Same engine vibe: 320x180 pixel canvas, bevel UI, toast, zones
   ========================================================== */

const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d", { alpha:false });
ctx.imageSmoothingEnabled = false;

const UI = {
  status: document.getElementById("status"),
  mode: document.getElementById("mode"),
  mush: document.getElementById("mush"),
  wanted: document.getElementById("wanted"),
  keys: document.getElementById("keys"),
  toast: document.getElementById("toast"),
};

const STORE_KEY = "SOPHIA_AUDITION_SAVE_V1";

/* ---------- state ---------- */
function loadState(){
  const raw = localStorage.getItem(STORE_KEY);
  if(raw){ try{ return JSON.parse(raw); }catch(e){} }
  return {
    hasKeys:false, slept:false, trip:false, puke:false,
    poemLines:0, poems:[], guitarPlayed:0,
    outfit:0,
    lastRoom:"STREET",
    sophia:{x:320, y:520},
    milo:{x:300, y:540},
    street:{
      mushrooms:0,
      wanted:0,
      inCar:false,
      hidden:false,
      car:{x:360,y:560, vx:0, vy:0},
      seenTimer:0,
      lastThrow:0,
      egg:{found:false}
    }
  };
}
let state = loadState();
state.lastRoom = "STREET";
state.street = state.street || { mushrooms:0, wanted:0, inCar:false, hidden:false, car:{x:360,y:560,vx:0,vy:0}, seenTimer:0, lastThrow:0, egg:{found:false} };

function saveState(){ localStorage.setItem(STORE_KEY, JSON.stringify(state)); }

UI.keys.textContent = state.hasKeys ? "YES" : "NO";
UI.mush.textContent = (state.street.mushrooms|0);
UI.wanted.textContent = (state.street.wanted|0);
UI.mode.textContent = state.street.inCar ? "IN CAR" : "ON FOOT";

/* ---------- toast ---------- */
function toast(msg, ms=1500){
  UI.toast.textContent = msg;
  UI.toast.classList.add("on");
  clearTimeout(toast._t);
  toast._t = setTimeout(()=>UI.toast.classList.remove("on"), ms);
}

/* ---------- input ---------- */
const keysDown = new Set();
addEventListener("keydown",(e)=>{
  const k = e.key.toLowerCase();
  if(["arrowup","arrowdown","arrowleft","arrowright"," ","shift","w","a","s","d","e"].includes(k)) e.preventDefault();
  keysDown.add(k);
});
addEventListener("keyup",(e)=> keysDown.delete(e.key.toLowerCase()));

/* ---------- world + camera ---------- */
const VW = canvas.width, VH = canvas.height;

// Big world (camera follows player/car)
const WORLD = { w: 2200, h: 1400 };

// Camera
const cam = { x:0, y:0 };

// Helpful math
const clamp = (v,min,max)=> Math.max(min, Math.min(max,v));
const rand = (a,b)=> a + Math.random()*(b-a);

function rectsOverlap(ax,ay,aw,ah,bx,by,bw,bh){
  return ax<bx+bw && ax+aw>bx && ay<by+bh && ay+ah>by;
}
function dist2(ax,ay,bx,by){
  const dx=ax-bx, dy=ay-by;
  return dx*dx + dy*dy;
}

/* ==========================================================
   CITY LAYOUT (hand-crafted blocks + bright details)
   ========================================================== */

// Roads and blocks are mostly visuals; "solids" are collision walls.
const solids = [];

// Helper: add solid rect
function addSolid(x,y,w,h){ solids.push([x,y,w,h]); }

// City boundaries
addSolid(-50,-50, WORLD.w+100, 50);
addSolid(-50, WORLD.h, WORLD.w+100, 50);
addSolid(-50,-50, 50, WORLD.h+100);
addSolid(WORLD.w, -50, 50, WORLD.h+100);

// Blocks: buildings/city chunks (collision)
const buildings = [
  // HOME block (south-west)
  {name:"HOME", x:120, y:1080, w:220, h:160, link:"Sophie03.html", glow:"vio"},
  {name:"BACKYARD", x:360, y:1120, w:160, h:120, link:"Sophie02.html", glow:"aqua"},

  // GROCERY
  {name:"GROCERY", x:520, y:940, w:220, h:150, link:"grocery-store.html", glow:"sun"},
  // BLOCKBUSTER
  {name:"BLOCKBUSTER", x:780, y:980, w:240, h:160, link:"blockbuster.html", glow:"vio"},
  // CAT STORE
  {name:"CAT STORE", x:1050, y:960, w:210, h:140, link:"catstore.html", glow:"hot"},
  // WEED SHOP
  {name:"WEED SHOP", x:1290, y:980, w:210, h:140, link:"weedshop.html", glow:"aqua"},

  // STARR BUILDING (audition) north-east
  {name:"STARR", x:1710, y:250, w:320, h:260, link:"audition.html", glow:"sun"},
];

// Add solids for buildings, but leave "door zones" as interact rectangles (no solid gap needed in this style)
for(const b of buildings){
  addSolid(b.x, b.y, b.w, b.h);
}

// Decorative obstacles: planter islands, statues, medians
const decorSolids = [
  [620,720,120,40],
  [1040,740,140,36],
  [1460,760,160,40],
  [1640,880,180,36],
  [420,660,90,32],
  [1880,630,120,46],
];
decorSolids.forEach(d=>addSolid(...d));

// Alleys (narrow walls)
addSolid(920,680,18,260);
addSolid(940,680,80,18);
addSolid(940,922,80,18);

// Park fences
addSolid(260,360,320,18);
addSolid(260,378,18,200);
addSolid(562,378,18,200);
addSolid(260,578,320,18);

/* ==========================================================
   ENTITIES
   ========================================================== */

// Player on foot
const sophia = { x: state.sophia.x, y: state.sophia.y, w:10, h:12, speed:0.92, run:1.45 };

// Milo
const milo = { x: state.milo.x, y: state.milo.y, w:8, h:8 };

// Car (drivable)
const car = {
  x: state.street.car?.x ?? 360,
  y: state.street.car?.y ?? 560,
  w: 18, h: 10,
  vx: state.street.car?.vx ?? 0,
  vy: state.street.car?.vy ?? 0,
  dir: 0, // direction for visuals only
  boost: 1.0,
};

// NPCs
const NPC_COUNT = 22;
const npcs = [];
for(let i=0;i<NPC_COUNT;i++){
  npcs.push({
    x: rand(220, WORLD.w-220),
    y: rand(220, WORLD.h-220),
    vx: rand(-0.25,0.25),
    vy: rand(-0.25,0.25),
    mood: (Math.random()<0.6) ? "chill" : "busy",
    hit: 0,
    color: (Math.random()<0.33) ? "aqua" : (Math.random()<0.5 ? "vio" : "sun"),
  });
}

// Mushrooms in world (collect)
const mushrooms = [];
for(let i=0;i<46;i++){
  mushrooms.push({
    x: rand(180, WORLD.w-180),
    y: rand(180, WORLD.h-180),
    alive: true,
    kind: (Math.random()<0.12) ? "gold" : "vio",
  });
}

// Dumpsters (hide)
const dumpsters = [
  {x: 640, y: 860, w: 34, h: 18},
  {x: 980, y: 920, w: 34, h: 18},
  {x: 1500, y: 910, w: 34, h: 18},
  {x: 1660, y: 740, w: 34, h: 18},
  {x: 360, y: 740, w: 34, h: 18},
];

// Trees (decor)
const trees = [];
for(let i=0;i<70;i++){
  trees.push({x: rand(80, WORLD.w-80), y: rand(80, WORLD.h-80), s: rand(0.8, 1.6), hue: (Math.random()<0.5 ? "aqua":"sun")});
}

// Projectiles (thrown mushrooms)
const shots = [];

// Cops (spawn when wanted)
const cops = [];

/* ==========================================================
   COLLISION
   ========================================================== */

function collides(x,y,w,h){
  for(const s of solids){
    if(rectsOverlap(x,y,w,h, s[0],s[1],s[2],s[3])) return true;
  }
  return false;
}

function tryMove(ent,dx,dy){
  const nx = ent.x + dx, ny = ent.y + dy;
  if(!collides(nx, ent.y, ent.w, ent.h)) ent.x = nx;
  if(!collides(ent.x, ny, ent.w, ent.h)) ent.y = ny;
  ent.x = clamp(ent.x, 0, WORLD.w-ent.w);
  ent.y = clamp(ent.y, 0, WORLD.h-ent.h);
}

function tryMoveCar(dx,dy){
  // car collision uses its rect
  const nx = car.x + dx, ny = car.y + dy;
  if(!collides(nx, car.y, car.w, car.h)) car.x = nx; else car.vx *= -0.25;
  if(!collides(car.x, ny, car.w, car.h)) car.y = ny; else car.vy *= -0.25;
  car.x = clamp(car.x, 0, WORLD.w-car.w);
  car.y = clamp(car.y, 0, WORLD.h-car.h);
}

/* ==========================================================
   ZONES (buildings, car, dumpsters)
   ========================================================== */

function nearestZone(){
  const px = (state.street.inCar ? car.x+car.w/2 : sophia.x+sophia.w/2);
  const py = (state.street.inCar ? car.y+car.h/2 : sophia.y+sophia.h/2);

  let best=null, bd=999999;

  // Door zones for buildings: small strip at bottom of each building
  for(const b of buildings){
    const z = {name: (b.name==="STARR" ? "STARR BUILDING" : b.name), rect:[b.x + b.w/2 - 20, b.y + b.h - 10, 40, 10], action: ()=>go(b.link)};
    const [x,y,w,h] = z.rect;
    const cx=x+w/2, cy=y+h/2;
    const d = dist2(px,py,cx,cy);
    if(d<bd && d<1800){ bd=d; best=z; }
  }

  // Car enter/exit zone (only when on foot)
  if(!state.street.inCar){
    const z = {name:"CAR", rect:[car.x-6, car.y-6, car.w+12, car.h+12], action: toggleCar};
    const [x,y,w,h] = z.rect;
    const cx=x+w/2, cy=y+h/2;
    const d = dist2(px,py,cx,cy);
    if(d<bd && d<1800){ bd=d; best=z; }
  }else{
    // In-car: allow exit anywhere but safer if stopped
    const z = {name:"EXIT CAR", rect:[car.x-6, car.y-6, car.w+12, car.h+12], action: toggleCar};
    const [x,y,w,h]=z.rect;
    const cx=x+w/2, cy=y+h/2;
    const d=dist2(px,py,cx,cy);
    if(d<bd && d<1800){ bd=d; best=z; }
  }

  // Dumpster hide zone (works only on foot)
  if(!state.street.inCar){
    for(const dmp of dumpsters){
      const z = {name:"DUMPSTER", rect:[dmp.x,dmp.y,dmp.w,dmp.h], action: startHide};
      const cx=dmp.x+dmp.w/2, cy=dmp.y+dmp.h/2;
      const d = dist2(px,py,cx,cy);
      if(d<bd && d<1500){ bd=d; best=z; }
    }
  }

  return best;
}

function interactPress(){
  const z = nearestZone();
  if(z) z.action();
}

/* ==========================================================
   CORE MECHANICS
   ========================================================== */

function toggleCar(){
  if(!state.street.inCar){
    // enter car only if near and not hidden
    if(state.street.hidden) return toast("Not while hiding. (Sophia holds her breath.)", 1400);
    state.street.inCar = true;
    UI.mode.textContent = "IN CAR";
    toast("She slides into the car. Milo becomes co-pilot.", 1600);

    // snap Sophia to car (so exit feels clean)
    sophia.x = car.x + 4; sophia.y = car.y + 2;
  }else{
    // exit car: require slow speed
    const sp = Math.hypot(car.vx, car.vy);
    if(sp > 2.2) return toast("Too fast to jump out. (Your knees disagree.)", 1400);
    state.street.inCar = false;
    UI.mode.textContent = "ON FOOT";
    toast("Back on foot. City noise returns.", 1400);

    // place Sophia beside car
    sophia.x = clamp(car.x - 14, 0, WORLD.w-sophia.w);
    sophia.y = clamp(car.y + 2, 0, WORLD.h-sophia.h);
  }
  saveState();
}

let hideHold = 0;
function startHide(){
  if(state.street.wanted<=0) return toast("She checks the dumpster. (It checks back.)", 1300);
  toast("Hold E to hide…", 1100);
  hideHold = 1; // start counting in loop while E is held
}

function enterHidden(){
  state.street.hidden = true;
  state.street.seenTimer = 0;
  toast("She hides. The world muffles. Milo goes statue-mode.", 1700);
  saveState();
}
function exitHidden(){
  state.street.hidden = false;
  toast("She slips out. Please be quiet, shoes.", 1400);
  saveState();
}

/* ---------- mushroom collecting ---------- */
function collectMushrooms(){
  const px = (state.street.inCar ? car.x+car.w/2 : sophia.x+sophia.w/2);
  const py = (state.street.inCar ? car.y+car.h/2 : sophia.y+sophia.h/2);

  for(const m of mushrooms){
    if(!m.alive) continue;
    if(dist2(px,py,m.x,m.y) < 14*14){
      m.alive=false;
      state.street.mushrooms = (state.street.mushrooms|0) + (m.kind==="gold" ? 2 : 1);
      UI.mush.textContent = state.street.mushrooms;
      toast(m.kind==="gold" ? "GOLD MUSHROOM (+2). The city winks." : "Mushroom collected (+1).", 1200);

      // tiny easter egg: collect 10 without wanted
      if(!state.street.egg.found && state.street.mushrooms>=10 && state.street.wanted===0){
        state.street.egg.found = true;
        toast("Easter egg: ‘CALM HANDS’ unlocked. (Wanted cooldown faster.)", 2000);
      }

      saveState();
    }
  }
}

/* ---------- throwing mushrooms ---------- */
function canThrow(){
  const now = performance.now();
  if(now - state.street.lastThrow < 220) return false;
  if((state.street.mushrooms|0) <= 0) return false;
  return true;
}

function throwMushroom(){
  if(state.street.inCar) return toast("Not while driving. (One hand on wheel.)", 1200);
  if(state.street.hidden) return toast("Not while hiding. (Mushroom stays pocketed.)", 1200);
  if(!canThrow()) return;

  state.street.lastThrow = performance.now();
  state.street.mushrooms--;
  UI.mush.textContent = state.street.mushrooms;

  // aim direction from movement keys (fallback: toward nearest npc)
  let ax=0, ay=0;
  if(keysDown.has("w")||keysDown.has("arrowup")) ay-=1;
  if(keysDown.has("s")||keysDown.has("arrowdown")) ay+=1;
  if(keysDown.has("a")||keysDown.has("arrowleft")) ax-=1;
  if(keysDown.has("d")||keysDown.has("arrowright")) ax+=1;
  if(ax===0 && ay===0){
    // toward nearest npc
    let best=null, bd=999999;
    for(const n of npcs){
      const d=dist2(n.x,n.y,sophia.x,sophia.y);
      if(d<bd){bd=d;best=n;}
    }
    if(best){
      ax = (best.x - sophia.x);
      ay = (best.y - sophia.y);
    }else ax=1;
  }
  const mag = Math.hypot(ax,ay) || 1;
  ax/=mag; ay/=mag;

  shots.push({
    x: sophia.x+5,
    y: sophia.y+6,
    vx: ax*2.9,
    vy: ay*2.9,
    life: 120,
  });

  toast("Mushroom thrown.", 900);
  saveState();
}

/* ---------- wanted + cops ---------- */
function setWanted(w){
  state.street.wanted = clamp(w|0, 0, 5);
  UI.wanted.textContent = state.street.wanted;
  saveState();
}

function escalateWanted(){
  const w = (state.street.wanted|0);
  if(w===0) toast("People scream. Sirens think about it.", 1400);
  setWanted(w+1);

  // spawn cops proportional to wanted
  spawnCops();
}

function spawnCops(){
  const target = 1 + state.street.wanted*2;
  while(cops.length < target){
    // spawn from edges
    const edge = (Math.random()*4)|0;
    let x=0,y=0;
    if(edge===0){ x=rand(0,WORLD.w); y=10; }
    if(edge===1){ x=rand(0,WORLD.w); y=WORLD.h-20; }
    if(edge===2){ x=10; y=rand(0,WORLD.h); }
    if(edge===3){ x=WORLD.w-20; y=rand(0,WORLD.h); }

    cops.push({
      x, y, w:10, h:12,
      vx:0, vy:0,
      lose:0,
      blink:rand(0,999),
    });
  }
}

function coolWanted(){
  // wanted decays if not seen for a bit
  if(state.street.wanted<=0) return;
  // calm hands easter egg: faster decay
  const calm = state.street.egg.found ? 1.35 : 1.0;
  state.street.seenTimer += 1*calm;
  // every ~7 seconds unseen -> reduce 1
  if(state.street.seenTimer > 420){
    state.street.seenTimer = 0;
    setWanted(state.street.wanted - 1);
    toast("Heat drops. The city exhales.", 1300);
    // trim cops if low wanted
    if(state.street.wanted<=1){
      cops.splice(0, Math.max(0, cops.length-3));
    }
  }
}

function markSeen(){
  state.street.seenTimer = 0;
}

/* ==========================================================
   NAVIGATION
   ========================================================== */

function go(file){
  // persist important stuff
  state.sophia.x = sophia.x; state.sophia.y = sophia.y;
  state.milo.x = milo.x; state.milo.y = milo.y;
  state.street.car = {x:car.x,y:car.y,vx:car.vx,vy:car.vy};
  saveState();
  location.href = file;
}

/* ==========================================================
   RENDER HELPERS (same bevel/hint style, brighter palette)
   ========================================================== */

function drawRectBevel(x,y,w,h,fill){
  ctx.fillStyle=fill; ctx.fillRect(x,y,w,h);
  ctx.fillStyle="rgba(255,255,255,.10)"; ctx.fillRect(x,y,w,1);
  ctx.fillStyle="rgba(0,0,0,.40)"; ctx.fillRect(x,y+h-1,w,1);
  ctx.fillStyle="rgba(255,255,255,.07)"; ctx.fillRect(x,y,1,h);
  ctx.fillStyle="rgba(0,0,0,.45)"; ctx.fillRect(x+w-1,y,1,h);
}

function drawHintBubble(text,x,y){
  const pad=3;
  ctx.font="8px ui-monospace, monospace";
  const m=ctx.measureText(text);
  const w=Math.ceil(m.width)+pad*2, h=12;
  ctx.fillStyle="rgba(0,0,0,.70)";
  ctx.fillRect(x-w/2,y-h,w,h);
  ctx.strokeStyle="rgba(255,255,255,.16)";
  ctx.strokeRect(x-w/2+0.5,y-h+0.5,w-1,h-1);
  ctx.fillStyle="rgba(255,255,255,.92)";
  ctx.fillText(text,x-w/2+pad,y-4);
}

function worldToView(x,y){
  return { x: Math.round(x - cam.x), y: Math.round(y - cam.y) };
}

/* ==========================================================
   DRAW WORLD (bright, colorful, alive)
   ========================================================== */

function drawBackground(t){
  // base
  ctx.fillStyle="#04040a";
  ctx.fillRect(0,0,VW,VH);

  // sky glow
  const g = ctx.createRadialGradient(VW*0.5, VH*0.35, 10, VW*0.5, VH*0.35, 220);
  g.addColorStop(0, "rgba(255,210,77,.12)");
  g.addColorStop(0.35, "rgba(0,255,213,.08)");
  g.addColorStop(0.7, "rgba(138,46,255,.10)");
  g.addColorStop(1, "rgba(0,0,0,0)");
  ctx.fillStyle=g; ctx.fillRect(0,0,VW,VH);

  // subtle scanlines
  for(let y=0;y<VH;y+=3){
    ctx.fillStyle = `rgba(255,255,255,${(y%9===0)?0.04:0.02})`;
    ctx.fillRect(0,y,VW,1);
  }
}

function drawRoads(t){
  // Simple road grid: draw rectangles (visual-only)
  // We'll paint big asphalt bands and neon lane hints.

  // Asphalt tone
  function asphalt(x,y,w,h){
    const v = worldToView(x,y);
    drawRectBevel(v.x,v.y,w,h,"rgba(255,255,255,.045)");
    // lane specks
    ctx.fillStyle="rgba(0,0,0,.32)";
    ctx.fillRect(v.x+2,v.y+2,w-4,h-4);
  }

  // Main horizontal road mid
  asphalt(0, 760, WORLD.w, 120);

  // Vertical boulevard to STARR
  asphalt(1520, 0, 150, WORLD.h);

  // Neighborhood roads
  asphalt(420, 960, 520, 90);
  asphalt(940, 920, 520, 90);
  asphalt(220, 520, 720, 90);
  asphalt(820, 520, 780, 90);

  // Neon lane markers (subtle)
  function lane(x,y,w,h,a){
    const v=worldToView(x,y);
    ctx.fillStyle=a;
    for(let i=0;i<w;i+=14){
      ctx.fillRect(v.x+i, v.y, 8, h);
    }
  }
  lane(20, 815, WORLD.w-40, 2, "rgba(0,255,213,.12)");
  lane(1540, 20, 2, WORLD.h-40, "rgba(138,46,255,.12)");
}

function drawParksAndGrass(t){
  // park area north-west (inside the fence solids)
  const park = {x:260,y:360,w:320,h:236};
  const v=worldToView(park.x,park.y);
  drawRectBevel(v.x,v.y,park.w,park.h,"rgba(0,255,170,.06)");
  // sprinkles
  for(let i=0;i<40;i++){
    const px = v.x + ((i*23 + (t*0.4|0))%park.w);
    const py = v.y + (i*7)%park.h;
    ctx.fillStyle="rgba(255,210,77,.04)";
    ctx.fillRect(px,py,1,1);
  }

  // general ground “city glow”
  // (just a gentle wash that makes it brighter)
  ctx.fillStyle="rgba(0,255,170,.015)";
  ctx.fillRect(0,0,VW,VH);
}

function drawTrees(t){
  for(const tr of trees){
    // skip if out of view
    if(tr.x<cam.x-30 || tr.x>cam.x+VW+30 || tr.y<cam.y-30 || tr.y>cam.y+VH+30) continue;
    const v=worldToView(tr.x,tr.y);
    const s=tr.s;
    // trunk
    ctx.fillStyle="rgba(0,0,0,.45)";
    ctx.fillRect(v.x, v.y, 2, 5*s);
    // canopy
    const glow = (tr.hue==="aqua") ? "rgba(0,255,213,.10)" : "rgba(255,210,77,.10)";
    ctx.fillStyle=glow;
    ctx.fillRect(v.x-4*s, v.y-5*s, 10*s, 9*s);
    ctx.fillStyle="rgba(255,255,255,.06)";
    ctx.fillRect(v.x-3*s, v.y-4*s, 8*s, 7*s);
  }
}

function drawBuildings(t){
  for(const b of buildings){
    // cull
    if(b.x+b.w<cam.x-10 || b.x>cam.x+VW+10 || b.y+b.h<cam.y-10 || b.y>cam.y+VH+10) continue;

    const v=worldToView(b.x,b.y);
    // base fill
    drawRectBevel(v.x,v.y,b.w,b.h,"rgba(255,255,255,.055)");

    // interior shadow
    ctx.fillStyle="rgba(0,0,0,.45)";
    ctx.fillRect(v.x+3, v.y+3, b.w-6, b.h-6);

    // sign glow strip
    const stripH=18;
    let glow = "rgba(138,46,255,.22)";
    if(b.glow==="aqua") glow="rgba(0,255,213,.20)";
    if(b.glow==="sun") glow="rgba(255,210,77,.20)";
    if(b.glow==="hot") glow="rgba(255,99,255,.18)";
    ctx.fillStyle=glow;
    ctx.fillRect(v.x+6, v.y+6, b.w-12, stripH);

    // sign text (pixel-ish)
    ctx.font="8px ui-monospace, monospace";
    ctx.fillStyle="rgba(255,255,255,.92)";
    const label = (b.name==="STARR" ? "STARR BUILDING" : b.name);
    ctx.fillText(label, v.x+10, v.y+18);

    // windows
    for(let i=0;i<Math.max(2,(b.w/46|0));i++){
      const wx=v.x+10+i*42;
      const wy=v.y+32;
      ctx.fillStyle="rgba(0,255,213,.06)";
      ctx.fillRect(wx,wy,24,10);
      ctx.fillStyle="rgba(255,255,255,.06)";
      ctx.fillRect(wx+1,wy+1,22,8);
    }

    // door zone highlight (bottom-center)
    const dz = {x:b.x+b.w/2-20, y:b.y+b.h-10, w:40, h:10};
    const dv=worldToView(dz.x,dz.y);
    ctx.fillStyle="rgba(255,255,255,.09)";
    ctx.fillRect(dv.x,dv.y,dz.w,dz.h);
    ctx.fillStyle="rgba(0,0,0,.55)";
    ctx.fillRect(dv.x+2,dv.y+2,dz.w-4,dz.h-4);
    if(b.name==="STARR"){
      ctx.fillStyle="rgba(255,210,77,.35)";
      ctx.fillRect(dv.x+2,dv.y+2,6,6);
    }
  }
}

function drawDecor(t){
  // planter islands / medians
  for(const d of decorSolids){
    if(d[0]+d[2]<cam.x-10 || d[0]>cam.x+VW+10 || d[1]+d[3]<cam.y-10 || d[1]>cam.y+VH+10) continue;
    const v=worldToView(d[0],d[1]);
    drawRectBevel(v.x,v.y,d[2],d[3],"rgba(0,255,170,.05)");
    ctx.fillStyle="rgba(255,210,77,.06)";
    ctx.fillRect(v.x+2,v.y+2,d[2]-4,2);
  }

  // dumpsters
  for(const dmp of dumpsters){
    if(dmp.x+dmp.w<cam.x-10 || dmp.x>cam.x+VW+10 || dmp.y+dmp.h<cam.y-10 || dmp.y>cam.y+VH+10) continue;
    const v=worldToView(dmp.x,dmp.y);
    drawRectBevel(v.x,v.y,dmp.w,dmp.h,"rgba(255,255,255,.05)");
    ctx.fillStyle="rgba(0,0,0,.55)";
    ctx.fillRect(v.x+3,v.y+3,dmp.w-6,dmp.h-6);
    ctx.fillStyle="rgba(0,255,213,.10)";
    ctx.fillRect(v.x+3,v.y+3,8,4);
  }

  // mushrooms
  for(const m of mushrooms){
    if(!m.alive) continue;
    if(m.x<cam.x-10||m.x>cam.x+VW+10||m.y<cam.y-10||m.y>cam.y+VH+10) continue;
    const v=worldToView(m.x,m.y);
    ctx.fillStyle="rgba(255,255,255,.10)";
    ctx.fillRect(v.x, v.y+2, 6, 2);
    ctx.fillStyle = (m.kind==="gold") ? "rgba(255,210,77,.55)" : "rgba(138,46,255,.45)";
    ctx.fillRect(v.x+1, v.y, 4, 2);
  }
}

function drawNPCs(t){
  for(const n of npcs){
    if(n.x<cam.x-20||n.x>cam.x+VW+20||n.y<cam.y-20||n.y>cam.y+VH+20) continue;
    const v=worldToView(n.x,n.y);

    // shadow
    ctx.fillStyle="rgba(0,0,0,.35)";
    ctx.fillRect(v.x-1, v.y+12, 12, 2);

    // body
    ctx.fillStyle="rgba(255,255,255,.07)";
    ctx.fillRect(v.x, v.y, 10, 12);

    // neon shirt
    let c="rgba(138,46,255,.35)";
    if(n.color==="aqua") c="rgba(0,255,213,.35)";
    if(n.color==="sun") c="rgba(255,210,77,.35)";
    ctx.fillStyle=c;
    ctx.fillRect(v.x+2, v.y+7, 6, 3);

    // face pixel
    ctx.fillStyle="rgba(255,255,255,.18)";
    ctx.fillRect(v.x+3, v.y+3, 4, 2);

    // hit effect
    if(n.hit>0){
      ctx.fillStyle=`rgba(255,99,255,${0.12 + 0.10*Math.sin(n.hit*0.6)})`;
      ctx.fillRect(v.x-2, v.y-2, 14, 16);
    }
  }
}

function drawCops(t){
  for(const c of cops){
    if(c.x<cam.x-20||c.x>cam.x+VW+20||c.y<cam.y-20||c.y>cam.y+VH+20) continue;
    const v=worldToView(c.x,c.y);

    // shadow
    ctx.fillStyle="rgba(0,0,0,.40)";
    ctx.fillRect(v.x-1,v.y+12,12,2);

    // uniform
    ctx.fillStyle="rgba(255,255,255,.06)";
    ctx.fillRect(v.x,v.y,10,12);
    ctx.fillStyle="rgba(0,255,213,.18)";
    ctx.fillRect(v.x+2,v.y+7,6,3);

    // siren blink
    const blink = ((t + (c.blink|0)) % 24) < 8;
    ctx.fillStyle = blink ? "rgba(255,99,255,.65)" : "rgba(255,210,77,.45)";
    ctx.fillRect(v.x+2, v.y-2, 6, 2);
  }
}

function drawShots(t){
  for(const s of shots){
    if(s.x<cam.x-10||s.x>cam.x+VW+10||s.y<cam.y-10||s.y>cam.y+VH+10) continue;
    const v=worldToView(s.x,s.y);
    ctx.fillStyle="rgba(255,255,255,.85)";
    ctx.fillRect(v.x, v.y, 2, 2);
    ctx.fillStyle="rgba(138,46,255,.25)";
    ctx.fillRect(v.x-1, v.y-1, 4, 4);
  }
}

function drawCar(t){
  // only draw car if visible
  if(car.x+car.w<cam.x-20||car.x>cam.x+VW+20||car.y+car.h<cam.y-20||car.y>cam.y+VH+20) return;
  const v=worldToView(car.x,car.y);

  // glow underside
  ctx.fillStyle="rgba(0,255,213,.10)";
  ctx.fillRect(v.x, v.y+car.h, car.w, 2);

  // body
  drawRectBevel(v.x,v.y,car.w,car.h,"rgba(255,255,255,.07)");
  ctx.fillStyle="rgba(0,0,0,.50)";
  ctx.fillRect(v.x+2,v.y+2,car.w-4,car.h-4);

  // windshield + neon stripe
  ctx.fillStyle="rgba(255,210,77,.10)";
  ctx.fillRect(v.x+3,v.y+3,car.w-6,2);
  ctx.fillStyle="rgba(138,46,255,.20)";
  ctx.fillRect(v.x+3,v.y+6,car.w-6,2);

  // “driver pixel” if in car
  if(state.street.inCar){
    ctx.fillStyle="rgba(255,255,255,.18)";
    ctx.fillRect(v.x+4, v.y+4, 2, 2);
    // Milo co-pilot pixel
    ctx.fillStyle="rgba(0,255,213,.18)";
    ctx.fillRect(v.x+car.w-6, v.y+4, 2, 2);
  }
}

/* Sophia + Milo (same vibe as other rooms) */
function drawSophia(t){
  if(state.street.inCar || state.street.hidden) return;

  const x=Math.round(sophia.x - cam.x), y=Math.round(sophia.y - cam.y);
  // shadow
  ctx.fillStyle="rgba(0,0,0,.45)";
  ctx.fillRect(x-1,y+11,12,2);

  // hair
  ctx.fillStyle="#f2d27a";
  ctx.fillRect(x+1,y+0,8,4);
  ctx.fillRect(x+0,y+3,10,3);

  // face
  ctx.fillStyle="#ffd9c9";
  ctx.fillRect(x+2,y+5,6,4);

  // eyes
  ctx.fillStyle="#67b7ff";
  ctx.fillRect(x+3,y+6,1,1);
  ctx.fillRect(x+6,y+6,1,1);

  // dress
  ctx.fillStyle="rgba(138,46,255,.55)";
  ctx.fillRect(x+2,y+9,6,3);
  ctx.fillStyle="rgba(255,255,255,.14)";
  ctx.fillRect(x+3,y+10,4,1);
}

function drawMilo(t){
  if(state.street.inCar || state.street.hidden) return;

  const x=Math.round(milo.x - cam.x), y=Math.round(milo.y - cam.y);
  ctx.fillStyle="rgba(0,0,0,.40)";
  ctx.fillRect(x-1,y+7,10,2);
  ctx.fillStyle="#d8d8d8";
  ctx.fillRect(x+1,y+2,6,5);
  ctx.fillStyle="#cfcfcf";
  ctx.fillRect(x+1,y+1,2,2);
  ctx.fillRect(x+5,y+1,2,2);
  // eyes
  ctx.fillStyle="#1affd3";
  ctx.fillRect(x+2,y+4,1,1);
  ctx.fillRect(x+5,y+4,1,1);
  // tail
  ctx.fillStyle="#cfcfcf";
  ctx.fillRect(x+7,y+3,1,3);
}

function drawWantedOverlay(t){
  const w = state.street.wanted|0;
  if(w<=0) return;

  // siren wash
  const a = 0.05 + 0.02*w;
  const blink = (t%30)<15;
  ctx.fillStyle = blink ? `rgba(255,99,255,${a})` : `rgba(0,255,213,${a})`;
  ctx.fillRect(0,0,VW,VH);

  // edge vignette
  ctx.fillStyle="rgba(0,0,0,.22)";
  ctx.fillRect(0,0,VW,2);
  ctx.fillRect(0,VH-2,VW,2);
  ctx.fillRect(0,0,2,VH);
  ctx.fillRect(VW-2,0,2,VH);
}

function drawHiddenOverlay(t){
  if(!state.street.hidden) return;

  // muffled black-green
  ctx.fillStyle="rgba(0,0,0,.55)";
  ctx.fillRect(0,0,VW,VH);
  ctx.fillStyle=`rgba(0,255,213,${0.06 + 0.04*Math.sin(t*0.12)})`;
  ctx.fillRect(0,0,VW,VH);

  ctx.font="9px ui-monospace, monospace";
  ctx.fillStyle="rgba(255,255,255,.8)";
  ctx.fillText("HIDING… (hold E to stay, release to exit)", 18, 92);
}

/* ==========================================================
   UPDATE LOOP
   ========================================================== */

function updateNPCs(t){
  for(const n of npcs){
    // wander
    if(Math.random()<0.01){
      n.vx += rand(-0.12,0.12);
      n.vy += rand(-0.12,0.12);
    }
    n.vx = clamp(n.vx, -0.55, 0.55);
    n.vy = clamp(n.vy, -0.55, 0.55);

    // avoid buildings a bit (simple bounce)
    const nx = n.x + n.vx;
    const ny = n.y + n.vy;
    if(!collides(nx, n.y, 10, 12)) n.x = nx; else n.vx *= -0.8;
    if(!collides(n.x, ny, 10, 12)) n.y = ny; else n.vy *= -0.8;

    // keep in world
    n.x = clamp(n.x, 0, WORLD.w-10);
    n.y = clamp(n.y, 0, WORLD.h-12);

    if(n.hit>0) n.hit--;
  }
}

function updateShots(){
  for(let i=shots.length-1;i>=0;i--){
    const s=shots[i];
    s.x += s.vx;
    s.y += s.vy;
    s.life--;

    // collide with solids -> poof
    if(collides(s.x, s.y, 2, 2)){
      shots.splice(i,1);
      continue;
    }

    // hit npc -> wanted
    for(const n of npcs){
      if(rectsOverlap(s.x,s.y,2,2, n.x,n.y,10,12)){
        n.hit = 60;
        shots.splice(i,1);
        escalateWanted();
        toast("Mushroom splat. Bad choice. Cops agree.", 1600);
        break;
      }
    }
    if(i>=shots.length) continue;
    if(s.life<=0) shots.splice(i,1);
  }
}

function updateCops(t){
  const w = state.street.wanted|0;
  if(w<=0){
    cops.length = 0;
    return;
  }

  // Target is Sophia unless in car, then target car.
  const tx = state.street.inCar ? (car.x+car.w/2) : (sophia.x+sophia.w/2);
  const ty = state.street.inCar ? (car.y+car.h/2) : (sophia.y+sophia.h/2);

  // If hidden, cops lose track over time (unless extremely close)
  const hidden = state.street.hidden;

  for(const c of cops){
    let vx=0,vy=0;

    const dx = tx - (c.x+5);
    const dy = ty - (c.y+6);
    const d = Math.hypot(dx,dy) || 1;

    // "vision" check (simple): if not hidden and within range -> seen
    const seen = (!hidden && d < 240) || (hidden && d < 42);
    if(seen){
      markSeen();
      c.lose = 0;
    }else{
      c.lose += 1;
    }

    // If hidden and cops haven't seen for a bit, they drift / search
    if(hidden && c.lose > 90){
      vx = Math.sin((t+c.blink)*0.03)*0.35;
      vy = Math.cos((t+c.blink)*0.04)*0.35;
    }else{
      // chase
      const sp = 0.85 + 0.15*w;
      vx = (dx/d) * sp;
      vy = (dy/d) * sp;
    }

    // move with collision
    const nx=c.x+vx, ny=c.y+vy;
    if(!collides(nx, c.y, c.w, c.h)) c.x=nx; else c.vx*=-0.2;
    if(!collides(c.x, ny, c.w, c.h)) c.y=ny; else c.vy*=-0.2;

    // catch: if cop overlaps player/car -> spikes wanted effect (but no game over)
    if(!hidden){
      if(state.street.inCar){
        if(rectsOverlap(c.x,c.y,c.w,c.h, car.x,car.y,car.w,car.h)){
          toast("Cop bumps your bumper. Siren screams in lowercase.", 1200);
          // little knockback
          car.vx *= -0.5; car.vy *= -0.5;
          // increase heat a touch
          if(Math.random()<0.2) setWanted(state.street.wanted + 1);
        }
      }else{
        if(rectsOverlap(c.x,c.y,c.w,c.h, sophia.x,sophia.y,sophia.w,sophia.h)){
          toast("Caught. They lecture you about mushrooms. Loudly.", 1400);
          // small penalty: drop 1 mushroom
          if(state.street.mushrooms>0){
            state.street.mushrooms--;
            UI.mush.textContent=state.street.mushrooms;
          }
          // push sophia away
          sophia.x = clamp(sophia.x - dx*0.02, 0, WORLD.w-sophia.w);
          sophia.y = clamp(sophia.y - dy*0.02, 0, WORLD.h-sophia.h);
          markSeen();
        }
      }
    }
  }
}

function updatePlayer(t){
  // Hiding logic: if hidden, player doesn't move
  if(state.street.hidden){
    // if E released -> exit hidden
    if(!keysDown.has("e")) exitHidden();
    return;
  }

  if(state.street.inCar){
    // Driving
    const boost = keysDown.has("shift") ? 1.18 : 1.0;

    let ax=0, ay=0;
    if(keysDown.has("w")||keysDown.has("arrowup")) ay -= 1;
    if(keysDown.has("s")||keysDown.has("arrowdown")) ay += 1;
    if(keysDown.has("a")||keysDown.has("arrowleft")) ax -= 1;
    if(keysDown.has("d")||keysDown.has("arrowright")) ax += 1;

    // normalize
    if(ax && ay){ ax*=0.72; ay*=0.72; }

    // acceleration
    const accel = 0.22 * boost;
    car.vx += ax*accel;
    car.vy += ay*accel;

    // friction
    car.vx *= 0.92;
    car.vy *= 0.92;

    // cap speed
    const maxSp = 3.0 * boost;
    const sp = Math.hypot(car.vx,car.vy);
    if(sp > maxSp){
      car.vx = (car.vx/sp)*maxSp;
      car.vy = (car.vy/sp)*maxSp;
    }

    // move + collide
    tryMoveCar(car.vx, car.vy);

    // keep Sophia/Milo “with” car
    sophia.x = car.x + 4; sophia.y = car.y + 2;
    milo.x = car.x + car.w - 10; milo.y = car.y + 2;

  }else{
    // On foot
    const run = keysDown.has("shift");
    const sp = sophia.speed * (run ? sophia.run : 1);

    let dx=0, dy=0;
    if(keysDown.has("w")||keysDown.has("arrowup")) dy-=sp;
    if(keysDown.has("s")||keysDown.has("arrowdown")) dy+=sp;
    if(keysDown.has("a")||keysDown.has("arrowleft")) dx-=sp;
    if(keysDown.has("d")||keysDown.has("arrowright")) dx+=sp;
    if(dx&&dy){dx*=0.72; dy*=0.72;}
    if(dx||dy) tryMove(sophia,dx,dy);

    // Milo follow
    const tx=sophia.x-10, ty=sophia.y+6;
    milo.x += (tx - milo.x)*0.07;
    milo.y += (ty - milo.y)*0.07;

    // If holding E near dumpster and wanted > 0, enter hidden after a moment
    if(keysDown.has("e") && hideHold){
      hideHold++;
      if(hideHold>28){
        hideHold=0;
        enterHidden();
      }
    }
    if(!keysDown.has("e")) hideHold=0;
  }

  // collection works for both modes
  collectMushrooms();
}

function updateCamera(){
  const px = state.street.inCar ? (car.x+car.w/2) : (sophia.x+sophia.w/2);
  const py = state.street.inCar ? (car.y+car.h/2) : (sophia.y+sophia.h/2);

  // camera follow with gentle smoothing
  const targetX = clamp(px - VW/2, 0, WORLD.w - VW);
  const targetY = clamp(py - VH/2, 0, WORLD.h - VH);

  cam.x += (targetX - cam.x) * 0.12;
  cam.y += (targetY - cam.y) * 0.12;
}

/* ==========================================================
   INTERACT + THROW bindings
   ========================================================== */

let spaceWasDown=false;
let eWasDown=false;

function handleButtons(){
  // Space = throw mushroom (tap)
  const sp = keysDown.has(" ");
  if(sp && !spaceWasDown){
    throwMushroom();
  }
  spaceWasDown = sp;

  // E = interact (tap), unless hidden (handled in update)
  const e = keysDown.has("e");
  if(e && !eWasDown){
    // If hidden, updatePlayer will keep you there
    if(!state.street.hidden){
      // If near dumpster and wanted > 0, start hide workflow,
      // else normal interact.
      const z = nearestZone();
      if(z && z.name==="DUMPSTER" && state.street.wanted>0){
        startHide();
      }else{
        interactPress();
      }
    }
  }
  eWasDown = e;
}

/* ==========================================================
   DRAW FRAME
   ========================================================== */

function draw(t){
  drawBackground(t);
  drawParksAndGrass(t);
  drawRoads(t);
  drawTrees(t);
  drawBuildings(t);
  drawDecor(t);

  drawCar(t);
  drawShots(t);
  drawNPCs(t);
  drawCops(t);

  // player last for clarity
  drawMilo(t);
  drawSophia(t);

  // hint bubble
  const z = nearestZone();
  if(z && !state.street.hidden){
    const px = state.street.inCar ? (car.x+car.w/2) : (sophia.x+6);
    const py = state.street.inCar ? (car.y-6) : (sophia.y-10);
    const v = worldToView(px,py);
    drawHintBubble(z.name, v.x, v.y);
  }

  drawWantedOverlay(t);
  drawHiddenOverlay(t);
}

/* ==========================================================
   MAIN LOOP
   ========================================================== */

let t=0;
function loop(){
  t++;

  // If wanted>0 and not seen (or hidden), decay eventually
  if(state.street.wanted>0){
    // If hidden, cops lose quicker
    if(state.street.hidden){
      state.street.seenTimer += 2.0;
    }
    // If in car going fast, you still might be "seen" (handled in cops)
    coolWanted();
  }

  handleButtons();
  updateNPCs(t);
  updateShots();
  updateCops(t);
  updatePlayer(t);
  updateCamera();

  // occasional tiny ambient line
  if(t%900===0 && state.street.wanted===0){
    toast("Somewhere downtown: a neon sign buzzes like it’s thinking.", 1700);
  }

  // autosave
  if(t%60===0){
    state.sophia.x=sophia.x; state.sophia.y=sophia.y;
    state.milo.x=milo.x; state.milo.y=milo.y;
    state.street.car={x:car.x,y:car.y,vx:car.vx,vy:car.vy};
    saveState();
  }

  draw(t);
  requestAnimationFrame(loop);
}
loop();

/* ==========================================================
   NOTE: Keys logic
   - In your world, keys should ONLY come from the backyard gnome chase.
   - This page respects state.hasKeys (from other pages).
   ========================================================== */
</script>
</body>
</html>
